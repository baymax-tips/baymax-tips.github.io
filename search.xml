<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker入门系列  9. Docker 容器的数据管理  数据卷 绑定挂载 临时挂载</title>
      <link href="/posts/37415.html"/>
      <url>/posts/37415.html</url>
      
        <content type="html"><![CDATA[<p>因为容器技术，重新构建并运行应用变得容易且快速，容器化应用基本是无需进一步配置的（已经打包好所有依赖并且已配置），只需PULL，然后Deploy（也许还需要一份docker-compose.yml）就好。我们无需太担心硬件，OS，库以及应用本身的潜在Bug导致应用挂掉，挂掉就挂掉吧，销毁然后重新运行一个新的就好，而且马上就可Ready。我们需要重点关心的是如何保存，备份，恢复应用产生的数据.</p><p>默认情况下，在容器内创建的所有文件都存储在可写容器层上。这意味着：</p><blockquote><ul><li>当该容器不再存在时，数据将不会持久保存，并且如果另一个进程需要它，则可能很难从容器中取出数据。</li><li>容器的可写层与运行容器的主机紧密耦合。您不能轻易地将数据移动到其他地方。</li><li>写入容器的可写层需要 存储驱动程序来管理文件系统。存储驱动程序使用Linux内核提供联合文件系统。与使用直接写入主机文件系统的数据卷相比，这种额外的抽象降低了性能 。</li></ul></blockquote><p><strong>Docker为容器提供了两个选项来将文件存储在主机中，以便即使容器停止后文件也可以持久存储：<code>数据卷</code>和 <code>绑定挂载</code>。如果您在Linux上运行Docker，则还可以使用<code>tmpfs</code>挂载。</strong></p><h2 id="1-Docker-数据挂载类型"><a href="#1-Docker-数据挂载类型" class="headerlink" title="1. Docker 数据挂载类型"></a>1. Docker 数据挂载类型</h2><p>无论您选择使用哪种类型的挂载，容器中的数据看起来都是相同的。它在容器的文件系统中显示为目录或单个文件。</p><p>区分数据卷，绑定挂载和tmpfs 挂载之间差异的一种简单方法就是考虑数据在Docker主机上实际存储的位置。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589544331/hexo/docker/types-of-mounts_i9si3p.png" alt="type of mounts"></p><ul><li><p><strong>数据卷（data volumes）</strong>: 存储在主机文件系统的一部分中，该文件系统由Docker管理（/var/lib/docker/volumes/在Linux上）。非Docker进程不应修改文件系统的这一部分。卷是在Docker中持久保存数据的最佳方法。</p></li><li><p><strong>绑定挂载（bind mounts）</strong>: 可以存储在主机系统上的任何位置。它们甚至可能是重要的系统文件或目录。Docker主机或Docker容器上的非Docker进程可以随时对其进行修改。</p></li><li><p><strong>临时挂载 （<code>tmpfs mounts</code>）</strong> 仅存储在主机系统的内存中，并且永远不会写入主机系统的文件系统中。</p></li></ul><h3 id="1-1-数据卷（data-volumes）"><a href="#1-1-数据卷（data-volumes）" class="headerlink" title="1.1 数据卷（data volumes）"></a>1.1 数据卷（data volumes）</h3><p><strong>数据卷</strong> 由Docker创建和管理。您可以使用<code>docker volume create</code>命令显式创建卷，或者Docker可以在容器或服务创建期间创建卷。</p><p>创建卷时，它存储在Docker主机上的目录中。将卷装入容器时，此目录就是装入容器的目录。这类似于绑定安装的工作方式，除了卷由Docker管理并且与主机的核心功能隔离。</p><p>已创建的数据卷可以同时安装到多个容器中。当没有正在运行的容器使用卷时，该卷仍可用于Docker，并且不会自动删除。您可以使用删除未使用的卷<code>docker volume prune</code>。</p><p>挂载卷时，它可以<strong>命名卷</strong>或<strong>匿名卷</strong>。匿名卷首次安装到容器中时，不会为其指定明确的名称，因此Docker为它们提供一个随机名称，该名称在给定的Docker主机中保证是唯一的。除了名称之外，命名卷和匿名卷的行为也相同。</p><p>卷还支持使用卷驱动程序，该驱动程序使您可以将数据存储在远程主机或云提供商上，以及其他可能性。</p><h4 id="1-1-1-数据卷-应用场景"><a href="#1-1-1-数据卷-应用场景" class="headerlink" title="1.1.1 数据卷 应用场景"></a>1.1.1 数据卷 应用场景</h4><ul><li><p>数据卷是将数据持久保存在Docker容器和服务中的首选方法。卷的一些用例包括：</p></li><li><p>在多个运行中的容器之间共享数据。如果未显式创建卷，则在首次将卷安装到容器中时将创建该卷。当该容器停止或卸下时，该卷仍然存在。多个容器可以同时装载相同的卷（可读写或只读）。仅在显式删除卷时才将它们删除。</p></li><li><p>不保证Docker主机具有给定的目录或文件结构时。卷可帮助您将Docker主机的配置与容器运行时解耦。</p></li><li><p>当您要将容器的数据存储在远程主机或云提供商上时，而不是在本地。</p></li><li><p>当您需要将数据从一个Docker主机备份，还原或迁移到另一个Docker主机时，卷是一个更好的选择。您可以停止使用该卷的容器，然后备份该卷的目录（例如/var/lib/docker/volumes/<volume-name>）。</volume-name></p></li></ul><h3 id="1-2-绑定挂载（bind-mounts）"><a href="#1-2-绑定挂载（bind-mounts）" class="headerlink" title="1.2 绑定挂载（bind mounts）"></a>1.2 绑定挂载（bind mounts）</h3><p><strong>绑定挂载</strong> 自Docker早期以来可用。与卷相比，绑定安装的功能有限。使用绑定安装时，主机上的文件或目录将安装到容器中。文件或目录由主机上的完整路径引用。该文件或目录不需要在Docker主机上已经存在。如果尚不存在，则按需创建。绑定挂载性能非常好，但是它们依赖于具有特定目录结构的主机文件系统。如果要开发新的Docker应用程序，请考虑使用命名卷。您不能使用Docker CLI命令直接管理绑定安装。</p><blockquote><p><strong><code>绑定安装允许访问敏感文件</code></strong></p><p>使用绑定挂载的好与坏的一个副作用是，您可以通过 <strong>容器中</strong> 运行的进程来更改 <strong>主机</strong> 文件系统 ，包括创建，修改或删除重要的系统文件或目录。这是一项强大的功能，可能会带来安全隐患，包括影响主机系统上的非Docker进程。</p></blockquote><h4 id="1-2-1-绑定挂载-应用场景"><a href="#1-2-1-绑定挂载-应用场景" class="headerlink" title="1.2.1 绑定挂载 应用场景"></a>1.2.1 绑定挂载 应用场景</h4><p>通常情况下，应尽可能使用数据卷。绑定挂载适用于以下类型的应用场景：</p><ul><li><p>将配置文件从主机共享到容器。默认情况下，这就是Docker通过/etc/resolv.conf从主机安装到每个容器的方式为容器提供DNS解析的方式 。</p></li><li><p>在Docker主机上的开发环境和容器之间共享源代码或构建工件。例如，您可以将Maven target/ 目录安装到容器中，并且每次在Docker主机上构建Maven项目时，容器都可以访问重建的工件。<br><br>如果您以这种方式使用Docker进行开发，那么您的生产Dockerfile会将生产就绪的工件直接复制到映像中，而不是依赖于绑定安装。</p></li><li><p>当确保Docker主机的文件或目录结构与容器所需的绑定挂载一致时。</p></li></ul><h3 id="1-3-临时挂载（tmpfs-mounts）"><a href="#1-3-临时挂载（tmpfs-mounts）" class="headerlink" title="1.3 临时挂载（tmpfs mounts）"></a>1.3 临时挂载（<code>tmpfs mounts</code>）</h3><p><strong><code>临时挂载</code></strong> 不会持久化在磁盘上，无论是在Docker主机上还是在容器内。容器在其生存期内可以使用它来存储非持久状态或敏感信息。例如，在内部，群集服务使用<code>tmpfs</code>安装将机密安装到服务的容器中。</p><h4 id="1-3-1-临时挂载-应用场景"><a href="#1-3-1-临时挂载-应用场景" class="headerlink" title="1.3.1 临时挂载 应用场景"></a>1.3.1 临时挂载 应用场景</h4><p>当您不希望数据在主机上或容器内持久存在时，最好使用mount。当您的应用程序需要写入大量非持久状态数据时，这可能是出于安全原因或为了保护容器的性能。</p><hr><p><strong>绑定挂载和数据卷都可以使用<code>-v</code>或 <code>--volume</code>标志挂载到容器中，但是两者的语法略有不同。对于<code>tmpfs</code> 挂载，您可以使用该<code>--tmpfs</code>标志。但是，在Docker 17.06及更高版本中，建议将<code>--mount</code>标志用于容器和服务，用于<code>绑定挂载</code>，<code>数据卷</code>或<code>tmpfs挂载</code>，因为语法更清晰。</strong></p><p><strong>如果使用绑定挂载或数据卷，请牢记以下几点：</strong></p><ul><li><p>如果将空卷装载到存在文件或目录的容器中的目录中，则这些文件或目录将传播（复制）到该卷中。同样，如果启动一个容器并指定一个尚不存在的卷，则会为您创建一个空卷。这是预填充另一个容器所需数据的好方法。</p></li><li><p>如果将绑定挂载或非空卷挂载到存在某些文件或目录的容器中的目录中，则这些文件或目录会被挂载遮盖，就像您将文件保存到Linux主机上的/mnt目，然后再挂载USB驱动器到/mnt。/mnt的内容将由USB驱动器遮盖，直至USB驱动器的内容被卸载。被遮盖的文件不会被删除或更改，但是在挂载绑定挂载或数据卷时将无法访问。</p></li></ul><h2 id="2-使用数据卷"><a href="#2-使用数据卷" class="headerlink" title="2. 使用数据卷"></a>2. 使用数据卷</h2><p>数据卷是用于持久化由Docker容器生成和使用的数据的首选机制。尽管绑定挂载取决于主机的目录结构，但是卷完全由Docker管理。与绑定挂载相比，卷具有几个优点：</p><ul><li>与绑定挂载相比，卷更易于备份或迁移。</li><li>您可以使用Docker CLI命令或Docker API管理卷。</li><li>卷在Linux和Windows容器上均可工作。</li><li>可以在多个容器之间更安全地共享卷。</li><li>卷驱动程序使您可以将卷存储在远程主机或云提供商上，以加密卷内容或添加其他功能。</li><li>新卷的内容可以由容器预先填充。</li></ul><p>此外，与将数据持久保存在容器的可写层中相比，卷通常是更好的选择，因为卷不会增加使用卷的容器的大小，并且卷的内容存在于给定容器的生命周期之外。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589547649/hexo/docker/types-of-mounts-volume_yrodyo.png" alt="type of mounts volume"></p><p>如果您的容器生成非持久状态数据，请考虑使用 <code>tmpfs挂载</code>以避免将数据永久存储在任何地方，并通过避免写入容器的可写层来提高容器的性能。</p><p>卷使用rprivate绑定传播，并且绑定传播无法为卷配置。</p><h3 id="2-1-选择-v-或-–mount-标志"><a href="#2-1-选择-v-或-–mount-标志" class="headerlink" title="2.1 选择 -v 或 –mount 标志"></a>2.1 选择 -v 或 –mount 标志</h3><p>最初，<code>-v</code>or <code>--volume</code>标志用于独立容器，而<code>--mount</code>标志用于集群服务。但是，从Docker 17.06开始，您还可以使用<code>--mount</code>独立容器。总的来说， <code>--mount</code>是更明确和冗长的。最大的区别是该<code>-v</code> 语法将所有选项合并在一个字段中，而<code>--mount</code> 语法将它们分开。这是每个标志的语法比较。</p><blockquote><p>新用户应该尝试<code>--mount</code>比<code>--volume</code>语法更简单的语法。</p></blockquote><p>如果需要指定数据卷驱动程序选项，则必须使用<code>--mount</code>。</p><ul><li><p><code>-v</code>或<code>--volume</code>：由三个字段组成，以冒号（:）分隔。这些字段必须以正确的顺序排列，并且每个字段的含义不是立即显而易见的。</p><ul><li>对于命名卷，第一个字段是卷的名称，在给定的主机上是唯一的。对于匿名卷，将省略第一个字段。</li><li>第二个字段是文件或目录在容器中的挂载路径。</li><li>第三个字段是可选的，并且是逗号分隔的选项列表，例如<code>ro</code>。这些选项将在下面讨论。</li></ul></li><li><p><code>--mount</code>：包含多个键值对，以逗号分隔，每个键值对都由一个<code>&lt;key&gt;=&lt;value&gt;</code>元组组成。该<code>--mount</code>语法比<code>-v</code>或<code>--volume</code>更详细，但关键字的顺序并不重要，并且键值对的值更容易理解。</p><ul><li>该type挂载，其可以是bind，volume，或 tmpfs。本主题讨论卷，因此类型始终为 volume。</li><li>该source的挂载。对于命名卷，这是卷的名称。对于匿名卷，将省略此字段。可以指定为source 或src。</li><li>该destination作为其值，其中的文件或目录被挂载在容器的路径。可以指定为destination，dst或target。</li><li>该readonly选项（如果存在）会使绑定挂载以只读方式安装到容器中。</li><li>该volume-opt选项 可以多次指定的选项，采用键值对，该键值对由选项名称及其值组成。</li></ul></li></ul><blockquote><p><strong>从外部CSV解析器转义值</strong></p><p>如果您的卷驱动程序接受逗号分隔的列表作为选项，则必须从外部CSV解析器中转义该值。要对<code>volume-opt</code>进行转义，请用双引号（<code>"</code>）包围，并用单引号（<code>'</code>）包围整个mount参数。</p><p>例如，<code>local</code>驱动程序接受挂载选项作为<code>o</code>参数中逗号分隔的列表。此示例显示了转义列表的正确方法。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker <span class="token function">service</span> create \     --mount <span class="token string">'type=volume,src=&lt;VOLUME-NAME>,dst=&lt;CONTAINER-PATH>,volume-driver=local,volume-opt=type=nfs,volume-opt=device=&lt;nfs-server>:&lt;nfs-path>,"volume-opt=o=addr=&lt;nfs-address>,vers=4,soft,timeo=180,bg,tcp,rw"'</span>    --name myservice \    <span class="token operator">&lt;</span>IMAGE<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>下面的示例在可能的情况下同时显示<code>--mount</code>和<code>-v</code>语法，并 <code>--mount</code>首先展示。</p><p><strong><code>-v</code>和<code>--mount</code>之间的差异</strong></p><blockquote><p>与绑定装载相反，所有数据卷选项都可用于 –mount和-v标志。</p><p>将数据卷与服务一起使用时，仅–mount支持。</p></blockquote><h3 id="2-2-创建和管理卷"><a href="#2-2-创建和管理卷" class="headerlink" title="2.2 创建和管理卷"></a>2.2 创建和管理卷</h3><p>与绑定装载不同，您可以在任何容器范围之外创建和管理卷。</p><h4 id="2-2-1-创建一个卷："><a href="#2-2-1-创建一个卷：" class="headerlink" title="2.2.1 创建一个卷："></a>2.2.1 创建一个卷：</h4><pre class="line-numbers language-bash"><code class="language-bash">docker volume create my-vol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果如下</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker volume create my-volmy-vol<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-2-2-查询卷："><a href="#2-2-2-查询卷：" class="headerlink" title="2.2.2 查询卷："></a>2.2.2 查询卷：</h4><pre class="line-numbers language-bash"><code class="language-bash">docker volume <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果如下</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker volume <span class="token function">ls</span>DRIVER              VOLUME NAMElocal               my-vol<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-2-3-检查卷："><a href="#2-2-3-检查卷：" class="headerlink" title="2.2.3 检查卷："></a>2.2.3 检查卷：</h4><pre class="line-numbers language-bash"><code class="language-bash">docker volume inspect my-vol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果如下</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker volume inspect my-vol<span class="token punctuation">[</span>    <span class="token punctuation">{</span>        <span class="token string">"CreatedAt"</span><span class="token keyword">:</span> <span class="token string">"2020-05-15T14:31:20Z"</span>,        <span class="token string">"Driver"</span><span class="token keyword">:</span> <span class="token string">"local"</span>,        <span class="token string">"Labels"</span><span class="token keyword">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>,        <span class="token string">"Mountpoint"</span><span class="token keyword">:</span> <span class="token string">"/var/lib/docker/volumes/my-vol/_data"</span>,        <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"my-vol"</span>,        <span class="token string">"Options"</span><span class="token keyword">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>,        <span class="token string">"Scope"</span><span class="token keyword">:</span> <span class="token string">"local"</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-4-删除卷："><a href="#2-2-4-删除卷：" class="headerlink" title="2.2.4 删除卷："></a>2.2.4 删除卷：</h4><pre class="line-numbers language-bash"><code class="language-bash">docker volume <span class="token function">rm</span> my-vol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行结果如下</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker volume <span class="token function">rm</span> my-volmy-vol<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-3-启动有数据卷的容器"><a href="#2-3-启动有数据卷的容器" class="headerlink" title="2.3 启动有数据卷的容器"></a>2.3 启动有数据卷的容器</h3><p>如果您使用尚不存在的卷启动容器，则Docker将为您创建该卷。以下示例将卷myvol2装入 /app/容器中。</p><p>下面的-v和–mount示例产生相同的结果。您不能同时运行它们，除非在运行第一个devtest容器和myvol2卷之后将其删除。</p><p><strong><code>--mount</code></strong></p><pre class="line-numbers language-bash"><code class="language-bash">docker run -d \  --name devtest \  --mount source<span class="token operator">=</span>myvol2,target<span class="token operator">=</span>/app \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>-v</code></strong></p><pre class="line-numbers language-bash"><code class="language-bash">docker run -d \  --name devtest \  -v myvol2:/app \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>docker inspect devtest</code>验证创建卷并安装正确。查找<code>Mounts</code>部分：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token string">"Mounts"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                <span class="token string">"Type"</span><span class="token keyword">:</span> <span class="token string">"volume"</span>,                <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"myvol2"</span>,                <span class="token string">"Source"</span><span class="token keyword">:</span> <span class="token string">"/var/lib/docker/volumes/myvol2/_data"</span>,                <span class="token string">"Destination"</span><span class="token keyword">:</span> <span class="token string">"/app"</span>,                <span class="token string">"Driver"</span><span class="token keyword">:</span> <span class="token string">"local"</span>,                <span class="token string">"Mode"</span><span class="token keyword">:</span> <span class="token string">"z"</span>,                <span class="token string">"RW"</span><span class="token keyword">:</span> true,                <span class="token string">"Propagation"</span><span class="token keyword">:</span> <span class="token string">""</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这表明安装是一个卷，它显示了正确的源和目标，并且该安装是可读写的。</p><p>停止容器并移除数据卷。数据卷清除是一个单独的步骤。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container stop devtest$ docker container <span class="token function">rm</span> devtest$ docker volume <span class="token function">rm</span> myvol2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-启动有数据卷的服务"><a href="#2-4-启动有数据卷的服务" class="headerlink" title="2.4 启动有数据卷的服务"></a>2.4 启动有数据卷的服务</h3><p>启动服务并定义卷时，每个服务容器都使用其自己的本地卷。如果您使用local 卷驱动程序，则没有一个容器可以共享此数据，但是某些卷驱动程序确实支持共享存储。适用于AWS的Docker和适用于Azure的Docker均使用Cloudstor插件支持持久存储。</p><p>以下示例nginx以四个副本启动服务，每个副本使用一个称为的本地卷myvol2。</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">service</span> create -d \  --replicas<span class="token operator">=</span>4 \  --name devtest-service \  --mount source<span class="token operator">=</span>myvol2,target<span class="token operator">=</span>/app \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用docker service ps devtest-service验证服务正在运行：</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker <span class="token function">service</span> <span class="token function">ps</span> devtest-serviceID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE           ERROR               PORTSwmvbs25isoi9        devtest-service.1   nginx:latest        docker-desktop      Running             Running 6 seconds ago6nai1zccabj2        devtest-service.2   nginx:latest        docker-desktop      Running             Running 6 seconds agoj1czn1oz2uk6        devtest-service.3   nginx:latest        docker-desktop      Running             Running 6 seconds agoullg50sx5g8p        devtest-service.4   nginx:latest        docker-desktop      Running             Running 6 seconds ago<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除该服务，这将停止其所有任务：</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">service</span> <span class="token function">rm</span> devtest-service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除服务不会删除该服务创建的任何卷。卷删除是一个单独的步骤。</p><p><strong>服务的语法差异</strong></p><p>该docker service create命令不支持<code>-v</code>or <code>--volume</code>标志。将卷装入服务的容器时，必须使用该<code>--mount</code> 标志。</p><h3 id="2-5-使用容器填充数据卷"><a href="#2-5-使用容器填充数据卷" class="headerlink" title="2.5 使用容器填充数据卷"></a>2.5 使用容器填充数据卷</h3><p>如果如上所述启动一个容器来创建新的卷，并且该容器在要挂载的目录（例如/app/上面）中具有文件或目录，则目录的内容将复制到该卷中。然后，该容器将安装并使用该卷，并且使用该卷的其他容器也可以访问预填充的内容。</p><p>为了说明这一点，此示例启动一个nginx容器，并nginx-vol使用容器/usr/share/nginx/html目录的内容填充新卷，Nginx 在该 目录中存储其默认HTML内容。</p><p>在<code>--mount</code>和<code>-v</code>实施例具有相同的最终结果。</p><p><strong><code>--mount</code></strong></p><pre class="line-numbers language-bash"><code class="language-bash">docker run -d \  --name<span class="token operator">=</span>nginxtest \  --mount source<span class="token operator">=</span>nginx-vol,destination<span class="token operator">=</span>/usr/share/nginx/html \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>-v</code></strong></p><pre class="line-numbers language-bash"><code class="language-bash">docker run -d \  --name<span class="token operator">=</span>nginxtest \  -v nginx-vol:/usr/share/nginx/html \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>运行这些示例中的任何一个之后，请运行以下命令以清理容器和卷。数据卷清除是一个单独的步骤。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container stop nginxtest$ docker container <span class="token function">rm</span> nginxtest$ docker volume <span class="token function">rm</span> nginx-vol<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-使用只读数据卷"><a href="#2-6-使用只读数据卷" class="headerlink" title="2.6 使用只读数据卷"></a>2.6 使用只读数据卷</h3><p>对于某些开发应用程序，容器需要写入绑定安装，以便将更改传播回Docker主机。在其他时候，容器仅需要对数据的读取访问权限。请记住，多个容器可以挂载相同的卷，并且可以同时对其中一些容器进行读写安装，而对其他容器则同时进行只读安装。</p><p>此示例修改了上面的示例，但通过ro在容器中的安装点之后添加到（默认为空）选项列表中，将目录作为只读卷安装。如果存在多个选项，请用逗号分隔。</p><p>在<code>--mount</code>和<code>-v</code>实例有同样的结果。</p><p><strong><code>--mount</code></strong></p><pre class="line-numbers language-bash"><code class="language-bash">docker run -d \  --name<span class="token operator">=</span>nginxtest \  --mount source<span class="token operator">=</span>nginx-vol,destination<span class="token operator">=</span>/usr/share/nginx/html,readonly \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>-v</code></strong></p><pre class="line-numbers language-bash"><code class="language-bash">docker run -d \  --name<span class="token operator">=</span>nginxtest \  -v nginx-vol:/usr/share/nginx/html:ro \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用docker inspect nginxtest验证只读mount正确创建。查找Mounts部分：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token string">"Mounts"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>        <span class="token string">"Type"</span><span class="token keyword">:</span> <span class="token string">"volume"</span>,        <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"nginx-vol"</span>,        <span class="token string">"Source"</span><span class="token keyword">:</span> <span class="token string">"/var/lib/docker/volumes/nginx-vol/_data"</span>,        <span class="token string">"Destination"</span><span class="token keyword">:</span> <span class="token string">"/usr/share/nginx/html"</span>,        <span class="token string">"Driver"</span><span class="token keyword">:</span> <span class="token string">"local"</span>,        <span class="token string">"Mode"</span><span class="token keyword">:</span> <span class="token string">""</span>,        <span class="token string">"RW"</span><span class="token keyword">:</span> false,        <span class="token string">"Propagation"</span><span class="token keyword">:</span> <span class="token string">""</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>停止并移除容器，然后移除数据卷。卷删除是一个单独的步骤。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container stop nginxtest$ docker container <span class="token function">rm</span> nginxtest$ docker volume <span class="token function">rm</span> nginx-vol<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-7-在机器之间共享数据"><a href="#2-7-在机器之间共享数据" class="headerlink" title="2.7 在机器之间共享数据"></a>2.7 在机器之间共享数据</h3><p>在构建容错应用程序时，您可能需要配置同一服务的多个副本才能访问相同的文件。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589637195/hexo/docker/volumes-shared-storage_vodngr.png" alt="volumes-shared-storage"></p><p>开发应用程序时，有几种方法可以实现此目的。一种是向您的应用程序添加逻辑，以将文件存储在像Amazon S3这样的云对象存储系统上。另一个方法是使用支持将文件写入外部存储系统（例如NFS或Amazon S3）的驱动程序来创建卷。</p><p>卷驱动程序使您可以从应用程序逻辑中抽象底层存储系统。例如，如果您的服务使用带有NFS驱动程序的卷，则可以更新服务以使用其他驱动程序（例如，将数据存储在云中），而无需更改应用程序逻辑。</p><h3 id="2-8-使用数据卷驱动器"><a href="#2-8-使用数据卷驱动器" class="headerlink" title="2.8 使用数据卷驱动器"></a>2.8 使用数据卷驱动器</h3><p>当使用创建卷时<code>docker volume create</code>，或者启动使用尚未创建的卷的容器时，可以指定卷驱动器。以下示例<code>vieux/sshfs</code>首先在创建独立卷时使用卷驱动程序，然后在启动创建新卷的容器时使用卷驱动程序。</p><h4 id="2-8-1-初始化设置"><a href="#2-8-1-初始化设置" class="headerlink" title="2.8.1 初始化设置"></a>2.8.1 初始化设置</h4><p>本示例假定您有两个节点，其中第一个是Docker主机，并且可以使用SSH连接到第二个。</p><p>在Docker主机上，安装vieux/sshfs插件：</p><pre class="line-numbers language-bash"><code class="language-bash">docker plugin <span class="token function">install</span> --grant-all-permissions vieux/sshfs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-8-2-使用卷驱动程序创建卷"><a href="#2-8-2-使用卷驱动程序创建卷" class="headerlink" title="2.8.2 使用卷驱动程序创建卷"></a>2.8.2 使用卷驱动程序创建卷</h4><p>此示例指定了SSH密码，但是如果两个主机都配置了共享密钥，则可以省略该密码。每个卷驱动程序可能具有零个或多个可配置选项，每个选项都使用一个-o标志指定。</p><pre class="line-numbers language-bash"><code class="language-bash">docker volume create --driver vieux/sshfs \  -o sshcmd<span class="token operator">=</span>test@node2:/home/test \  -o password<span class="token operator">=</span>testpassword \  sshvolume<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-8-3-启动一个使用卷驱动程序创建卷的容器"><a href="#2-8-3-启动一个使用卷驱动程序创建卷的容器" class="headerlink" title="2.8.3 启动一个使用卷驱动程序创建卷的容器"></a>2.8.3 启动一个使用卷驱动程序创建卷的容器</h4><p>此示例指定了SSH密码，但是如果两个主机都配置了共享密钥，则可以省略该密码。每个卷驱动程序可能具有零个或多个可配置选项。<strong>如果卷驱动程序要求您传递选项，则必须使用该–mount标志而不是来安装卷-v</strong>。</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -d \  --name sshfs-container \  --volume-driver vieux/sshfs \  --mount src<span class="token operator">=</span>sshvolume,target<span class="token operator">=</span>/app,volume-opt<span class="token operator">=</span>sshcmd<span class="token operator">=</span>test@node2:/home/test,volume-opt<span class="token operator">=</span>password<span class="token operator">=</span>testpassword \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-8-4-创建一个创建NFS卷的服务"><a href="#2-8-4-创建一个创建NFS卷的服务" class="headerlink" title="2.8.4 创建一个创建NFS卷的服务"></a>2.8.4 创建一个创建NFS卷的服务</h4><p>本示例说明了创建服务时如何创建NFS卷。本示例<code>10.0.0.10</code>用作NFS服务器和NFS服务器上<code>/var/docker-nfs</code>的导出目录。请注意，指定的音量驱动程序为<code>local</code>。</p><p><strong>NFSV3</strong></p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">service</span> create -d \  --name nfs-service \  --mount <span class="token string">'type=volume,source=nfsvolume,target=/app,volume-driver=local,volume-opt=type=nfs,volume-opt=device=:/var/docker-nfs,volume-opt=o=addr=10.0.0.10'</span> \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>NFSV4</strong></p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">service</span> create -d \    --name nfs-service \    --mount <span class="token string">'type=volume,source=nfsvolume,target=/app,volume-driver=local,volume-opt=type=nfs,volume-opt=device=:/,"volume-opt=o=10.0.0.10,rw,nfsvers=4,async"'</span> \    nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-9-备份，还原或迁移数据卷"><a href="#2-9-备份，还原或迁移数据卷" class="headerlink" title="2.9 备份，还原或迁移数据卷"></a>2.9 备份，还原或迁移数据卷</h3><p>卷对于备份，还原和迁移很有用。使用该 –volumes-from标志创建一个安装该卷的新容器。</p><h4 id="2-9-1-备份容器"><a href="#2-9-1-备份容器" class="headerlink" title="2.9.1 备份容器"></a>2.9.1 备份容器</h4><p>例如，在下一个命令中，我们：</p><ul><li>启动一个新容器并从该dbstore容器装入卷</li><li>将本地主机目录挂载为 /backup</li><li>将命令将dbdata卷的内容放到目录中的backup.tar文件中/backup。</li></ul><pre class="line-numbers language-bash"><code class="language-bash">docker run --rm --volumes-from dbstore -v <span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>:/backup ubuntu <span class="token function">tar</span> cvf /backup/backup.tar /dbdata<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当命令完成并且容器停止时，我们将获得<code>dbdata</code>卷的备份。</p><h4 id="2-9-2-从备份还原容器"><a href="#2-9-2-从备份还原容器" class="headerlink" title="2.9.2 从备份还原容器"></a>2.9.2 从备份还原容器</h4><p>使用刚刚创建的备份，您可以将其还原到同一容器或在其他位置创建的另一个容器。</p><p>例如，创建一个名为的新容器dbstore2：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -v /dbdata --name dbstore2 ubuntu /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后将备份文件解压缩到新容器的数据卷中：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run --rm --volumes-from dbstore2 -v <span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>:/backup ubuntu <span class="token function">bash</span> -c <span class="token string">"cd /dbdata &amp;&amp; tar xvf /backup/backup.tar --strip 1"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您可以使用首选工具使用上述技术来自动执行备份，迁移和还原测试。</p><h3 id="2-10-删除卷"><a href="#2-10-删除卷" class="headerlink" title="2.10 删除卷"></a>2.10 删除卷</h3><p>删除容器后，Docker数据卷仍然存在。有两种类型的卷需要考虑：</p><ul><li><strong>命名卷</strong> 具有来自容器外部的特定来源，例如<code>awesome:/bar</code>。</li><li><strong>匿名卷</strong> 没有特定来源，因此在删除容器时，请指示Docker Engine守护程序将其删除。</li></ul><h4 id="2-10-1-删除匿名卷"><a href="#2-10-1-删除匿名卷" class="headerlink" title="2.10.1 删除匿名卷"></a>2.10.1 删除匿名卷</h4><p>要自动删除匿名卷，请使用该<code>--rm</code>选项。例如，此命令创建一个匿名<code>/foo</code>卷。删除容器后，Docker Engine会删除该<code>/foo</code>卷，但不会删除该<code>awesome</code>卷。</p><pre class="line-numbers language-bash"><code class="language-bash">docker run --rm -v /foo -v awesome:/bar busybox <span class="token function">top</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-10-2-删除所有卷"><a href="#2-10-2-删除所有卷" class="headerlink" title="2.10.2 删除所有卷"></a>2.10.2 删除所有卷</h4><p>要删除所有未使用的卷并释放空间：</p><pre class="line-numbers language-bash"><code class="language-bash">docker volume prune<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-使用绑定挂载"><a href="#3-使用绑定挂载" class="headerlink" title="3. 使用绑定挂载"></a>3. 使用绑定挂载</h2><p>自Docker诞生以来，绑定挂载就已经存在。与<code>卷</code>相比，绑定安装的功能有限。使用绑定安装时，主机上的文件或目录将安装到容器中。该文件或目录由主机上的完整或相对路径引用。相比之下，当您使用卷时，将在主机上的Docker的存储目录中创建一个新目录，并且Docker管理该目录的内容。</p><p>该文件或目录不需要在Docker主机上已经存在。如果尚不存在，则按需创建。绑定挂载性能非常好，但是它们依赖于具有特定目录结构的主机文件系统。如果要开发新的Docker应用程序，请考虑使用<code>命名卷</code>。您不能使用Docker CLI命令直接管理绑定安装。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589638340/hexo/docker/types-of-mounts-bind_rvrxbl.png" alt="types-of-mounts-bind"></p><h3 id="3-1-选择-v或–mount标志"><a href="#3-1-选择-v或–mount标志" class="headerlink" title="3.1 选择-v或–mount标志"></a>3.1 选择-v或–mount标志</h3><p>最初，-vor –volume标志用于独立容器，而–mount标志用于集群服务。但是，从Docker 17.06开始，您还可以使用–mount独立容器。总的来说， –mount是更明确和冗长的。最大的区别是该-v 语法将所有选项合并在一个字段中，而–mount 语法将它们分开。这是每个标志的语法比较。</p><blockquote><p><strong>提示</strong>：新用户应使用–mount语法。有经验的用户可能更熟悉-v或–volume语法，但建议使用–mount，因为研究表明它更易于使用。</p></blockquote><ul><li>-v或–volume：由三个字段组成，以冒号（:）分隔。这些字段必须以正确的顺序排列，并且每个字段的含义不是立即显而易见的。<ul><li>对于绑定挂载，第一个字段是主机上文件或目录的路径。</li><li>第二个字段是文件或目录在容器中的安装路径。</li><li>第三个字段是可选的，并且是用逗号分隔的选项，诸如列表ro，consistent，delegated，cached，z，和Z。这些选项将在下面讨论。</li></ul></li><li>–mount：包含多个键值对，以逗号分隔，每个键值对都由一个<key>=<value>元组组成。该–mount语法是更详细的比-v或–volume，但按键的顺序并不显著，并且标志的价值更容易理解。<ul><li>该类型挂载，其可以是bind，volume，或tmpfs。本次讨论绑定挂载，因此类型始终为bind。</li><li>该source的挂载。对于绑定挂载，这是Docker守护程序主机上文件或目录的路径。可以指定为source或 src。</li><li>该destination作为其值，其中的文件或目录被挂载在容器的路径。可以指定为destination，dst或target。</li><li>该readonly选项（如果存在）会使绑定安装以只读方式安装到容器中。</li><li>该bind-propagation选项（如果存在）将更改 绑定传播。可以是一个rprivate， private，rshared，shared，rslave，slave。</li><li>的consistency选项，如果存在，可以是一种consistent，delegated或cached。此设置仅适用于Mac的Docker桌面，在所有其他平台上将被忽略。</li><li>该–mount标志不支持z或没有Z用于修改selinux标签的选项。</li></ul></value></key></li></ul><p>下面的示例在可能的情况下同时显示–mount和-v语法，并 –mount首先展示。</p><p><strong><code>-v</code>和<code>--mount</code>行为之间的差异</strong></p><p>由于<code>-v</code>and <code>--volume</code>标志已经很长时间成为Docker的一部分，因此它们的行为无法更改。这意味着和之间存在一种不同的行为。-v–mount</p><p>如果您使用<code>-v</code>或<code>--volume</code>绑定安装Docker主机上尚不存在的文件或目录，请-v为您创建端点。<strong>始终将其创建为目录</strong>。</p><p>如果您使用–mount绑定贴装尚不泊坞窗主机上存在的文件或目录，码头工人也不会自动为您创建它，但会产生一个错误。</p><h3 id="3-2-使用绑定挂载启动容器"><a href="#3-2-使用绑定挂载启动容器" class="headerlink" title="3.2 使用绑定挂载启动容器"></a>3.2 使用绑定挂载启动容器</h3><p>考虑以下情况：您有一个目录source，并且在构建源代码时，工件会保存到另一个目录中source/target/。您希望这些工件可用于的容器/app/，并且希望每次在开发主机上构建源代码时，容器都可以访问新的构建。使用以下命令将target/ 目录绑定安装到您的容器中，位于/app/。从source目录中运行命令 。该$(pwd)子命令将扩展到Linux或macOS主机上的当前工作目录。</p><p>下面的–mount和-v示例产生相同的结果。您不能同时运行它们，除非devtest在运行第一个容器后删除容器。</p><p><strong><code>--mount</code></strong></p><pre class="line-numbers language-bash"><code class="language-bash">docker run -d \  -it \  --name devtest \  --mount type<span class="token operator">=</span>bind,source<span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target,target<span class="token operator">=</span>/app \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>-v</code></strong></p><pre class="line-numbers language-bash"><code class="language-bash">docker run -d \  -it \  --name devtest \  -v <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target:/app \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>docker inspect devtest</code>验证绑定安装正确创建。查找<code>Mounts</code>部分：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token string">"Mounts"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>        <span class="token string">"Type"</span><span class="token keyword">:</span> <span class="token string">"bind"</span>,        <span class="token string">"Source"</span><span class="token keyword">:</span> <span class="token string">"/tmp/source/target"</span>,        <span class="token string">"Destination"</span><span class="token keyword">:</span> <span class="token string">"/app"</span>,        <span class="token string">"Mode"</span><span class="token keyword">:</span> <span class="token string">""</span>,        <span class="token string">"RW"</span><span class="token keyword">:</span> true,        <span class="token string">"Propagation"</span><span class="token keyword">:</span> <span class="token string">"rprivate"</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这表明该坐骑是一个bind坐骑，它显示了正确的源和目标，表明该坐骑是可读写的，并且传播设置为rprivate。</p><p>停止容器：</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container stop devtest$ docker container <span class="token function">rm</span> devtest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>挂载到容器上的非空目录中</strong></p><p>如果将绑定安装到容器上的非空目录中，则该目录的现有内容将被绑定安装遮盖。这可能是有益的，例如，当您要测试应用程序的新版本而不构建新映像时。但是，这也可能令人惊讶，并且此行为不同于docker volume的行为。</p><p>该示例被认为是极端的，但是用主机上的/usr/目录替换了容器目录的内容/tmp/。在大多数情况下，这将导致容器无法正常工作。</p><p>在–mount和-v实施例具有相同的最终结果。</p><p><strong><code>--mount</code></strong></p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run -d \  -it \  --name broken-container \  --mount type<span class="token operator">=</span>bind,source<span class="token operator">=</span>/tmp,target<span class="token operator">=</span>/usr \  nginx:latestdocker: Error response from daemon: oci runtime error: container_linux.go:262:starting container process caused <span class="token string">"exec: \"nginx\": executable file not found in <span class="token variable">$PATH</span>"</span><span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>-v</code></strong></p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run -d \  -it \  --name broken-container \  -v /tmp:/usr \  nginx:latestdocker: Error response from daemon: oci runtime error: container_linux.go:262:starting container process caused <span class="token string">"exec: \"nginx\": executable file not found in <span class="token variable">$PATH</span>"</span><span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>容器已创建但未启动。去掉它：</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container <span class="token function">rm</span> broken-container<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-3-使用只读绑定挂载"><a href="#3-3-使用只读绑定挂载" class="headerlink" title="3.3 使用只读绑定挂载"></a>3.3 使用只读绑定挂载</h3><p>对于某些开发应用程序，容器需要写入绑定安装，因此更改将传播回Docker主机。在其他时间，容器仅需要读取访问权限。</p><p>此示例修改了上面的示例，但ro通过在容器中的安装点之后添加到（默认为空）选项列表中，将目录作为只读绑定安装进行安装。如果存在多个选项，请用逗号分隔。</p><p>在–mount和-v实例有同样的结果。</p><p><strong><code>--mount</code></strong></p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run -d \  -it \  --name devtest \  --mount type<span class="token operator">=</span>bind,source<span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target,target<span class="token operator">=</span>/app,readonly \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>-v</code></strong></p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run -d \  -it \  --name devtest \  -v <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target:/app:ro \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用docker inspect devtest验证绑定安装正确创建。查找Mounts部分：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token string">"Mounts"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>        <span class="token string">"Type"</span><span class="token keyword">:</span> <span class="token string">"bind"</span>,        <span class="token string">"Source"</span><span class="token keyword">:</span> <span class="token string">"/tmp/source/target"</span>,        <span class="token string">"Destination"</span><span class="token keyword">:</span> <span class="token string">"/app"</span>,        <span class="token string">"Mode"</span><span class="token keyword">:</span> <span class="token string">"ro"</span>,        <span class="token string">"RW"</span><span class="token keyword">:</span> false,        <span class="token string">"Propagation"</span><span class="token keyword">:</span> <span class="token string">"rprivate"</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>停止容器：</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container stop devtest$ docker container <span class="token function">rm</span> devtest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-4-配置绑定传播"><a href="#3-4-配置绑定传播" class="headerlink" title="3.4 配置绑定传播"></a>3.4 配置绑定传播</h3><p><code>rprivate</code>对于绑定安装和卷，绑定传播默认为。它仅可用于绑定安装，并且只能在Linux主机上配置。绑定传播是一个高级主题，许多用户不需要配置它。</p><p>绑定传播是指是否可以将在给定绑定安装或命名卷中创建的安装传播到该安装的副本。考虑一个安装点<code>/mnt</code>，它也安装在上<code>/tmp</code>。传播设置控制是否<code>/tmp/a</code>可以在上安装底座<code>/mnt/a</code>。每个传播设置都有一个递归对点。在递归的情况下，请考虑将<code>/tmp/a</code>其也安装为<code>/foo</code>。传播设置控制是否<code>/mnt/a</code>和/或<code>/tmp/a</code>将存在。</p><br><table><thead><tr><th align="center">传播设置</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>shared</code></td><td align="left">原始安装的子安装暴露于副本安装，副本安装的子安装也传播到原始安装。</td></tr><tr><td align="center"><code>slave</code></td><td align="left">与共享安装类似，但仅在一个方向上。如果原始安装公开了子安装，则副本安装可以看到它。但是，如果副本安装公开了子安装，则原始安装看不到它。</td></tr><tr><td align="center"><code>private</code></td><td align="left">坐骑是私人的。其中的子安装不暴露于副本安装，副本安装的子安装也不暴露于原始安装。</td></tr><tr><td align="center"><code>rshared</code></td><td align="left">与共享相同，但传播也扩展到嵌套在任何原始或副本安装点中的安装点以及从这些安装点扩展。</td></tr><tr><td align="center"><code>rslave</code></td><td align="left">与从属服务器相同，但是传播也扩展到嵌套在任何原始或副本安装点中的安装点以及从这些安装点扩展。</td></tr><tr><td align="center"><code>rprivate</code></td><td align="left">默认值。与专用相同，这意味着原始或副本安装点内的任何安装点都不会向任一方向传播。</td></tr></tbody></table><br><br><p>在可以在安装点上设置绑定传播之前，主机文件系统需要已经支持绑定传播。</p><p>有关绑定传播的更多信息，请参见 Linux内核文档中的共享子树。</p><p>以下示例将target/目录两次安装到容器中，第二次安装同时设置了ro选项和rslave绑定传播选项。</p><p>在–mount和-v实例有同样的结果。</p><p><strong><code>--mount</code></strong></p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run -d \  -it \  --name devtest \  --mount type<span class="token operator">=</span>bind,source<span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target,target<span class="token operator">=</span>/app \  --mount type<span class="token operator">=</span>bind,source<span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target,target<span class="token operator">=</span>/app2,readonly,bind-propagation<span class="token operator">=</span>rslave \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>-v</code></strong></p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run -d \  -it \  --name devtest \  -v <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target:/app \  -v <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target:/app2:ro,rslave \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，如果您创建<code>/app/foo/</code>，它<code>/app2/foo/</code>也存在。</p><h3 id="3-5-配置selinux标签"><a href="#3-5-配置selinux标签" class="headerlink" title="3.5 配置selinux标签"></a>3.5 配置selinux标签</h3><p>如果使用selinux，则可以添加z或Z选项来修改要装入容器的主机文件或目录的selinux标签。这会影响主机本身上的文件或目录，并可能导致超出Docker范围的后果。</p><ul><li>该z选项指示绑定安装内容在多个容器之间共享。</li><li>该Z选项指示绑定安装内容是私有的且未共享。</li></ul><p>这些选项请格外小心。绑定安装系统目录（例如/home或/usr带有该Z选项）会使主机无法运行，并且您可能需要手动重新标记主机文件。</p><blockquote><p><strong>重要说明</strong>：将绑定安装与服务一起使用时，selinux标签（<code>:Z</code>和<code>:z</code>）以及将<code>:ro</code>被忽略。有关详细信息，请参见 <a href="https://github.com/moby/moby/issues/32579" target="_blank" rel="noopener"><code>moby / moby＃32579</code></a>。</p></blockquote><p>本示例设置z选项以指定多个容器可以共享绑定安装的内容：</p><p>无法使用该–mount标志修改selinux标签。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run -d \  -it \  --name devtest \  -v <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target:/app:z \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-配置macOS的挂载一致性"><a href="#3-6-配置macOS的挂载一致性" class="headerlink" title="3.6 配置macOS的挂载一致性"></a>3.6 配置macOS的挂载一致性</h3><p>用于Mac的Docker桌面用于osxfs将从macOS共享的目录和文件传播到Linux VM。这种传播使这些目录和文件可用于在Mac上运行Docker Desktop的Docker容器。</p><p>默认情况下，这些共享是完全一致的，这意味着每次在macOS主机上或通过容器中的挂载进行写操作时，所做的更改都会刷新到磁盘上，以便共享中的所有参与者都具有完全一致的视图。在某些情况下，完全一致性可能会严重影响性能。Docker 17.05及更高版本引入了一些选项，可以针对每个容器，每个容器来调整一致性设置。提供以下选项：</p><ul><li><p><code>consistent</code>或<code>default</code>：如上所述，具有完全一致性的默认设置。</p></li><li><p><code>delegated</code>：容器运行时的挂载视图具有权威性。在主机上看到容器中所做的更新之前可能会有所延迟。</p></li><li><p><code>cached</code>：macOS主机的挂载视图具有权威性。在容器中可以看到主机上所做的更新，这可能会有所延迟。</p></li></ul><p>这些选项在除macOS之外的所有主机操作系统上均被完全忽略。</p><p>在–mount和-v实例有同样的结果。</p><p><strong><code>--mount</code></strong></p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run -d \  -it \  --name devtest \  --mount type<span class="token operator">=</span>bind,source<span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target,destination<span class="token operator">=</span>/app,consistency<span class="token operator">=</span>cached \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>-v</code></strong></p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run -d \  -it \  --name devtest \  -v <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target:/app:cached \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-使用tmpfs-挂载"><a href="#3-使用tmpfs-挂载" class="headerlink" title="3. 使用tmpfs 挂载"></a>3. 使用tmpfs 挂载</h2><p>数据卷和绑定挂载使您可以在主机和容器之间共享文件，以便即使容器停止后也可以保留数据。</p><p>如果您在Linux上运行Docker，则还有第三种选择：tmpfs挂载。当创建带有tmpfs安装架的容器时，该容器可以在该容器的可写层之外创建文件。</p><p>与卷和绑定挂载相反，tmpfs挂载是临时的，并且仅保留在主机内存中。当容器停止时，tmpfs挂载将被删除，并且在其中写入的文件将不会保留。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1590133898/hexo/docker/types-of-mounts-tmpfs_fpwsba.png" alt="types-of-mounts-tmpfs"></p><p>这对于在主机或容器可写层中临时存储您不想持久保存的敏感文件很有用。</p><h3 id="3-1-tmpfs安装的局限性"><a href="#3-1-tmpfs安装的局限性" class="headerlink" title="3.1 tmpfs安装的局限性"></a>3.1 tmpfs安装的局限性</h3><ul><li><p>与卷和绑定安装不同，您不能tmpfs在容器之间共享安装。</p></li><li><p>仅当您在Linux上运行Docker时，此功能才可用。</p></li></ul><h3 id="3-2-选择–tmpfs或–mount标志"><a href="#3-2-选择–tmpfs或–mount标志" class="headerlink" title="3.2 选择–tmpfs或–mount标志"></a>3.2 选择–tmpfs或–mount标志</h3><p>最初，该–tmpfs标志用于独立容器，而该–mount标志用于集群服务。但是，从Docker 17.06开始，您还可以使用–mount独立容器。总的来说， –mount是更明确和冗长的。最大的区别是该 –tmpfs标志不支持任何可配置的选项。</p><ul><li><p>–tmpfs：挂载tmpfs挂载而不允许您指定任何可配置的选项，并且只能与独立容器一起使用。</p></li><li><p>–mount：包含多个键值对，以逗号分隔，每个键值对都由一个<key>=<value>元组组成。该–mount语法比更详细–tmpfs：</value></key></p><ul><li>该type安装件，其可以是bind，volume，或 tmpfs。本主题讨论tmpfs，因此类型始终为 tmpfs。</li><li>的destination作为其值，其中的路径tmpfs安装被安装在容器中。可以指定为destination，dst或target。</li><li>在tmpfs-type和tmpfs-mode选项。请参阅 tmpfs选项。</li></ul></li></ul><p>下面的示例在可能的情况下同时显示–mount和–tmpfs语法，并–mount首先展示。</p><h4 id="–tmpfs和–mount行为之间的差异"><a href="#–tmpfs和–mount行为之间的差异" class="headerlink" title="–tmpfs和–mount行为之间的差异"></a>–tmpfs和–mount行为之间的差异</h4><ul><li>该–tmpfs标志不允许您指定任何可配置的选项。</li><li>该–tmpfs标志不能与群集服务一起使用。您必须使用–mount。</li></ul><h3 id="3-3-在容器中使用tmpfs挂载"><a href="#3-3-在容器中使用tmpfs挂载" class="headerlink" title="3.3 在容器中使用tmpfs挂载"></a>3.3 在容器中使用tmpfs挂载</h3><p>要tmpfs在容器中使用安装座，请使用–tmpfs标志，或将 –mount标志与type=tmpfs和destination选项一起使用。没有 source了tmpfs坐骑。以下示例在Nginx容器中的上创建一个tmpfs安装 /app。第一个示例使用–mount标志，第二个示例使用–tmpfs标志。</p><p><strong>–mount</strong></p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run -d \  -it \  --name tmptest \  --mount type<span class="token operator">=</span>tmpfs,destination<span class="token operator">=</span>/app \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>–tmpfs</strong></p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run -d \  -it \  --name tmptest \  --tmpfs /app \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tmpfs通过运行docker container inspect tmptest并查找以下Mounts部分来验证安装是否为安装：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token string">"Tmpfs"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>    <span class="token string">"/app"</span><span class="token keyword">:</span> <span class="token string">""</span><span class="token punctuation">}</span>,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>卸下容器：</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container stop tmptest$ docker container <span class="token function">rm</span> tmptest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="指定tmpfs选项"><a href="#指定tmpfs选项" class="headerlink" title="指定tmpfs选项"></a>指定tmpfs选项</h4><p>tmpfs安装允许两个配置选项，都不是必需的。如果需要指定这些选项，则必须使用该–mount标志，因为该–tmpfs标志不支持它们。<br><br></p><table><thead><tr><th align="center">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">tmpfs-size</td><td align="left">tmpfs安装的大小（以字节为单位）。默认情况下不受限制。</td></tr><tr><td align="center">tmpfs-mode</td><td align="left">tmpfs的文件模式（八进制）。例如700或0770。默认为1777或世界可写。</td></tr></tbody></table><br><p>以下示例将设置tmpfs-mode为1770，以使其在容器内不被世界范围内读取。</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -d \  -it \  --name tmptest \  --mount type<span class="token operator">=</span>tmpfs,destination<span class="token operator">=</span>/app,tmpfs-mode<span class="token operator">=</span>1770 \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 容器服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门系列  8. Docker 容器网络的概念及网络配置 macvlan</title>
      <link href="/posts/38417.html"/>
      <url>/posts/38417.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-使用-macvlan-网络"><a href="#1-使用-macvlan-网络" class="headerlink" title="1. 使用 macvlan 网络"></a>1. 使用 macvlan 网络</h2><p>有些应用程序，特别是监视网络流量的遗留应用程序或应用程序，希望直接连接到物理网络。 在这种情况下，你可以使用 macvlan 网络驱动程序为每个容器的虚拟网络接口分配一个 MAC 地址，使其看起来像一个直接连接到物理网络的物理网络接口。 在这种情况下，您需要在 Docker 主机上指定一个用于 macvlan 的物理接口，以及 macvlan 的子网和网关。 您甚至可以使用不同的物理网络接口来隔离您的 macvlan 网络。 记住以下几点:</p><ul><li><p>由于 IP 地址耗尽或“ VLAN 扩散” ，很容易无意中损坏您的网络，这种情况下，您的网络中有大量不适当的唯一 MAC 地址。</p></li><li><p>你的网络设备需要能够处理“混杂模式” ，其中一个物理接口可以分配多个 MAC 地址。</p></li><li><p>如果您的应用程序可以使用网桥(在单个 Docker 主机上)或覆盖(跨多个 Docker 主机通信) ，那么从长远来看，这些解决方案可能更好。</p></li></ul><h3 id="1-1-创建一个-macvlan-网络"><a href="#1-1-创建一个-macvlan-网络" class="headerlink" title="1.1 创建一个 macvlan 网络"></a>1.1 创建一个 macvlan 网络</h3><p>当您创建 macvlan 网络时，它可以是桥接模式或802.1 q vlan 桥接模式。</p><ul><li><p>在桥接模式下，macvlan 流量通过主机上的一个物理设备。</p></li><li><p>在802.1 q vlan 桥模式下，流量通过 Docker 动态创建的802.1 q 子接口。 这允许您在更细粒度的级别上控制路由和过滤。</p></li></ul><h3 id="1-2-桥接模式"><a href="#1-2-桥接模式" class="headerlink" title="1.2 桥接模式"></a>1.2 桥接模式</h3><p>要创建一个连接给定物理网络接口的 macvlan 网络，可以使用 <code>--driver macvlan</code> 和 <code>docker network create</code> 命令。 您还需要指定父接口，它是流量将在 Docker 主机上物理地经过的接口。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create -d macvlan \  --subnet<span class="token operator">=</span>172.16.86.0/24 \  --gateway<span class="token operator">=</span>172.16.86.1 \  -o parent<span class="token operator">=</span>eth0 pub_net<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果你需要排除在 macvlan 网络中使用的 IP 地址，比如当一个给定的 IP 地址已经在使用时，使用 – aux-addresses:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create -d macvlan \  --subnet<span class="token operator">=</span>192.168.32.0/24 \  --ip-range<span class="token operator">=</span>192.168.32.128/25 \  --gateway<span class="token operator">=</span>192.168.32.254 \  --aux-address<span class="token operator">=</span><span class="token string">"my-router=192.168.32.129"</span> \  -o parent<span class="token operator">=</span>eth0 macnet32<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-集束桥接模式（vlan）"><a href="#1-3-集束桥接模式（vlan）" class="headerlink" title="1.3 集束桥接模式（vlan）"></a>1.3 集束桥接模式（vlan）</h3><p>如果您指定父接口名称并包含一个点，例如 eth0.50，Docker 将其解释为 eth0的子接口，并自动创建子接口。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create -d macvlan \    --subnet<span class="token operator">=</span>192.168.50.0/24 \    --gateway<span class="token operator">=</span>192.168.50.1 \    -o parent<span class="token operator">=</span>eth0.50 macvlan50<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-4-使用-ipvlan-而不是-macvlan"><a href="#1-4-使用-ipvlan-而不是-macvlan" class="headerlink" title="1.4 使用 ipvlan 而不是 macvlan"></a>1.4 使用 ipvlan 而不是 macvlan</h3><p>在上面的示例中，您仍然在使用 L3桥。 你可以使用 ipvlan 代替，并得到一个 L2桥。 指定 -o ipvlan 模式 l2。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create -d ipvlan \    --subnet<span class="token operator">=</span>192.168.210.0/24 \    --subnet<span class="token operator">=</span>192.168.212.0/24 \    --gateway<span class="token operator">=</span>192.168.210.254 \    --gateway<span class="token operator">=</span>192.168.212.254 \     -o ipvlan_mode<span class="token operator">=</span>l2 ipvlan210<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-5-使用-IPv6"><a href="#1-5-使用-IPv6" class="headerlink" title="1.5 使用 IPv6"></a>1.5 使用 IPv6</h3><p>如果已经将 Docker 守护进程配置为允许 IPv6，则可以使用双栈 ipv4 / IPv6 macvlan 网络。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create -d macvlan \    --subnet<span class="token operator">=</span>192.168.216.0/24 --subnet<span class="token operator">=</span>192.168.218.0/24 \    --gateway<span class="token operator">=</span>192.168.216.1 --gateway<span class="token operator">=</span>192.168.218.1 \    --subnet<span class="token operator">=</span>2001:db8:abc8::/64 --gateway<span class="token operator">=</span>2001:db8:abc8::10 \     -o parent<span class="token operator">=</span>eth0.218 \     -o macvlan_mode<span class="token operator">=</span>bridge macvlan216<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-实践练习-macvlan-网络"><a href="#2-实践练习-macvlan-网络" class="headerlink" title="2. 实践练习 macvlan 网络"></a>2. 实践练习 macvlan 网络</h2><p>该实践处理网络独立的容器连接到 macvlan 网络。 在这种类型的网络中，Docker 主机在其 IP 地址接受对多个 MAC 地址的请求，并将这些请求路由到适当的容器。</p><h3 id="2-1-目标"><a href="#2-1-目标" class="headerlink" title="2.1 目标"></a>2.1 目标</h3><p>目标是建立一个桥接 macvlan 网络和附加一个容器到它，然后建立一个802.1 q 集束聚合 macvlan 网络和附加一个容器到它。</p><h3 id="2-2-先决条件"><a href="#2-2-先决条件" class="headerlink" title="2.2 先决条件"></a>2.2 先决条件</h3><ul><li><p>大多数云提供商都会屏蔽 macvlan 网络，您可能需要对网络设备进行物理访问。</p></li><li><p>Macvlan 网络驱动程序只能在 Linux 主机上使用，而且不支持 Docker Desktop for Mac，Docker Desktop for Windows，或 Docker EE for Windows Server。</p></li><li><p>您至少需要3.9版本的 Linux 内核，并且推荐4.0或更高版本。</p></li><li><p>这些例子假设您的以太网接口是 eth0。如果您的设备有一个不同的名称，请使用相应的名称。</p></li></ul><h3 id="2-3-桥接模式"><a href="#2-3-桥接模式" class="headerlink" title="2.3 桥接模式"></a>2.3 桥接模式</h3><p>在简单的桥接示例中，流量通过 eth0和 Docker 使用容器的 MAC 地址将流量路由到容器。 对于网络上的网络设备，容器看起来是物理连接到网络的。</p><ol><li><p>创建一个称为 my-macvlan-net 的 macvlan 网络。 将子网、网关和父值修改为在环境中有意义的值。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create -d macvlan \--subnet<span class="token operator">=</span>172.16.86.0/24 \--gateway<span class="token operator">=</span>172.16.86.1 \-o parent<span class="token operator">=</span>eth0 \my-macvlan-net<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>您可以使用 docker 网络 ls 和 docker 网络检查 my-macvlan-net 命令，以验证网络存在并且是 macvlan 网络。</p></li><li><p>启动一个<code>alpine</code>容器并将其连接到 <code>my-macvlan-net</code> 网络。 <code>-dit</code> 标志在后台启动容器，但允许您附加到它。 <code>-rm</code> 标志意味着容器在停止时被移除。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run --rm -itd \--network my-macvlan-net \--name my-macvlan-alpine \alpine:latest \ash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>检查 <code>my-macvlan-alpine</code> 容器，注意网络键中的 <code>MacAddress</code> 键:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container inspect my-macvlan-alpine<span class="token punctuation">..</span>.truncated<span class="token punctuation">..</span>.<span class="token string">"Networks"</span><span class="token keyword">:</span> <span class="token punctuation">{</span><span class="token string">"my-macvlan-net"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>   <span class="token string">"IPAMConfig"</span><span class="token keyword">:</span> null,   <span class="token string">"Links"</span><span class="token keyword">:</span> null,   <span class="token string">"Aliases"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>       <span class="token string">"bec64291cd4c"</span>   <span class="token punctuation">]</span>,   <span class="token string">"NetworkID"</span><span class="token keyword">:</span> <span class="token string">"5e3ec79625d388dbcc03dcf4a6dc4548644eb99d58864cf8eee2252dcfc0cc9f"</span>,   <span class="token string">"EndpointID"</span><span class="token keyword">:</span> <span class="token string">"8caf93c862b22f379b60515975acf96f7b54b7cf0ba0fb4a33cf18ae9e5c1d89"</span>,   <span class="token string">"Gateway"</span><span class="token keyword">:</span> <span class="token string">"172.16.86.1"</span>,   <span class="token string">"IPAddress"</span><span class="token keyword">:</span> <span class="token string">"172.16.86.2"</span>,   <span class="token string">"IPPrefixLen"</span><span class="token keyword">:</span> 24,   <span class="token string">"IPv6Gateway"</span><span class="token keyword">:</span> <span class="token string">""</span>,   <span class="token string">"GlobalIPv6Address"</span><span class="token keyword">:</span> <span class="token string">""</span>,   <span class="token string">"GlobalIPv6PrefixLen"</span><span class="token keyword">:</span> 0,   <span class="token string">"MacAddress"</span><span class="token keyword">:</span> <span class="token string">"02:42:ac:10:56:02"</span>,   <span class="token string">"DriverOpts"</span><span class="token keyword">:</span> null<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">..</span>.truncated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通过运行两个 docker exec 命令，查看容器如何看待自己的网络接口。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker <span class="token function">exec</span> my-macvlan-alpine ip addr show eth09: eth0@tunl0: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN<span class="token operator">></span> mtu 1500 qdisc noqueue state UPlink/ether 02:42:ac:10:56:02 brd ff:ff:ff:ff:ff:ffinet 172.16.86.2/24 brd 172.16.86.255 scope global eth0valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">$ docker <span class="token function">exec</span> my-macvlan-alpine ip routedefault via 172.16.86.1 dev eth0172.16.86.0/24 dev eth0 scope <span class="token function">link</span>  src 172.16.86.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>停止容器(因为 <code>--rm</code> 标志，Docker 删除了它) ，并删除网络。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container stop my-macvlan-alpine$ docker network <span class="token function">rm</span> my-macvlan-net<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="2-4-集束桥接（vlan）"><a href="#2-4-集束桥接（vlan）" class="headerlink" title="2.4 集束桥接（vlan）"></a>2.4 集束桥接（vlan）</h3><p>在802.1 q 集束桥接的示例中，流量通过 eth0(称为 eth0.10)的子接口流动，而 Docker 使用容器的 MAC 地址将流量路由到容器。 对于网络上的网络设备，容器看起来是物理连接到网络的。</p><ol><li><p>创建一个名为 my-8021q-macvlan-net 的 macvlan 网络。 将子网、网关和父值修改为在环境中有意义的值。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create -d macvlan \--subnet<span class="token operator">=</span>172.16.86.0/24 \--gateway<span class="token operator">=</span>172.16.86.1 \-o parent<span class="token operator">=</span>eth0.10 \my-8021q-macvlan-net<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>您可以使用 <code>docker network ls</code> 和 <code>docker network inspection my-8021q-macvlan-net</code> 命令来验证网络是否存在，是否是 <code>macvlan</code> 网络，以及是否具有父 <code>eth0.10</code>。 您可以在 Docker 主机上使用 <code>ip addr show</code> 来验证接口 <code>eth0.10</code>是否存在并具有单独的 IP 地址</p></li><li><p>启动一个<code>alpine</code>容器并将其连接到 <code>my-8021q-macvlan-net</code> 网络。 <code>-dit</code> 标志在后台启动容器，但允许您附加到它。 <code>-rm</code> 标志意味着容器在停止时被移除。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run --rm -itd \--network my-8021q-macvlan-net \--name my-second-macvlan-alpine \alpine:latest \ash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>检查 <code>my-second-macvlan-alpine</code> 容器，注意网络键中的 <code>MacAddress</code> 键:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container inspect my-second-macvlan-alpine<span class="token punctuation">..</span>.truncated<span class="token punctuation">..</span>.<span class="token string">"Networks"</span><span class="token keyword">:</span> <span class="token punctuation">{</span><span class="token string">"my-8021q-macvlan-net"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>   <span class="token string">"IPAMConfig"</span><span class="token keyword">:</span> null,   <span class="token string">"Links"</span><span class="token keyword">:</span> null,   <span class="token string">"Aliases"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>       <span class="token string">"12f5c3c9ba5c"</span>   <span class="token punctuation">]</span>,   <span class="token string">"NetworkID"</span><span class="token keyword">:</span> <span class="token string">"c6203997842e654dd5086abb1133b7e6df627784fec063afcbee5893b2bb64db"</span>,   <span class="token string">"EndpointID"</span><span class="token keyword">:</span> <span class="token string">"aa08d9aa2353c68e8d2ae0bf0e11ed426ea31ed0dd71c868d22ed0dcf9fc8ae6"</span>,   <span class="token string">"Gateway"</span><span class="token keyword">:</span> <span class="token string">"172.16.86.1"</span>,   <span class="token string">"IPAddress"</span><span class="token keyword">:</span> <span class="token string">"172.16.86.2"</span>,   <span class="token string">"IPPrefixLen"</span><span class="token keyword">:</span> 24,   <span class="token string">"IPv6Gateway"</span><span class="token keyword">:</span> <span class="token string">""</span>,   <span class="token string">"GlobalIPv6Address"</span><span class="token keyword">:</span> <span class="token string">""</span>,   <span class="token string">"GlobalIPv6PrefixLen"</span><span class="token keyword">:</span> 0,   <span class="token string">"MacAddress"</span><span class="token keyword">:</span> <span class="token string">"02:42:ac:10:56:02"</span>,   <span class="token string">"DriverOpts"</span><span class="token keyword">:</span> null<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">..</span>.truncated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通过运行两个 docker exec 命令，查看容器如何看待自己的网络接口。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker <span class="token function">exec</span> my-second-macvlan-alpine ip addr show eth011: eth0@if10: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN<span class="token operator">></span> mtu 1500 qdisc noqueue state UPlink/ether 02:42:ac:10:56:02 brd ff:ff:ff:ff:ff:ffinet 172.16.86.2/24 brd 172.16.86.255 scope global eth0valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">$ docker <span class="token function">exec</span> my-second-macvlan-alpine ip routedefault via 172.16.86.1 dev eth0172.16.86.0/24 dev eth0 scope <span class="token function">link</span>  src 172.16.86.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>停止容器(因为 – rm 标志，Docker 删除了它) ，并删除网络。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container stop my-second-macvlan-alpine$ docker network <span class="token function">rm</span> my-8021q-macvlan-net<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 容器服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门系列  7. Docker 容器网络的概念及网络配置 主机网络</title>
      <link href="/posts/42665.html"/>
      <url>/posts/42665.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-使用主机网络"><a href="#1-使用主机网络" class="headerlink" title="1. 使用主机网络"></a>1. 使用主机网络</h2><p>如果您使用容器的主机网络模式，那么容器的网络堆栈不会与 Docker 主机隔离(容器共享主机的网络名称空间) ，并且容器不会得到自己的 ip 地址分配。 例如，如果您运行一个绑定到端口80的容器，并且使用主机网络，那么容器的应用程序在端口80的主机 IP 地址上是可用的。</p><blockquote><p><strong>注意: 当使用主机模式网络时，容器没有自己的 ip 地址，因此端口映射不生效，并且忽略 <code>-p</code>、 <code>--publish</code>、<code>-P</code> 和 <code>--publish-all</code> 选项，从而产生一个警告:</strong></p><pre><code>WARNING: Published ports are discarded when using host network mode</code></pre></blockquote><p>主机模式网络对于优化性能非常有用，并且在容器需要处理大范围的端口的情况下，因为它不需要网络地址转换(NAT) ，也不会为每个端口创建“ userland-proxy”。</p><p>主机网络驱动程序只能在 Linux 主机上工作，而且不支持 Mac 版的 Docker Desktop，Windows 版的 Docker Desktop，或 Windows 服务器版的 Docker EE。</p><p>您还可以为群服务使用一个主机网络，方法是将 <code>--network host</code> 传递给 <code>docker service create</code> 命令。 在这种情况下，控制流量(与管理群和服务相关的流量)仍然通过覆盖网络发送，但是各个群服务容器使用 Docker 守护进程的主机网络和端口发送数据。 这就产生了一些额外的限制。 例如，如果一个服务容器绑定到端口80，那么在给定的群节点上只能运行一个服务容器。</p><h2 id="2-实践练习-主机网络"><a href="#2-实践练习-主机网络" class="headerlink" title="2. 实践练习 主机网络"></a>2. 实践练习 主机网络</h2><h3 id="2-1-目标"><a href="#2-1-目标" class="headerlink" title="2.1 目标"></a>2.1 目标</h3><p>本练习涉及处理网络独立容器，直接绑定到 Docker 主机的网络，没有网络隔离。</p><p>实践目标是启动一个直接绑定到 Docker 主机上的端口80的 nginx 容器。 从网络的角度来看，这与 nginx 进程直接在 Docker 主机而不是容器中运行的隔离级别是相同的。 但是，在所有其他方面，例如存储、流程名称空间和用户名称空间，nginx 流程都与主机隔离。</p><h3 id="2-2-前提条件"><a href="#2-2-前提条件" class="headerlink" title="2.2 前提条件"></a>2.2 前提条件</h3><ul><li><p>此过程要求在 Docker 主机上可以使用端口80。 要让 Nginx 在另一个端口上侦听，请参阅 Nginx 映像的文档</p></li><li><p>主机网络驱动程序只能在 Linux 主机上工作，而且不支持 Mac 版的 Docker Desktop，Windows 版的 Docker Desktop，或 Windows 服务器版的 Docker EE。</p></li></ul><h3 id="2-3-实践"><a href="#2-3-实践" class="headerlink" title="2.3 实践"></a>2.3 实践</h3><ol><li><p>创建并启动容器作为一个分离的进程。 <code>--rm</code> 选项意味着在容器退出 / 停止时删除它。 <code>-d</code> 标志意味着启动分离的容器(在后台)。</p><pre class="line-numbers language-bash"><code class="language-bash"> docker run --rm -d --network host --name my_nginx nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>访问 Nginx 服务  通过网页浏览器 浏览 <a href="http://localhost:80/" target="_blank" rel="noopener">http://localhost:80/</a> 。</p></li><li><p>使用以下命令检查网络堆栈:</p><ul><li><p>使用以下命令检查网络堆栈:</p><pre class="line-numbers language-bash"><code class="language-bash">ip addr show<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>使用 netstat 命令验证哪个进程绑定到端口80。 您需要使用 sudo，因为进程属于 Docker 守护进程用户，否则您将无法看到它的名称或 PID。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">netstat</span> -tulpn <span class="token operator">|</span> <span class="token function">grep</span> :80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>停止容器。当它使用 <code>--rm</code> 选项启动时，它将被自动删除。</p><pre class="line-numbers language-bash"><code class="language-bash"> docker container stop my_nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 容器服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门系列  5. Docker 容器网络的概念及网络配置 覆盖网络</title>
      <link href="/posts/11593.html"/>
      <url>/posts/11593.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-使用覆盖网络"><a href="#1-使用覆盖网络" class="headerlink" title="1. 使用覆盖网络"></a>1. 使用覆盖网络</h2><p>覆盖网络驱动程序在多个 Docker 守护进程主机之间创建一个分布式网络。 这个网络位于(覆盖)主机特定网络的顶部，允许连接到它的容器(包括群服务容器)在启用加密时进行安全通信。 Docker 透明地处理每个数据包与正确的 Docker 守护进程主机和正确的目标容器之间的路由。。</p><p>当你初始化一个群或者将一个 Docker 主机加入到一个已经存在的群中时，会在 Docker 主机上创建两个新的网络:</p><ul><li><p>一个称为<code>ingress</code>的覆盖网络，用于处理与群体服务有关的控制和数据流。当您创建一个群服务并且不将其连接到用户定义的覆盖网络时，默认情况下它将连接到网络<code>ingress</code> 。</p></li><li><p>一个名为<code>docker_gwbridge</code>的桥接网络，它将各个独立的Docker守护程序连接到该集群中的其他守护程序。</p></li></ul><p>您可以使用 <code>docker network create</code> 创建用户定义的覆盖网络，就像您可以创建用户定义的桥接网络一样。 服务或容器可以同时连接到多个网络。 服务或容器只能通过它们各自连接的网络进行通信。</p><p>虽然可以将群服务和独立容器连接到覆盖网络，但默认行为和配置问题是不同的。 基于这个原因，这个主题的其余部分被分为适用于所有覆盖网络的操作，适用于群服务网络的操作，以及适用于独立容器使用的覆盖网络的操作。</p><h2 id="2-所有覆盖网络的操作"><a href="#2-所有覆盖网络的操作" class="headerlink" title="2. 所有覆盖网络的操作"></a>2. 所有覆盖网络的操作</h2><h3 id="2-1-创建覆盖网络"><a href="#2-1-创建覆盖网络" class="headerlink" title="2.1 创建覆盖网络"></a>2.1 创建覆盖网络</h3><blockquote><p><strong>先决条件：</strong></p><ul><li><p>使用覆盖网络的Docker守护程序的防火墙规则</p><p>你需要下面的端口对来往于参与覆盖网络的每个 Docker 主机的通信开放:</p><ul><li>用于集群管理通信的 TCP 端口2377</li><li>用于节点间通信的 TCP 和 UDP 端口7946</li><li>用于覆盖网络流量的 UDP 端口4789</li></ul></li><li><p>在创建覆盖网络之前，您需要使用 Docker swarm init 将 Docker 守护进程初始化为一个群管理器，或者使用 Docker swarm join 将其加入到现有的群中。 这两者中的任何一个都会创建默认的入口覆盖网络，该网络默认由群服务使用。 你需要这样做，即使你从来没有计划使用群服务。 然后，您可以创建其他用户定义的覆盖网络。</p></li></ul></blockquote><p>要创建一个覆盖网络来使用群服务，可以使用如下命令:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create -d overlay my-overlay<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要创建一个覆盖网络，它可以被群服务或独立容器用来与运行在其他 Docker 守护进程上的其他独立容器进行通信，添加<code>--attachable</code>标志：</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create -d overlay --attachable my-attachable-overlay<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您可以指定IP地址范围，子网，网关和其他选项。</p><h3 id="2-1-加密覆盖网络上的流量"><a href="#2-1-加密覆盖网络上的流量" class="headerlink" title="2.1 加密覆盖网络上的流量"></a>2.1 加密覆盖网络上的流量</h3><p>在 GCM 模式下，所有群服务管理流量默认情况下使用 AES 算法进行加密。 群中的管理器节点每12小时轮换用于加密传播协议数据的密钥。</p><p>要加密应用程序数据，在创建覆盖网络时添加<code>--opt encrypted</code>。这样就可以在 vxlan 级别实现 IPSEC 加密。 这种加密会带来不可忽视的性能损失，因此在生产中使用此选项之前应该对其进行测试。</p><p>当您启用覆盖加密时，Docker 会在所有节点之间创建 IPSEC 隧道，在这些节点中，任务被安排用于连接到覆盖网络的服务。 这些隧道也使用 AES 算法在 GCM 模式，并且管理器节点每12小时自动轮换一次密钥。</p><blockquote><p>  不要将Windows节点附加到加密的覆盖网络。<br>Windows不支持覆盖网络加密。如果Windows节点尝试连接到加密的覆盖网络，则不会检测到错误，但是该节点无法通信。</p></blockquote><h4 id="群集模式覆盖网络和独立容器"><a href="#群集模式覆盖网络和独立容器" class="headerlink" title="群集模式覆盖网络和独立容器"></a>群集模式覆盖网络和独立容器</h4><p>您可以同时使用覆盖网络功能，<code>--opt encrypted --attachable</code> 并将非托管容器附加到该网络：</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create --opt encrypted --driver overlay --attachable my-attachable-multi-host-network<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2-自定义默认入口网络"><a href="#2-2-自定义默认入口网络" class="headerlink" title="2.2 自定义默认入口网络"></a>2.2 自定义默认入口网络</h3><p>大多数用户从不需要配置<code>ingress</code>网络，但是Docker 17.05及更高版本允许您进行配置。如果自动选择的子网与网络上已经存在的子网发生冲突，或者您需要自定义其他低级别的网络设置（例如MTU），这将很有用。</p><p>自定义<code>ingress</code>网络涉及删除并重新创建它。这通常在集群中创建任何服务之前完成。如果您拥有发布端口的现有服务，那么在删除<code>ingress</code>网络之前需要删除这些服务。</p><p>在没有<code>ingress</code>网络的时候，不发布端口的现有服务继续运行，但是负载不平衡。 这会影响发布端口的服务，比如发布端口80的 WordPress 服务。</p><ol><li><p>使用<code>docker network inspect ingress</code>检查<code>ingress</code>网络，并移除与其连接的容器的任何服务。这些是发布端口的服务，例如发布端口80的WordPress服务。如果不停止所有这些服务，下一步就会失败。</p></li><li><p>移除现有<code>ingress</code>网络：</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network <span class="token function">rm</span> ingressWARNING<span class="token operator">!</span> Before removing the routing-mesh network, <span class="token function">make</span> sure all the nodes<span class="token keyword">in</span> your swarm run the same docker engine version. Otherwise, removal may notbe effective and functionality of newly created ingress networks will beimpaired.Are you sure you want to continue? <span class="token punctuation">[</span>y/N<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用<code>--ingress</code>标志创建一个新的覆盖网络，以及您想要设置的自定义选项。 此示例将 MTU 设置为1200，将子网设置为<code>10.11.0.0/16</code>，并将网关设置为<code>10.11.0.2</code>。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create \--driver overlay \--ingress \--subnet<span class="token operator">=</span>10.11.0.0/16 \--gateway<span class="token operator">=</span>10.11.0.2 \--opt com.docker.network.driver.mtu<span class="token operator">=</span>1200 \my-ingress<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>  <strong>注意</strong>：您可以将<code>ingress</code>网络命名为别的名称，但只能有一个。 试图创建第二个的尝试失败。</p></blockquote></li><li><p>重新启动在第一步中停止的服务。</p></li></ol><h3 id="2-3-自定义docker-gwbridge接口"><a href="#2-3-自定义docker-gwbridge接口" class="headerlink" title="2.3 自定义docker_gwbridge接口"></a>2.3 自定义docker_gwbridge接口</h3><p><code>docker_gwbridge</code>是一个虚拟网桥，它将覆盖网络(包括入口网络)连接到单个 Docker 守护进程的物理网络。 当初始化一个群或者将一个 Docker 主机加入到一个群中时，Docker 会自动创建它，但它不是 Docker 设备。 它存在于 Docker 主机的内核中。 如果您需要自定义它的设置，那么您必须在加入 Docker 主机到群体之前或者从群体中临时移除主机之后这样做。</p><ol><li><p>停止 Docker。</p></li><li><p>删除现有的 <code>docker gwbridge</code> 接口。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> ip <span class="token function">link</span> <span class="token keyword">set</span> docker_gwbridge down$ <span class="token function">sudo</span> ip <span class="token function">link</span> del dev docker_gwbridge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>启动 Docker。不要连接或初始化集群服务。</p></li><li><p>使用自定义设置，使用 <code>docker network Create</code> 命令手动创建或重新创建 <code>docker gwbridge</code>。 此示例使用子网<code>10.11.0.0 / 16</code>。 有关可自定义选项的完整列表，请参见桥接驱动程序选项。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create \\--subnet 10.11.0.0/16 \\--opt com.docker.network.bridge.name<span class="token operator">=</span>docker_gwbridge \\--opt com.docker.network.bridge.enable_icc<span class="token operator">=</span>false \\--opt com.docker.network.bridge.enable_ip_masquerade<span class="token operator">=</span>true \docker_gwbridge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>初始化或加入群。由于桥已经存在，Docker 不会自动创建它。</p></li></ol><h2 id="3-群服务的操作"><a href="#3-群服务的操作" class="headerlink" title="3. 群服务的操作"></a>3. 群服务的操作</h2><h3 id="3-1-在覆盖网络上发布端口"><a href="#3-1-在覆盖网络上发布端口" class="headerlink" title="3.1 在覆盖网络上发布端口"></a>3.1 在覆盖网络上发布端口</h3><p>连接到同一覆盖网络的群服务有效地将所有端口相互暴露。 对于可以在服务之外访问的端口，必须使用 <code>-p</code> 或 <code>-- publish</code> 标志在 <code>docker service create</code> 或 <code>docker service update</code>时发布该端口。 支持旧的冒号分隔语法和新的逗号分隔值语法。 较长的语法是首选的，因为它在一定程度上是自文档化的。</p><table><thead><tr><th align="center">标志值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">-p 8080:80 - p 8080:80 或 -p published=8080,target=80</td><td align="left">将服务上的 TCP 端口80映射到路由网格上的端口8080</td></tr><tr><td align="center">-p 8080:80/udp 或 -p published=8080,target=80,protocol=udp</td><td align="left">将服务上的 UDP 端口80映射到路由网上的端口8080</td></tr><tr><td align="center">-p 8080:80/tcp -p 8080:80/udp 或 -p published=8080,target=80,protocol=tcp -p published=8080,target=80,protocol=udp</td><td align="left">将服务上的 TCP 端口80映射到路由网格上的 TCP 端口8080，将服务上的 UDP 端口80映射到路由网格上的 UDP 端口8080</td></tr></tbody></table><h3 id="3-2-绕过集群服务的路由网格"><a href="#3-2-绕过集群服务的路由网格" class="headerlink" title="3.2 绕过集群服务的路由网格"></a>3.2 绕过集群服务的路由网格</h3><p>默认情况下，发布端口的群服务使用路由网格来发布端口。 当您连接到任何群节点上的发布端口时(无论它是否运行给定的服务) ，您都会被重定向到正在透明地运行该服务的工作节点。 实际上，Docker 充当了你的群服务的负载平衡器。 使用路由网格的服务以虚拟 IP (VIP)模式运行。 即使是在每个节点上运行的服务(通过 <code>-- mode glocal</code>标志)也使用路由网格。 当使用路由网格时，不能保证哪个 Docker 节点为客户机请求提供服务。</p><p>要绕过路由网格，可以通过将 <code>-- endpoint-mode</code> 标志设置为 <code>dnsrr</code>，使用 DNS Round Robin (DNSRR)模式启动服务。 您必须在集群服务前面运行自己的负载均衡器。 针对 Docker 主机上的服务名称的 DNS 查询将返回运行该服务的节点的 IP 地址列表。 配置您的负载平衡器来使用这个列表并平衡节点之间的流量。</p><h3 id="3-3-分离控制和数据通信"><a href="#3-3-分离控制和数据通信" class="headerlink" title="3.3 分离控制和数据通信"></a>3.3 分离控制和数据通信</h3><p>默认情况下，与集群管理和应用程序之间的通信相关的控制通信在同一网络上运行，不过群控通信是加密的。 您可以将 Docker 配置为使用单独的网络接口来处理两种不同类型的流量。 初始化或加入群时，分别指定 ·– advertised-addr· 和 ·– datapath-addr·。 您必须为加入群的每个节点执行此操作。</p><h2 id="4-覆盖网络上独立容器的操作"><a href="#4-覆盖网络上独立容器的操作" class="headerlink" title="4. 覆盖网络上独立容器的操作"></a>4. 覆盖网络上独立容器的操作</h2><h3 id="4-1-将独立的容器连接到覆盖网络"><a href="#4-1-将独立的容器连接到覆盖网络" class="headerlink" title="4.1 将独立的容器连接到覆盖网络"></a>4.1 将独立的容器连接到覆盖网络</h3><p><code>ingress</code>网络是在没有<code>-- attachable</code>标志的情况下创建的，这意味着只有群服务可以使用它，而不是单独的容器。 您可以将独立容器连接到用户定义的覆盖网络，这些覆盖网络是用 <code>-- attachable</code>标志创建的。 这使得运行在不同 Docker 守护进程上的独立容器能够进行通信，而无需在单个 Docker 守护进程主机上设置路由。</p><h3 id="4-2-发布端口"><a href="#4-2-发布端口" class="headerlink" title="4.2 发布端口"></a>4.2 发布端口</h3><table><thead><tr><th align="center">标志值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">-p 8080:80</td><td align="left">将容器中的 TCP 端口80映射到覆盖网络上的8080端口</td></tr><tr><td align="center">-p 8080:80/udp</td><td align="left">在覆盖网络上将容器中的 UDP 端口80映射到8080端口</td></tr><tr><td align="center">-p 8080:80/sctp</td><td align="left">将容器中的 SCTP 端口80映射到覆盖网络上的8080端口</td></tr><tr><td align="center">p 8080:80/tcp -p 8080:80/udp</td><td align="left">将容器内的 TCP 端口80映射到覆盖网络上的 TCP 端口8080，将容器内的 UDP 端口80映射到覆盖网络上的 UDP 端口8080</td></tr></tbody></table><h3 id="4-3-容器发现"><a href="#4-3-容器发现" class="headerlink" title="4.3 容器发现"></a>4.3 容器发现</h3><p>对于大多数情况，应该连接到服务名称，该名称是负载平衡的，由支持服务的所有容器(“任务”)处理。 若要获取支持服务的所有任务的列表，请对任务执行 DNS 查找 <code>tasks.&lt;service-name&gt;</code>。</p><h2 id="5-实践练习-覆盖网络"><a href="#5-实践练习-覆盖网络" class="headerlink" title="5. 实践练习 覆盖网络"></a>5. 实践练习 覆盖网络</h2><ul><li><p><code>使用默认覆盖网络</code> 演示了如何在初始化或加入群集时使用Docker自动为您设置的默认覆盖网络。该网络不是生产系统的最佳选择。</p></li><li><p><code>使用用户定义的覆盖网络</code> 演示了如何创建和使用自己的自定义覆盖网络来连接服务。建议将其用于生产中运行的服务。</p></li><li><p><code>将覆盖网络用于独立容器</code> 演示了如何使用覆盖网络在不同Docker守护程序上的独立容器之间进行通信。</p></li><li><p><code>容器与群集服务之间的通信</code> 演示了使用可附加的覆盖网络，在独立容器和群服务之间建立通信。 这在 Docker 17.06及更高版本中得到了支持。</p></li></ul><h3 id="5-1-前提条件"><a href="#5-1-前提条件" class="headerlink" title="5.1 前提条件"></a>5.1 前提条件</h3><p>这些要求您至少有一个单节点群集，这意味着您已启动Docker并docker swarm init在主机上运行。您也可以在多节点群集上运行示例。</p><p>最后一个示例需要Docker 17.06或更高版本。</p><h3 id="5-2-使用默认的覆盖网络"><a href="#5-2-使用默认的覆盖网络" class="headerlink" title="5.2 使用默认的覆盖网络"></a>5.2 使用默认的覆盖网络</h3><p>在这个示例中，您将启动一个 alpine 服务，并从单个服务容器的角度检查网络的特性。</p><h4 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h4><p>本教程需要三个物理或虚拟的 Docker 主机，它们都可以相互通信，都运行 Docker 17.03或更高版本的新安装。 本教程假设三台主机在同一网络上运行，不涉及防火墙。</p><p>这些主机将被称为 manager、 worker-1和 worker-2。 管理器主机既是管理节点又是工作节点，这意味着它既可以运行服务任务，也可以管理集群。 工作节点1号和工作节点2号只起工作节点的作用,</p><p>如果你手头没有三台主机，一个简单的解决方案是在云提供商(比如 Amazon EC2)上安装三台 Ubuntu 主机，它们都在同一个网络上，允许所有主机通信(使用 EC2安全组之类的机制) ，然后按照 Ubuntu 上 Docker Engine-Community 的安装说明进行安装。</p><h4 id="演练"><a href="#演练" class="headerlink" title="演练"></a>演练</h4><h5 id="创造集群"><a href="#创造集群" class="headerlink" title="创造集群"></a>创造集群</h5><p>在这个过程的最后，所有三个 Docker 主机将被加入到群体中，并且将使用一个称为入口的覆盖网络连接在一起。</p><ol><li><p>在 manager. 上初始化群。如果主机只有一个网络接口，则 – advertised-addr 标志是可选的。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker swarm init --advertise-addr<span class="token operator">=</span><span class="token operator">&lt;</span>IP-ADDRESS-OF-MANAGER<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>记下输出的文本，因为它包含将用于将 worker-1和 worker-2加入到群体中的令牌。 将令牌存储在密码管理器中是一个好主意。</p></li><li><p>在 worker-1上，加入群体。如果主机只有一个网络接口，则 – advertised-addr 标志是可选的。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker swarm <span class="token function">join</span> --token <span class="token operator">&lt;</span>TOKEN<span class="token operator">></span> \--advertise-addr <span class="token operator">&lt;</span>IP-ADDRESS-OF-WORKER-1<span class="token operator">></span> \<span class="token operator">&lt;</span>IP-ADDRESS-OF-MANAGER<span class="token operator">></span>:2377<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>在 worker-2上，加入群体。如果主机只有一个网络接口，则 – advertised-addr 标志是可选的。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker swarm <span class="token function">join</span> --token <span class="token operator">&lt;</span>TOKEN<span class="token operator">></span> \--advertise-addr <span class="token operator">&lt;</span>IP-ADDRESS-OF-WORKER-2<span class="token operator">></span> \<span class="token operator">&lt;</span>IP-ADDRESS-OF-MANAGER<span class="token operator">></span>:2377<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>在管理节点上，列出所有的节点。这个命令只能从管理器执行。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker node <span class="token function">ls</span>ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUSd68ace5iraw6whp7llvgjpu48 *   ip-172-31-34-146    Ready               Active              Leadernvp5rwavvb8lhdggo8fcf7plg     ip-172-31-35-151    Ready               Activeouvx2l7qfcxisoyms8mtkgahw     ip-172-31-36-89     Ready               Active<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你还可以使用-filter 标志按角色进行筛选:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker node <span class="token function">ls</span> --filter role<span class="token operator">=</span>managerID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUSd68ace5iraw6whp7llvgjpu48 *   ip-172-31-34-146    Ready               Active              Leader$ docker node <span class="token function">ls</span> --filter role<span class="token operator">=</span>workerID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUSnvp5rwavvb8lhdggo8fcf7plg     ip-172-31-35-151    Ready               Activeouvx2l7qfcxisoyms8mtkgahw     ip-172-31-36-89     Ready               Active<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在 manager、 worker-1和 worker-2上列出 Docker 网络，注意它们现在都有一个覆盖网络，称为<code>ingress</code>网络和一个桥接网络，称为 Docker gwbridge。 这里只显示了 manager 的列表:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network <span class="token function">ls</span>NETWORK ID          NAME                DRIVER              SCOPE495c570066be        bridge              bridge              local961c6cae9945        docker_gwbridge     bridge              localff35ceda3643        host                host                localtrtnl4tqnc3n        ingress             overlay             swarmc8357deec9cb        none                null                local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p><code>Docker gwbridge</code> 将<code>ingress</code>网络与 Docker 主机的网络接口连接起来，这样就可以在群管理节点和工作节点之间进行通信。 如果您创建了群服务，但没有指定网络，那么它们将连接到<code>ingress</code>网络。 建议您为每个应用程序或将一起工作的应用程序组使用单独的覆盖网络。 在下一个过程中，您将创建两个覆盖网络，并将服务连接到每个覆盖网络。</p><h5 id="创造服务"><a href="#创造服务" class="headerlink" title="创造服务"></a>创造服务</h5><ol><li><p>在 manager 上，创建一个新的覆盖网络 nginx-net:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create -d overlay nginx-net<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您不需要在其他节点上创建覆盖网络，因为当其中一个节点开始运行需要它的服务任务时，它将自动创建。</p></li><li><p>在 <code>manager</code> 上，创建一个连接到 <code>nginx-net</code> 的5个副本的 Nginx 服务。 该服务将向外界发布端口80。 所有的服务任务容器都可以在不打开任何端口的情况下相互通信。</p><blockquote><p><strong>注意: 服务只能在管理器上创建。</strong></p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ docker <span class="token function">service</span> create \--name my-nginx \--publish target<span class="token operator">=</span>80,published<span class="token operator">=</span>80 \--replicas<span class="token operator">=</span>5 \--network nginx-net \nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认的<code>ingress</code>发布模式，当您没有为 <code>-- publish</code> 标志指定<code>mode</code>模式时使用，这意味着如果您在 manager、 worker-1或 worker-2上浏览到端口80，您将连接到5个服务任务节点之一的端口80，即使当前在您浏览的节点上没有任何任务正在运行。 如果希望使用<code>host</code>主机模式发布端口，可以将<code>mode=host</code>添加到 <code>-- publish</code> 输出。 但是，在这种情况下，您还应该使用 <code>-- mode global</code> 而不是 <code>-- replicas 5</code>，因为只有一个服务任务可以绑定指定节点上的指定端口。</p></li><li><p>运行 <code>docker service ls</code> 来监视服务启动的进度，这可能需要几秒钟。</p></li><li><p>检查<code>manager</code>、<code>worker-1</code>和<code>worker-2</code>的 <code>nginx-net</code> 网络。 请记住，您不需要在 <code>worker-1</code>和 <code>worker-2</code>上手动创建它，因为 Docker 为您创建了它。 输出将很长，但请注意 <code>Containers</code> 和 <code>Peers</code> 部分。 <code>Containers</code>列出从该主机连接到覆盖网络的所有服务任务(或独立容器)。</p></li><li><p>从 manager节点，使用 <code>docker service inspect my-nginx</code> 并注意关于服务使用的端口和端点的信息。</p></li><li><p>创建一个新的网络 nginx-net-2，然后更新该服务以使用该网络而不是 nginx-net:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create -d overlay nginx-net-2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">$ docker <span class="token function">service</span> update \--network-add nginx-net-2 \--network-rm nginx-net \my-nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>运行 <code>docker service ls</code>，以验证服务是否已更新，所有任务是否已重新部署。 运行 <code>docker network inspect nginx-net</code> 以验证没有任何容器连接到它。 对 <code>nginx-net-2</code>运行相同的命令，并注意所有服务任务容器都连接到它。</p><blockquote><p><strong>注意: 即使覆盖网络是根据需要在群工作节点上自动创建的，它们也不会被自动删除。</strong></p></blockquote></li><li><p>清理服务和网络。 从 manager，运行以下命令。 管理节点会指示工作节点自动移除网络。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker <span class="token function">service</span> <span class="token function">rm</span> my-nginx$ docker network <span class="token function">rm</span> nginx-net nginx-net-2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="5-3-使用用户定义的覆盖网络"><a href="#5-3-使用用户定义的覆盖网络" class="headerlink" title="5.3 使用用户定义的覆盖网络"></a>5.3 使用用户定义的覆盖网络</h3><h4 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h4><p>  假设群已经设置好，并且你在管理节点。</p><h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><pre><code>1. 创建用户定义的覆盖网络。```bash$ docker network create -d overlay my-overlay```2. 使用覆盖网络启动服务，并将端口80发布到 Docker 主机上的端口8080。```bash$ docker service create \--name my-nginx \--network my-overlay \--replicas 1 \--publish published=8080,target=80 \nginx:latest```3. 运行 `docker network inspect my-overlay` 并通过查看 `Containers` 部分来验证 `my-nginx` 服务任务是否连接到它。4. 删除服务和网络。```bash$ docker service rm my-nginx$ docker network rm my-overlay```</code></pre><h3 id="5-4-对独立容器使用覆盖网络"><a href="#5-4-对独立容器使用覆盖网络" class="headerlink" title="5.4 对独立容器使用覆盖网络"></a>5.4 对独立容器使用覆盖网络</h3><p>这个示例演示了 DNS 容器发现——具体地说，如何使用覆盖网络在不同的 Docker 守护进程上的独立容器之间进行通信。 步骤如下:</p><ul><li>在节点host1上，将节点初始化为群集（管理器）。</li><li>在节点host2上，将节点加入群集（工作节点）。</li><li>在节点host1上，创建一个可连接的覆盖网络（test-net）。</li><li>在节点host1上，运行一个交互式<code>alpine</code>容器（alpine1）在 test-net上。</li><li>在节点host2上，运行一个独立的交互式<code>alpine</code>容器（alpine2）test-net。</li><li>在节点host1上, <code>alpine1</code> 的会话中 ping <code>alpine2</code>。</li></ul><h4 id="先决条件-1"><a href="#先决条件-1" class="headerlink" title="先决条件"></a>先决条件</h4><p>对于这个测试，您需要两个可以相互通信的 Docker 主机。 每个主机必须具有 Docker 17.06或更高版本，并在两个 Docker 主机之间打开以下端口:</p><ul><li>TCP端口2377</li><li>TCP和UDP端口7946</li><li>UDP端口4789</li></ul><p>一种简单的设置方法是使用两个 vm (本地或像 AWS 这样的云提供商) ，每个 vm 都安装并运行了 Docker。 如果您正在使用 AWS 或类似的云计算平台，最简单的配置是使用一个安全组来打开两台主机之间的所有传入端口，并从客户机的 IP 地址打开 SSH 端口。</p><p>这个例子将我们的群中的两个节点称为 host1和 host2。 这个示例也使用 Linux 主机，但是相同的命令可以在 Windows 上使用。</p><h4 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h4><ol><li><p>设置集群</p><p>a. 在 <code>host1</code>上，初始化一个群(如果提示，使用 <code>-- advertised-addr</code> 为与群中其他主机通信的接口指定 IP 地址，例如 AWS 上的私有 IP 地址) :</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker swarm initSwarm initialized: current node <span class="token punctuation">(</span>vz1mm9am11qcmo979tlrlox42<span class="token punctuation">)</span> is now a manager.To add a worker to this swarm, run the following command:   docker swarm <span class="token function">join</span> --token SWMTKN-1-5g90q48weqrtqryq4kj6ow0e8xm9wmv9o6vgqc5j320ymybd5c-8ex8j0bc40s6hgvy5ui5gl4gy 172.31.47.252:2377To add a manager to this swarm, run <span class="token string">'docker swarm join-token manager'</span> and follow the instructions.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>b. 在 <code>host2</code>上，按照上面的指示加入蜂群:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker swarm <span class="token function">join</span> --token <span class="token operator">&lt;</span>your_token<span class="token operator">></span> <span class="token operator">&lt;</span>your_ip_address<span class="token operator">></span>:2377This node joined a swarm as a worker.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果节点未能加入群体，docker 群体将超时加入命令。 要解决这个问题，运行 docker swarm leave ——强制 host2，验证网络和防火墙设置，然后再试一次。</p></li><li><p>在 <code>host1</code>上，创建一个名为 <code>test-net</code> 的可连接覆盖网络:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create --driver<span class="token operator">=</span>overlay --attachable test-netuqsof8phj3ak0rq9k86zta6ht<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>请注意返回的 NETWORK ID ——当您从 <code>host2</code>连接到它时，将再次看到它。</p></blockquote></li><li><p>在 <code>host1</code> 上，启动一个连接到 <code>test-net</code> 的交互式(- it)容器(alpine1) :</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run -it --name alpine1 --network test-net alpine/ <span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>在 <code>host2</code> 上，列出可用的网络——注意 <code>test-net</code> 还不存在:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network <span class="token function">ls</span>NETWORK ID          NAME                DRIVER              SCOPEec299350b504        bridge              bridge              local66e77d0d0e9a        docker_gwbridge     bridge              local9f6ae26ccb82        host                host                localomvdxqrda80z        ingress             overlay             swarmb65c952a4b2b        none                null                local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在 <code>host2</code> 上，启动一个连接到 <code>test-net</code> 的独立(- d)和交互(- it)容器(alpine2) :</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run -dit --name alpine2 --network test-net alpinefb635f5ece59563e7b8b99556f816d24e6949a5f6a5b1fbd92ca244db17a4342<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>自动 DNS 容器发现只适用于唯一的容器名。</p></blockquote></li><li><p>在 <code>host2</code> 上，验证创建了 <code>test-net</code> (并且在 <code>host1</code> 上具有与 <code>test-net</code> 相同的 NETWORK ID) :</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network <span class="token function">ls</span>NETWORK ID          NAME                DRIVER              SCOPE<span class="token punctuation">..</span>.uqsof8phj3ak        test-net            overlay             swarm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在 <code>host1</code> 上，ping <code>alpine2</code> 在 <code>alpine1</code>的交互终端上:</p><pre class="line-numbers language-bash"><code class="language-bash">/ <span class="token comment" spellcheck="true"># ping -c 2 alpine2</span>PING alpine2 <span class="token punctuation">(</span>10.0.0.5<span class="token punctuation">)</span>: 56 data bytes64 bytes from 10.0.0.5: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.600 ms64 bytes from 10.0.0.5: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.555 ms\--- alpine2 <span class="token function">ping</span> statistics ---2 packets transmitted, 2 packets received, 0% packet lossround-trip min/avg/max <span class="token operator">=</span> 0.555/0.577/0.600 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个容器与连接两台主机的覆盖网络通信。 如果你在 host2上运行另一个不是分离的 alpine 容器，你可以从 host2中 ping alpine1(在这里我们添加了自动容器清理的 remove 选项) :</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run -it --rm --name alpine3 --network test-net alpine/ <span class="token comment" spellcheck="true"># ping -c 2 alpine1</span>/ <span class="token comment" spellcheck="true"># exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>在 host1上，关闭 alpine1会话(它也会停止容器) :</p><pre class="line-numbers language-bash"><code class="language-bash">/ <span class="token comment" spellcheck="true"># exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>清理你的容器和网络:</p><p>您必须独立地停止和删除每个主机上的容器，因为 Docker 守护进程是独立运行的，而且它们是独立的容器。 您只需要删除 host1上的网络，因为当您在 host2上停止 alpine2时，test-net 就会消失。</p><p>在 host2上，停止使用 alpine2，检查测试网是否被移除，然后移除 alpine2:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container stop alpine2$ docker network <span class="token function">ls</span>$ docker container <span class="token function">rm</span> alpine2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在 host1上，删除 alpine1和 test-net:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container <span class="token function">rm</span> alpine1$ docker network <span class="token function">rm</span> test-net<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="5-5-容器和群服务之间的通信"><a href="#5-5-容器和群服务之间的通信" class="headerlink" title="5.5 容器和群服务之间的通信"></a>5.5 容器和群服务之间的通信</h3><h4 id="先决条件-2"><a href="#先决条件-2" class="headerlink" title="先决条件"></a>先决条件</h4><p>本例中需要 Docker 17.06或更高版本。</p><h4 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h4><p>在本例中，您在同一个 Docker 主机上启动两个不同的 alpine 容器，并进行一些测试以了解它们如何彼此通信。 您需要安装并运行 Docker。</p><ol><li><p>打开终端窗口。 在你做任何事情之前列出当前的网络。 如果您从未在这个 Docker 守护进程上添加过网络或初始化过一个群，下面是您应该看到的内容。 你可能会看到不同的网络，但是你至少应该看到这些(网络 id 不同) :</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network <span class="token function">ls</span>NETWORK ID          NAME                DRIVER              SCOPE17e324f45964        bridge              bridge              local6ed54d316334        host                host                local7092879f2cc8        none                null                local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>列出了缺省桥接网络、主机和 none。 后两者不是完全成熟的网络，但用于启动直接连接到 Docker 守护进程主机的网络堆栈的容器，或者启动没有网络设备的容器。 本教程将把两个容器连接到桥接网络。</p></li><li><p>启动两个运行阿尔卑斯灰的容器，这是阿尔卑斯的默认外壳而不是猛击。 Dit 标志意味着启动分离的容器(在后台)、交互式的容器(可以在其中键入内容)和 TTY (这样您就可以看到输入和输出)。 因为是分离启动的，所以不会马上连接到容器。 相反，容器的 ID 将被打印出来。 因为您没有指定任何 – 网络标志，所以容器连接到默认的网桥网络。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run -dit --name alpine1 alpine ash$ docker run -dit --name alpine2 alpine ash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>检查两个容器是否实际启动:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container <span class="token function">ls</span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES602dbf1edc81        alpine              <span class="token string">"ash"</span>               4 seconds ago       Up 3 seconds                            alpine2da33b7aa74b0        alpine              <span class="token string">"ash"</span>               17 seconds ago      Up 16 seconds  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>检查桥接网络，看看有哪些容器连接到它。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network inspect bridge<span class="token punctuation">[</span> <span class="token punctuation">{</span>     <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"bridge"</span>,     <span class="token string">"Id"</span><span class="token keyword">:</span> <span class="token string">"17e324f459648a9baaea32b248d3884da102dde19396c25b30ec800068ce6b10"</span>,     <span class="token string">"Created"</span><span class="token keyword">:</span> <span class="token string">"2017-06-22T20:27:43.826654485Z"</span>,     <span class="token string">"Scope"</span><span class="token keyword">:</span> <span class="token string">"local"</span>,     <span class="token string">"Driver"</span><span class="token keyword">:</span> <span class="token string">"bridge"</span>,     <span class="token string">"EnableIPv6"</span><span class="token keyword">:</span> false,     <span class="token string">"IPAM"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>         <span class="token string">"Driver"</span><span class="token keyword">:</span> <span class="token string">"default"</span>,         <span class="token string">"Options"</span><span class="token keyword">:</span> null,         <span class="token string">"Config"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>             <span class="token punctuation">{</span>                 <span class="token string">"Subnet"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.0/16"</span>,                 <span class="token string">"Gateway"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.1"</span>             <span class="token punctuation">}</span>         <span class="token punctuation">]</span>     <span class="token punctuation">}</span>,     <span class="token string">"Internal"</span><span class="token keyword">:</span> false,     <span class="token string">"Attachable"</span><span class="token keyword">:</span> false,     <span class="token string">"Containers"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>         <span class="token string">"602dbf1edc81813304b6cf0a647e65333dc6fe6ee6ed572dc0f686a3307c6a2c"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>             <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"alpine2"</span>,             <span class="token string">"EndpointID"</span><span class="token keyword">:</span> <span class="token string">"03b6aafb7ca4d7e531e292901b43719c0e34cc7eef565b38a6bf84acf50f38cd"</span>,             <span class="token string">"MacAddress"</span><span class="token keyword">:</span> <span class="token string">"02:42:ac:11:00:03"</span>,             <span class="token string">"IPv4Address"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.3/16"</span>,             <span class="token string">"IPv6Address"</span><span class="token keyword">:</span> <span class="token string">""</span>         <span class="token punctuation">}</span>,         <span class="token string">"da33b7aa74b0bf3bda3ebd502d404320ca112a268aafe05b4851d1e3312ed168"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>             <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"alpine1"</span>,             <span class="token string">"EndpointID"</span><span class="token keyword">:</span> <span class="token string">"46c044a645d6afc42ddd7857d19e9dcfb89ad790afb5c239a35ac0af5e8a5bc5"</span>,             <span class="token string">"MacAddress"</span><span class="token keyword">:</span> <span class="token string">"02:42:ac:11:00:02"</span>,             <span class="token string">"IPv4Address"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.2/16"</span>,             <span class="token string">"IPv6Address"</span><span class="token keyword">:</span> <span class="token string">""</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>,     <span class="token string">"Options"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>         <span class="token string">"com.docker.network.bridge.default_bridge"</span><span class="token keyword">:</span> <span class="token string">"true"</span>,         <span class="token string">"com.docker.network.bridge.enable_icc"</span><span class="token keyword">:</span> <span class="token string">"true"</span>,         <span class="token string">"com.docker.network.bridge.enable_ip_masquerade"</span><span class="token keyword">:</span> <span class="token string">"true"</span>,         <span class="token string">"com.docker.network.bridge.host_binding_ipv4"</span><span class="token keyword">:</span> <span class="token string">"0.0.0.0"</span>,         <span class="token string">"com.docker.network.bridge.name"</span><span class="token keyword">:</span> <span class="token string">"docker0"</span>,         <span class="token string">"com.docker.network.driver.mtu"</span><span class="token keyword">:</span> <span class="token string">"1500"</span>     <span class="token punctuation">}</span>,     <span class="token string">"Labels"</span><span class="token keyword">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在顶部附近，列出了有关桥接网络的信息，包括 Docker 主机和桥接网络之间网关的 IP 地址(172.17.0.1)。 在 Containers 键下，列出了每个连接的容器，以及有关其 IP 地址的信息(alpine1为172.17.0.2，alpine2为172.17.0.3)。</p></li><li><p>容器在后台运行。使用 <code>docker attach</code> 命令连接到 <code>alpine1</code>。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker attach alpine1/ <span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>提示将更改为 <code>#</code> ，以指示您是容器中的根用户。 使用 <code>ip addr show</code> 命令显示 <code>alpine1</code>的网络接口，因为它们从容器内部观察:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ip addr show</span>1: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">></span> mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo   valid_lft forever preferred_lft forever inet6 ::1/128 scope host   valid_lft forever preferred_lft forever27: eth0@if28: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN<span class="token operator">></span> mtu 1500 qdisc noqueue state UP link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff inet 172.17.0.2/16 scope global eth0   valid_lft forever preferred_lft forever inet6 fe80::42:acff:fe11:2/64 scope <span class="token function">link</span>   valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个接口是环回设备。 暂时忽略它。 请注意，第二个接口的 IP 地址为172.17.0.2，与前面步骤中显示的 alpine1的地址相同。</p></li><li><p>在 <code>alpine1</code> 内部，确保你可以通过 <code>ping google.com</code> 连接到互联网。 <code>-c 2</code> 标志将命令限制为两次 ping 尝试。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ping -c 2 google.com</span>PING google.com <span class="token punctuation">(</span>172.217.3.174<span class="token punctuation">)</span>: 56 data bytes64 bytes from 172.217.3.174: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>41 time<span class="token operator">=</span>9.841 ms64 bytes from 172.217.3.174: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>41 time<span class="token operator">=</span>9.897 ms\--- google.com <span class="token function">ping</span> statistics ---2 packets transmitted, 2 packets received, 0% packet lossround-trip min/avg/max <span class="token operator">=</span> 9.841/9.869/9.897 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>现在尝试 ping 第二个容器，首先，ping 它的 IP 地址，172.17.0.3:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ping -c 2 172.17.0.3</span>PING 172.17.0.3 <span class="token punctuation">(</span>172.17.0.3<span class="token punctuation">)</span>: 56 data bytes64 bytes from 172.17.0.3: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.086 ms64 bytes from 172.17.0.3: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.094 ms\--- 172.17.0.3 <span class="token function">ping</span> statistics ---2 packets transmitted, 2 packets received, 0% packet lossround-trip min/avg/max <span class="token operator">=</span> 0.086/0.090/0.094 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成功。接下来，尝试按容器名称 ping alpine2容器。这将失败。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ping -c 2 alpine2</span>ping: bad address <span class="token string">'alpine2'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>通过使用分离序列，CTRL + p CTRL + q (按住 CTRL，输入 p 后跟 q)从 <code>alpine1</code>中分离，而不停止它。 如果你愿意，连接到 <code>alpine2</code>，重复步骤4,5,6，用 <code>alpine1</code>代替 <code>alpine2</code>。</p></li><li><p>停止并移走两个容器。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container stop alpine1 alpine2$ docker container <span class="token function">rm</span> alpine1 alpine2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>请记住，生产环境中不推荐使用默认的网桥网络。 要了解用户定义的桥梁网络，请继续阅读下一个教程。</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 容器服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门系列  4. Docker 容器网络的概念及网络配置 网桥网络</title>
      <link href="/posts/27457.html"/>
      <url>/posts/27457.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-使用网桥网络"><a href="#1-使用网桥网络" class="headerlink" title="1. 使用网桥网络"></a>1. 使用网桥网络</h2><p>就网络而言，桥接网络是在网段之间转发流量的链路层设备。桥接器可以是在主机内核中运行的硬件设备或软件设备。</p><p>就 Docker 而言，桥接网络使用一个软件桥接器，它允许连接到同一桥接网络的容器进行通信，同时提供与未连接到桥接网络的容器的隔离。 Docker 桥接驱动程序在主机上自动安装规则，使不同桥接网络上的容器不能直接相互通信。</p><p>桥接网络应用于运行在同一个 Docker 守护进程主机上的容器。 对于运行在不同 Docker 守护进程主机上的容器之间的通信，您可以在操作系统级别管理路由，也可以使用<code>覆盖网络</code>。</p><p>启动Docker时，会自动创建一个<code>默认的桥接网络</code>（也称为<code>bridge</code>），除非另有说明，否则新启动的容器将连接到它。您还可以创建用户定义的自定义网桥网络。<strong>用户定义的网桥网络优于默认<code>bridge</code> 网络</strong>。</p><h3 id="1-1-用户定义的网桥和默认网桥之间的区别"><a href="#1-1-用户定义的网桥和默认网桥之间的区别" class="headerlink" title="1.1 用户定义的网桥和默认网桥之间的区别"></a>1.1 用户定义的网桥和默认网桥之间的区别</h3><ul><li><p><strong>用户定义的桥接提供了更好的隔离和容器化应用程序之间的互操作性。</strong></p><p>  连接到相同的用户定义桥接网络的容器自动将所有端口相互公开，而不向外部世界公开端口。 这使得容器化的应用程序可以轻松地相互通信，而不会意外地打开对外部世界的访问。</p><p>  想象一下，一个应用程序有一个 web 前端和一个数据库后端。 外部世界需要访问 web 前端(可能在端口80上) ，但只有后端本身需要访问数据库主机和端口。 使用用户定义的网桥，只需要打开 web 端口，数据库应用程序不需要打开任何端口，因为 web 前端可以通过用户定义的网桥到达它。</p><blockquote><p>如果在缺省桥接网络上运行相同的应用程序堆栈，则需要同时打开 web 端口和数据库端口，并为每个端口使用-p 或 – publish 标志。 这意味着 Docker 主机需要通过其他方式阻止对数据库端口的访问。</p></blockquote></li><li><p><strong>用户定义的网桥可在容器之间提供自动DNS解析。</strong></p><p>  默认桥网络上的容器只能通过 IP 地址访问彼此，除非您使用 – link 选项，这被认为是遗留的。 在用户定义的网桥网络上，容器可以通过名称或别名相互解析。</p><p>  想象一下与前一点相同的应用程序，它有一个 web 前端和一个数据库后端。 如果你调用你的容器 web 和 db，web 容器可以连接到 db 容器，不管 Docker 主机上运行的应用程序堆栈是什么。</p><blockquote><p>如果在默认网桥网络上运行相同的应用程序堆栈，则需要在容器之间手动创建链接（使用旧式–link 标志）。这些链接需要双向创建，因此您可以看到，要进行通信的容器超过两个，这将变得很复杂。另外，您可以操纵/etc/hosts容器中的文件，但这会产生难以调试的问题。</p></blockquote></li><li><p><strong>容器可以随时随地从用户定义的网络连接和分离。</strong></p><blockquote><p>在容器的生命周期内，您可以即时将其与用户定义的网络连接或断开连接。要从默认桥接网络中删除容器，您需要停止容器并使用其他网络选项重新创建它。</p></blockquote></li><li><p><strong>每个用户定义的网络都会创建一个可配置的网桥。</strong></p><p>  如果您的容器使用默认桥接网络，则可以对其进行配置，但是所有容器都使用相同的设置，例如MTU和iptables规则。另外，配置默认桥接网络发生在Docker本身之外，并且需要重新启动Docker。</p><blockquote><p>使用 <code>docker network create</code> 创建和配置用户定义的桥接网络。 如果不同的应用程序组有不同的网络需求，您可以在创建用户定义的桥接时分别配置它。</p></blockquote></li><li><p><strong>默认网桥网络上的链接容器共享环境变量。</strong></p><p>  最初，在两个容器之间共享环境变量的唯一方法是使用 – link 标志将它们链接起来。 这种类型的变量共享在用户定义的网络中是不可能的。 但是，有一些共享环境变量的优秀方法。 以下是一些建议:</p><ul><li><p>多个容器可以使用Docker卷挂载包含共享信息的文件或目录。</p></li><li><p>使用可以一起启动多个容器docker-compose，并且compose文件可以定义共享变量。</p></li><li><p>您可以使用群体服务代替独立容器，并利用共享的<code>secrets</code>和 <code>configs</code>。</p></li></ul></li></ul><p>连接到同一个用户定义的桥接网络的容器有效地将所有端口相互暴露。 对于不同网络上的容器或非 docker 主机可以访问的端口，必须使用 -p 或 – publish 标志发布该端口。</p><h3 id="1-2-管理用户定义的网桥"><a href="#1-2-管理用户定义的网桥" class="headerlink" title="1.2 管理用户定义的网桥"></a>1.2 管理用户定义的网桥</h3><p>使用该docker network create命令创建用户定义的网桥网络。</p><pre class="line-numbers language-bash"><code class="language-bash">docker network create my-net<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您可以指定子网，IP地址范围，网关和其他选项。</p><p>使用<code>docker network rm</code>命令删除用户定义的网桥网络。如果容器当前已连接到网络， 请先断开它们。</p><pre class="line-numbers language-bash"><code class="language-bash">docker network <span class="token function">rm</span> my-net<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p> <strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8">⚠</span> 到底发生了什么事？</strong></p><p>当您创建或删除用户定义的桥接或从用户定义的桥接连接或断开容器时，Docker 使用特定于操作系统的工具来管理底层网络基础设施(例如添加或删除桥接设备或在 Linux 上配置 iptables 规则)。 这些细节应该被视为实现细节。 让 Docker 为您管理用户定义的网络。</p></blockquote><h3 id="1-3-将容器连接到用户定义的网桥"><a href="#1-3-将容器连接到用户定义的网桥" class="headerlink" title="1.3 将容器连接到用户定义的网桥"></a>1.3 将容器连接到用户定义的网桥</h3><p>创建新容器时，可以指定一个或多个网络标志。 此示例将 Nginx 容器连接到 <code>my-net</code> 网络。 它还将容器中的端口80发布到 Docker 主机上的端口8080，这样外部客户机就可以访问该端口。 连接到 <code>my-net</code> 网络的任何其他容器都可以访问 <code>my-nginx</code> 容器上的所有端口，反之亦然。</p><pre class="line-numbers language-bash"><code class="language-bash">docker create --name my-nginx \  --network my-net \  --publish 8080:80 \  nginx:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>若要将正在运行的容器连接到现有的用户定义桥接器，请使用 <code>docker network connect</code> 命令。 下面的命令将一个已经运行的 <code>my-nginx</code> 容器连接到一个已经存在的 <code>my-net</code> 网络:</p><pre class="line-numbers language-bash"><code class="language-bash">docker network connect my-net my-nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-4-断开容器与用户定义的网桥的连接"><a href="#1-4-断开容器与用户定义的网桥的连接" class="headerlink" title="1.4 断开容器与用户定义的网桥的连接"></a>1.4 断开容器与用户定义的网桥的连接</h3><p>若要断开正在运行的容器与用户定义的桥接器的连接，请使用 <code>docker network disconnect</code> 命令。 下面的命令断开 <code>my-nginx</code> 容器与 <code>my-net</code> 网络的连接。</p><pre class="line-numbers language-bash"><code class="language-bash">docker network disconnect my-net my-nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-5-使用IPv6"><a href="#1-5-使用IPv6" class="headerlink" title="1.5 使用IPv6"></a>1.5 使用IPv6</h3><p>如果您需要对 Docker 容器的 IPv6支持，那么在创建任何 IPv6网络或为容器分配 IPv6地址之前，您需要启用 Docker 守护进程上的选项并重新加载其配置。</p><p>创建网络时，可以指定 <code>--ipv6</code>标志以启用 IPv6。 你不能选择性地禁用默认桥接网络的 IPv6支持。</p><h3 id="1-6-启用从Docker容器到外界的转发"><a href="#1-6-启用从Docker容器到外界的转发" class="headerlink" title="1.6 启用从Docker容器到外界的转发"></a>1.6 启用从Docker容器到外界的转发</h3><p>默认情况下，来自连接到默认网桥网络的容器的流量 不会转发到外界。要启用转发，您需要更改两个设置。这些不是Docker命令，它们会影响Docker主机的内核。</p><ol><li><p>配置Linux内核以允许IP转发。</p><pre class="line-numbers language-bash"><code class="language-bash">sysctl net.ipv4.conf.all.forwarding<span class="token operator">=</span>1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>将策略的iptables FORWARD策略从更改DROP为 ACCEPT。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> iptables -P FORWARD ACCEPT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>这些设置不会在重新启动后持续存在，因此您可能需要将它们添加到启动脚本中。</p><h3 id="1-7-使用默认的桥接网络"><a href="#1-7-使用默认的桥接网络" class="headerlink" title="1.7 使用默认的桥接网络"></a>1.7 使用默认的桥接网络</h3><p>默认<code>bridge</code>网络被认为是Docker的遗留细节，不建议用于生产环境。对其进行配置是手动操作，并且存在 技术缺陷。</p><h4 id="将容器连接到默认网桥网络"><a href="#将容器连接到默认网桥网络" class="headerlink" title="将容器连接到默认网桥网络"></a>将容器连接到默认网桥网络</h4><p>如果没有使用 – network 标志指定网络，并且指定了网络驱动程序，则默认情况下容器将连接到默认桥接网络。 连接到默认桥接网络的容器可以通信，但只能通过 IP 地址通信，除非使用遗留的 – link 标志链接它们。</p><h4 id="配置默认网桥网络"><a href="#配置默认网桥网络" class="headerlink" title="配置默认网桥网络"></a>配置默认网桥网络</h4><p>要配置默认的桥接网络，可以在 daemon.json 中指定选项。 下面是一个指定了几个选项的 daemon.json 示例。 只指定需要自定义的设置。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">{</span>  <span class="token string">"bip"</span><span class="token keyword">:</span> <span class="token string">"192.168.1.5/24"</span>,  <span class="token string">"fixed-cidr"</span><span class="token keyword">:</span> <span class="token string">"192.168.1.5/25"</span>,  <span class="token string">"fixed-cidr-v6"</span><span class="token keyword">:</span> <span class="token string">"2001:db8::/64"</span>,  <span class="token string">"mtu"</span><span class="token keyword">:</span> 1500,  <span class="token string">"default-gateway"</span><span class="token keyword">:</span> <span class="token string">"10.20.1.1"</span>,  <span class="token string">"default-gateway-v6"</span><span class="token keyword">:</span> <span class="token string">"2001:db8:abcd::89"</span>,  <span class="token string">"dns"</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token string">"10.20.1.2"</span>,<span class="token string">"10.20.1.3"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重新启动Docker以使更改生效。</p><h4 id="将IPv6与默认桥接网络一起使用"><a href="#将IPv6与默认桥接网络一起使用" class="headerlink" title="将IPv6与默认桥接网络一起使用"></a>将IPv6与默认桥接网络一起使用</h4><p>如果您为 IPv6支持配置 Docker (请参阅使用 IPv6) ，默认桥接网络也会自动为 IPv6配置。 与用户定义的网桥不同，您不能在缺省网桥上有选择地禁用 IPv6。</p><h2 id="2-实践练习-与独立容器联网"><a href="#2-实践练习-与独立容器联网" class="headerlink" title="2. 实践练习 与独立容器联网"></a>2. 实践练习 与独立容器联网</h2><ul><li><p>使<code>用默认桥接网络</code> 演示如何使用 Docker 为您自动设置的默认桥网络。 这个网络不是生产系统的最佳选择。</p></li><li><p><code>使用用户定义的桥接网络</code> 演示了如何创建和使用自己的定制桥接网络，以连接运行在同一个 Docker 主机上的容器。 建议在生产环境中运行的独立容器使用这种方法。</p></li></ul><h3 id="2-1-使用默认的桥接网络"><a href="#2-1-使用默认的桥接网络" class="headerlink" title="2.1 使用默认的桥接网络"></a>2.1 使用默认的桥接网络</h3><p>在本例中，您在同一个 Docker 主机上启动两个不同的 alpine 容器，并进行一些测试以了解它们如何彼此通信。 您需要安装并运行 Docker。</p><ol><li><p>打开终端窗口。 在你做任何事情之前列出当前的网络。 如果您从未在这个 Docker 守护进程上添加过网络或初始化过一个群，下面是您应该看到的内容。 你可能会看到不同的网络，但是你至少应该看到这些(网络 id 不同) :</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network <span class="token function">ls</span>NETWORK ID          NAME                DRIVER              SCOPE17e324f45964        bridge              bridge              local6ed54d316334        host                host                local7092879f2cc8        none                null                local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>列出了<code>bridge</code>、<code>host</code>和 <code>none</code>。 后两者不是完全成熟的网络，但用于启动直接连接到 Docker 守护进程主机的网络堆栈的容器，或者启动没有网络设备的容器。 本教程将把两个容器连接到桥接网络。</p></li><li><p>启动两个<code>alpine</code>运行的容器<code>ash</code>，这是<code>alpine</code>的默认<code>shell</code>程序，而不是bash。<code>-dit</code>标志意味着启动分离的容器(在后台），交互式的容器(可以在其中键入内容)和 TTY (这样您就可以看到输入和输出)。因为是分离启动的，所以不会马上连接到容器。 相反，容器的 ID 将被打印出来。 因为您没有指定任何 <code>--network</code>标志，因此容器将连接到默认<code>bridge</code>网络。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run -dit --name alpine1 alpine ash$ docker run -dit --name alpine2 alpine ash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>检查两个容器是否确实已启动：</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container <span class="token function">ls</span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES602dbf1edc81        alpine              <span class="token string">"ash"</span>               4 seconds ago       Up 3 seconds                            alpine2da33b7aa74b0        alpine              <span class="token string">"ash"</span>               17 seconds ago      Up 16 seconds                           alpine1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>检查bridge网络以查看连接了哪些容器。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network inspect bridge<span class="token punctuation">[</span> <span class="token punctuation">{</span>     <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"bridge"</span>,     <span class="token string">"Id"</span><span class="token keyword">:</span> <span class="token string">"17e324f459648a9baaea32b248d3884da102dde19396c25b30ec800068ce6b10"</span>,     <span class="token string">"Created"</span><span class="token keyword">:</span> <span class="token string">"2017-06-22T20:27:43.826654485Z"</span>,     <span class="token string">"Scope"</span><span class="token keyword">:</span> <span class="token string">"local"</span>,     <span class="token string">"Driver"</span><span class="token keyword">:</span> <span class="token string">"bridge"</span>,     <span class="token string">"EnableIPv6"</span><span class="token keyword">:</span> false,     <span class="token string">"IPAM"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>         <span class="token string">"Driver"</span><span class="token keyword">:</span> <span class="token string">"default"</span>,         <span class="token string">"Options"</span><span class="token keyword">:</span> null,         <span class="token string">"Config"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>             <span class="token punctuation">{</span>                 <span class="token string">"Subnet"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.0/16"</span>,                 <span class="token string">"Gateway"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.1"</span>             <span class="token punctuation">}</span>         <span class="token punctuation">]</span>     <span class="token punctuation">}</span>,     <span class="token string">"Internal"</span><span class="token keyword">:</span> false,     <span class="token string">"Attachable"</span><span class="token keyword">:</span> false,     <span class="token string">"Containers"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>         <span class="token string">"602dbf1edc81813304b6cf0a647e65333dc6fe6ee6ed572dc0f686a3307c6a2c"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>             <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"alpine2"</span>,             <span class="token string">"EndpointID"</span><span class="token keyword">:</span> <span class="token string">"03b6aafb7ca4d7e531e292901b43719c0e34cc7eef565b38a6bf84acf50f38cd"</span>,             <span class="token string">"MacAddress"</span><span class="token keyword">:</span> <span class="token string">"02:42:ac:11:00:03"</span>,             <span class="token string">"IPv4Address"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.3/16"</span>,             <span class="token string">"IPv6Address"</span><span class="token keyword">:</span> <span class="token string">""</span>         <span class="token punctuation">}</span>,         <span class="token string">"da33b7aa74b0bf3bda3ebd502d404320ca112a268aafe05b4851d1e3312ed168"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>             <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"alpine1"</span>,             <span class="token string">"EndpointID"</span><span class="token keyword">:</span> <span class="token string">"46c044a645d6afc42ddd7857d19e9dcfb89ad790afb5c239a35ac0af5e8a5bc5"</span>,             <span class="token string">"MacAddress"</span><span class="token keyword">:</span> <span class="token string">"02:42:ac:11:00:02"</span>,             <span class="token string">"IPv4Address"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.2/16"</span>,             <span class="token string">"IPv6Address"</span><span class="token keyword">:</span> <span class="token string">""</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>,     <span class="token string">"Options"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>         <span class="token string">"com.docker.network.bridge.default_bridge"</span><span class="token keyword">:</span> <span class="token string">"true"</span>,         <span class="token string">"com.docker.network.bridge.enable_icc"</span><span class="token keyword">:</span> <span class="token string">"true"</span>,         <span class="token string">"com.docker.network.bridge.enable_ip_masquerade"</span><span class="token keyword">:</span> <span class="token string">"true"</span>,         <span class="token string">"com.docker.network.bridge.host_binding_ipv4"</span><span class="token keyword">:</span> <span class="token string">"0.0.0.0"</span>,         <span class="token string">"com.docker.network.bridge.name"</span><span class="token keyword">:</span> <span class="token string">"docker0"</span>,         <span class="token string">"com.docker.network.driver.mtu"</span><span class="token keyword">:</span> <span class="token string">"1500"</span>     <span class="token punctuation">}</span>,     <span class="token string">"Labels"</span><span class="token keyword">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>s在顶部附近，<code>bridge</code>列出了有关网络的信息，包括Docker主机和<code>bridge</code> 网络之间的网关的IP地址（<code>172.17.0.1</code>）。在该<code>Containers</code>键下，列出了每个已连接的容器以及有关其IP地址的信息（<code>172.17.0.2</code>for <code>alpine1</code>和<code>172.17.0.3</code>for <code>alpine2</code>）。</p></blockquote></li><li><p>容器在后台运行。使用docker attach 命令连接到alpine1。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker attach alpine1/ <span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>提示将更改为 # ，以指示您是容器中的根用户。 使用 <code>ip addr show</code> 命令显示 <code>alpine1</code>的网络接口，因为它们从容器内部观察:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ip addr show</span>1: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">></span> mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo   valid_lft forever preferred_lft forever inet6 ::1/128 scope host   valid_lft forever preferred_lft forever27: eth0@if28: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN<span class="token operator">></span> mtu 1500 qdisc noqueue state UP link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff inet 172.17.0.2/16 scope global eth0   valid_lft forever preferred_lft forever inet6 fe80::42:acff:fe11:2/64 scope <span class="token function">link</span>   valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个接口是环回设备。 暂时忽略它。 请注意，第二个接口的 IP 地址为<code>172.17.0.2</code>，与前面步骤中显示的 <code>alpine1</code>的地址相同。</p></li><li><p>在 <code>alpine1</code>内部，确保你可以通过 <code>ping google.com</code>连接到互联网。该 <code>-c2</code>标志将命令限制为两次ping 尝试。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ping -c 2 google.com</span>PING google.com <span class="token punctuation">(</span>172.217.3.174<span class="token punctuation">)</span>: 56 data bytes64 bytes from 172.217.3.174: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>41 time<span class="token operator">=</span>9.841 ms64 bytes from 172.217.3.174: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>41 time<span class="token operator">=</span>9.897 ms\--- google.com <span class="token function">ping</span> statistics ---2 packets transmitted, 2 packets received, 0% packet lossround-trip min/avg/max <span class="token operator">=</span> 9.841/9.869/9.897 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>现在尝试 ping 第二个容器，首先，ping 它的 IP 地址，<code>172.17.0.3</code>:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ping -c 2 172.17.0.3</span>PING 172.17.0.3 <span class="token punctuation">(</span>172.17.0.3<span class="token punctuation">)</span>: 56 data bytes64 bytes from 172.17.0.3: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.086 ms64 bytes from 172.17.0.3: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.094 ms\--- 172.17.0.3 <span class="token function">ping</span> statistics ---2 packets transmitted, 2 packets received, 0% packet lossround-trip min/avg/max <span class="token operator">=</span> 0.086/0.090/0.094 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成功。接下来，尝试按容器名称 <code>ping alpine2</code>容器。这将失败。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ping -c 2 alpine2</span>ping: bad address <span class="token string">'alpine2'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>通过使用分离序列，<code>CTRL + p</code> <code>CTRL + q</code> (按住 CTRL，输入 p 后跟 q)从 <code>alpine1</code>中分离，而不停止它。 如果你愿意，连接到 <code>alpine2</code>，重复步骤4,5,6，用 <code>alpine1</code>代替 <code>alpine2</code>。</p></li><li><p>停止并移走两个容器。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container stop alpine1 alpine2$ docker container <span class="token function">rm</span> alpine1 alpine2 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><blockquote><p>请记住，生产环境中不推荐使用默认的网桥网络。</p></blockquote><h3 id="2-2-使用用户定义的网桥"><a href="#2-2-使用用户定义的网桥" class="headerlink" title="2.2 使用用户定义的网桥"></a>2.2 使用用户定义的网桥</h3><p>在这个例子中，我们再次启动两个 <code>alpine</code> 容器，但是将它们附加到我们已经创建的用户定义的网络 <code>alpine-net</code> 中。 这些容器根本没有连接到缺省<code>网桥网络</code>。 然后我们开始第三个<code>alpine</code>容器，连接到<code>桥接网络</code>，但不连接到<code>lpine-net</code>，和第四个<code>alpine</code>容器，同事连接到这两个网络。</p><ol><li><p>创建·alpine-net·网络。您不需要<code>--driver bridge</code>标志，因为它是默认标志，但是此示例显示了如何指定它。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create --driver bridge alpine-net<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>列出Docker的网络：</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network <span class="token function">ls</span>NETWORK ID          NAME                DRIVER              SCOPEe9261a8c9a19        alpine-net          bridge              local17e324f45964        bridge              bridge              local6ed54d316334        host                host                local7092879f2cc8        none                null                local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>检查·alpine-net·网络。这显示了它的IP地址以及没有容器连接到它：</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network inspect alpine-net<span class="token punctuation">[</span> <span class="token punctuation">{</span>     <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"alpine-net"</span>,     <span class="token string">"Id"</span><span class="token keyword">:</span> <span class="token string">"e9261a8c9a19eabf2bf1488bf5f208b99b1608f330cff585c273d39481c9b0ec"</span>,     <span class="token string">"Created"</span><span class="token keyword">:</span> <span class="token string">"2017-09-25T21:38:12.620046142Z"</span>,     <span class="token string">"Scope"</span><span class="token keyword">:</span> <span class="token string">"local"</span>,     <span class="token string">"Driver"</span><span class="token keyword">:</span> <span class="token string">"bridge"</span>,     <span class="token string">"EnableIPv6"</span><span class="token keyword">:</span> false,     <span class="token string">"IPAM"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>         <span class="token string">"Driver"</span><span class="token keyword">:</span> <span class="token string">"default"</span>,         <span class="token string">"Options"</span><span class="token keyword">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>,         <span class="token string">"Config"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>             <span class="token punctuation">{</span>                 <span class="token string">"Subnet"</span><span class="token keyword">:</span> <span class="token string">"172.18.0.0/16"</span>,                 <span class="token string">"Gateway"</span><span class="token keyword">:</span> <span class="token string">"172.18.0.1"</span>             <span class="token punctuation">}</span>         <span class="token punctuation">]</span>     <span class="token punctuation">}</span>,     <span class="token string">"Internal"</span><span class="token keyword">:</span> false,     <span class="token string">"Attachable"</span><span class="token keyword">:</span> false,     <span class="token string">"Containers"</span><span class="token keyword">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>,     <span class="token string">"Options"</span><span class="token keyword">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>,     <span class="token string">"Labels"</span><span class="token keyword">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请注意，这个网络的网关是172.18.0.1，与缺省网桥网络相反，后者的网关是172.17.0.1。 确切的 IP 地址在您的系统上可能不同。</p></li><li><p>创建四个容器。注意<code>--network</code>标志。在<code>docker run</code>命令期间，您只能连接到一个网络，因此需要在之后使用 <code>docker network connect</code>将 <code>alpine4</code>连接到桥接网络。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run -dit --name alpine1 --network alpine-net alpine ash$ docker run -dit --name alpine2 --network alpine-net alpine ash$ docker run -dit --name alpine3 alpine ash$ docker run -dit --name alpine4 --network alpine-net alpine ash$ docker network connect bridge alpine4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>验证所有容器都在运行：</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container <span class="token function">ls</span>CONTAINER ID        IMAGE               COMMAND             CREATED              STATUS              PORTS               NAMES156849ccd902        alpine              <span class="token string">"ash"</span>               41 seconds ago       Up 41 seconds                           alpine4fa1340b8d83e        alpine              <span class="token string">"ash"</span>               51 seconds ago       Up 51 seconds                           alpine3a535d969081e        alpine              <span class="token string">"ash"</span>               About a minute ago   Up About a minute                       alpine20a02c449a6e9        alpine              <span class="token string">"ash"</span>               About a minute ago   Up About a minute                       alpine1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>检查<code>bridge</code>网络和<code>alpine-net</code>网络：</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network inspect bridge<span class="token punctuation">[</span> <span class="token punctuation">{</span>     <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"bridge"</span>,     <span class="token string">"Id"</span><span class="token keyword">:</span> <span class="token string">"17e324f459648a9baaea32b248d3884da102dde19396c25b30ec800068ce6b10"</span>,     <span class="token string">"Created"</span><span class="token keyword">:</span> <span class="token string">"2017-06-22T20:27:43.826654485Z"</span>,     <span class="token string">"Scope"</span><span class="token keyword">:</span> <span class="token string">"local"</span>,     <span class="token string">"Driver"</span><span class="token keyword">:</span> <span class="token string">"bridge"</span>,     <span class="token string">"EnableIPv6"</span><span class="token keyword">:</span> false,     <span class="token string">"IPAM"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>         <span class="token string">"Driver"</span><span class="token keyword">:</span> <span class="token string">"default"</span>,         <span class="token string">"Options"</span><span class="token keyword">:</span> null,         <span class="token string">"Config"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>             <span class="token punctuation">{</span>                 <span class="token string">"Subnet"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.0/16"</span>,                 <span class="token string">"Gateway"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.1"</span>             <span class="token punctuation">}</span>         <span class="token punctuation">]</span>     <span class="token punctuation">}</span>,     <span class="token string">"Internal"</span><span class="token keyword">:</span> false,     <span class="token string">"Attachable"</span><span class="token keyword">:</span> false,     <span class="token string">"Containers"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>         <span class="token string">"156849ccd902b812b7d17f05d2d81532ccebe5bf788c9a79de63e12bb92fc621"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>             <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"alpine4"</span>,             <span class="token string">"EndpointID"</span><span class="token keyword">:</span> <span class="token string">"7277c5183f0da5148b33d05f329371fce7befc5282d2619cfb23690b2adf467d"</span>,             <span class="token string">"MacAddress"</span><span class="token keyword">:</span> <span class="token string">"02:42:ac:11:00:03"</span>,             <span class="token string">"IPv4Address"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.3/16"</span>,             <span class="token string">"IPv6Address"</span><span class="token keyword">:</span> <span class="token string">""</span>         <span class="token punctuation">}</span>,         <span class="token string">"fa1340b8d83eef5497166951184ad3691eb48678a3664608ec448a687b047c53"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>             <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"alpine3"</span>,             <span class="token string">"EndpointID"</span><span class="token keyword">:</span> <span class="token string">"5ae767367dcbebc712c02d49556285e888819d4da6b69d88cd1b0d52a83af95f"</span>,             <span class="token string">"MacAddress"</span><span class="token keyword">:</span> <span class="token string">"02:42:ac:11:00:02"</span>,             <span class="token string">"IPv4Address"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.2/16"</span>,             <span class="token string">"IPv6Address"</span><span class="token keyword">:</span> <span class="token string">""</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>,     <span class="token string">"Options"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>         <span class="token string">"com.docker.network.bridge.default_bridge"</span><span class="token keyword">:</span> <span class="token string">"true"</span>,         <span class="token string">"com.docker.network.bridge.enable_icc"</span><span class="token keyword">:</span> <span class="token string">"true"</span>,         <span class="token string">"com.docker.network.bridge.enable_ip_masquerade"</span><span class="token keyword">:</span> <span class="token string">"true"</span>,         <span class="token string">"com.docker.network.bridge.host_binding_ipv4"</span><span class="token keyword">:</span> <span class="token string">"0.0.0.0"</span>,         <span class="token string">"com.docker.network.bridge.name"</span><span class="token keyword">:</span> <span class="token string">"docker0"</span>,         <span class="token string">"com.docker.network.driver.mtu"</span><span class="token keyword">:</span> <span class="token string">"1500"</span>     <span class="token punctuation">}</span>,     <span class="token string">"Labels"</span><span class="token keyword">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>容器<code>alpine3</code>和<code>alpine4</code>连接到<code>bridge</code>网络。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network inspect alpine-net<span class="token punctuation">[</span> <span class="token punctuation">{</span>     <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"alpine-net"</span>,     <span class="token string">"Id"</span><span class="token keyword">:</span> <span class="token string">"e9261a8c9a19eabf2bf1488bf5f208b99b1608f330cff585c273d39481c9b0ec"</span>,     <span class="token string">"Created"</span><span class="token keyword">:</span> <span class="token string">"2017-09-25T21:38:12.620046142Z"</span>,     <span class="token string">"Scope"</span><span class="token keyword">:</span> <span class="token string">"local"</span>,     <span class="token string">"Driver"</span><span class="token keyword">:</span> <span class="token string">"bridge"</span>,     <span class="token string">"EnableIPv6"</span><span class="token keyword">:</span> false,     <span class="token string">"IPAM"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>         <span class="token string">"Driver"</span><span class="token keyword">:</span> <span class="token string">"default"</span>,         <span class="token string">"Options"</span><span class="token keyword">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>,         <span class="token string">"Config"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>             <span class="token punctuation">{</span>                 <span class="token string">"Subnet"</span><span class="token keyword">:</span> <span class="token string">"172.18.0.0/16"</span>,                 <span class="token string">"Gateway"</span><span class="token keyword">:</span> <span class="token string">"172.18.0.1"</span>             <span class="token punctuation">}</span>         <span class="token punctuation">]</span>     <span class="token punctuation">}</span>,     <span class="token string">"Internal"</span><span class="token keyword">:</span> false,     <span class="token string">"Attachable"</span><span class="token keyword">:</span> false,     <span class="token string">"Containers"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>         <span class="token string">"0a02c449a6e9a15113c51ab2681d72749548fb9f78fae4493e3b2e4e74199c4a"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>             <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"alpine1"</span>,             <span class="token string">"EndpointID"</span><span class="token keyword">:</span> <span class="token string">"c83621678eff9628f4e2d52baf82c49f974c36c05cba152db4c131e8e7a64673"</span>,             <span class="token string">"MacAddress"</span><span class="token keyword">:</span> <span class="token string">"02:42:ac:12:00:02"</span>,             <span class="token string">"IPv4Address"</span><span class="token keyword">:</span> <span class="token string">"172.18.0.2/16"</span>,             <span class="token string">"IPv6Address"</span><span class="token keyword">:</span> <span class="token string">""</span>         <span class="token punctuation">}</span>,         <span class="token string">"156849ccd902b812b7d17f05d2d81532ccebe5bf788c9a79de63e12bb92fc621"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>             <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"alpine4"</span>,             <span class="token string">"EndpointID"</span><span class="token keyword">:</span> <span class="token string">"058bc6a5e9272b532ef9a6ea6d7f3db4c37527ae2625d1cd1421580fd0731954"</span>,             <span class="token string">"MacAddress"</span><span class="token keyword">:</span> <span class="token string">"02:42:ac:12:00:04"</span>,             <span class="token string">"IPv4Address"</span><span class="token keyword">:</span> <span class="token string">"172.18.0.4/16"</span>,             <span class="token string">"IPv6Address"</span><span class="token keyword">:</span> <span class="token string">""</span>         <span class="token punctuation">}</span>,         <span class="token string">"a535d969081e003a149be8917631215616d9401edcb4d35d53f00e75ea1db653"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>             <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"alpine2"</span>,             <span class="token string">"EndpointID"</span><span class="token keyword">:</span> <span class="token string">"198f3141ccf2e7dba67bce358d7b71a07c5488e3867d8b7ad55a4c695ebb8740"</span>,             <span class="token string">"MacAddress"</span><span class="token keyword">:</span> <span class="token string">"02:42:ac:12:00:03"</span>,             <span class="token string">"IPv4Address"</span><span class="token keyword">:</span> <span class="token string">"172.18.0.3/16"</span>,             <span class="token string">"IPv6Address"</span><span class="token keyword">:</span> <span class="token string">""</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>,     <span class="token string">"Options"</span><span class="token keyword">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>,     <span class="token string">"Labels"</span><span class="token keyword">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>容器<code>alpine1</code>，<code>alpine2</code>和<code>alpine4</code>连接到 <code>alpine-net</code>网络。</p></li><li><p>在用户定义网络<code>alpine-net</code>，容器不仅可以通过IP地址进行通信，还可以将容器名称解析为IP地址。此功能称为<strong>自动服务发现</strong>。让我们连接<code>alpine1</code>并测试一下。<code>alpine1</code>应该能够解析 <code>alpine2</code>和<code>alpine4</code>（以及<code>alpine1</code>本身）为IP地址。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container attach alpine1<span class="token comment" spellcheck="true"># ping -c 2 alpine2</span>PING alpine2 <span class="token punctuation">(</span>172.18.0.3<span class="token punctuation">)</span>: 56 data bytes64 bytes from 172.18.0.3: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.085 ms64 bytes from 172.18.0.3: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.090 ms\--- alpine2 <span class="token function">ping</span> statistics ---2 packets transmitted, 2 packets received, 0% packet lossround-trip min/avg/max <span class="token operator">=</span> 0.085/0.087/0.090 ms<span class="token comment" spellcheck="true"># ping -c 2 alpine4</span>PING alpine4 <span class="token punctuation">(</span>172.18.0.4<span class="token punctuation">)</span>: 56 data bytes64 bytes from 172.18.0.4: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.076 ms64 bytes from 172.18.0.4: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.091 ms\--- alpine4 <span class="token function">ping</span> statistics ---2 packets transmitted, 2 packets received, 0% packet lossround-trip min/avg/max <span class="token operator">=</span> 0.076/0.083/0.091 ms<span class="token comment" spellcheck="true"># ping -c 2 alpine1</span>PING alpine1 <span class="token punctuation">(</span>172.18.0.2<span class="token punctuation">)</span>: 56 data bytes64 bytes from 172.18.0.2: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.026 ms64 bytes from 172.18.0.2: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.054 ms\--- alpine1 <span class="token function">ping</span> statistics ---2 packets transmitted, 2 packets received, 0% packet lossround-trip min/avg/max <span class="token operator">=</span> 0.026/0.040/0.054 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>从<code>alpine1</code>，您根本无法连接<code>alpine3</code>，因为它不在<code>alpine-net</code>网络上。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ping -c 2 alpine3</span>ping: bad address <span class="token string">'alpine3'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>不仅如此，您也无法通过<code>alpine3</code>的IP地址，从<code>alpine1</code>连接到<code>alpine3</code>。回顾网络的<code>docker network inspect</code>输出 <code>bridge</code>，找到<code>alpine3</code>的IP地址：<code>172.17.0.2</code>尝试ping通它。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ping -c 2 172.17.0.2</span>PING 172.17.0.2 <span class="token punctuation">(</span>172.17.0.2<span class="token punctuation">)</span>: 56 data bytes\--- 172.17.0.2 <span class="token function">ping</span> statistics ---2 packets transmitted, 0 packets received, 100% packet loss<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用分离序列从 <code>alpine1</code>中分离， <code>CTRL+ p</code> <code>CTRL+ q</code>（按住 CTRL，键入 p，然后是 q）。</p></li><li><p>请记住，<code>alpine4</code>已连接到默认<code>bridge</code>网络和<code>alpine-net</code>。它应该能够到达所有其他容器。但是，您将需要<code>alpine3</code>的IP地址进行寻址。附加到它并运行测试。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container attach alpine4<span class="token comment" spellcheck="true"># ping -c 2 alpine1</span>PING alpine1 <span class="token punctuation">(</span>172.18.0.2<span class="token punctuation">)</span>: 56 data bytes64 bytes from 172.18.0.2: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.074 ms64 bytes from 172.18.0.2: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.082 ms\--- alpine1 <span class="token function">ping</span> statistics ---2 packets transmitted, 2 packets received, 0% packet lossround-trip min/avg/max <span class="token operator">=</span> 0.074/0.078/0.082 ms<span class="token comment" spellcheck="true"># ping -c 2 alpine2</span>PING alpine2 <span class="token punctuation">(</span>172.18.0.3<span class="token punctuation">)</span>: 56 data bytes64 bytes from 172.18.0.3: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.075 ms64 bytes from 172.18.0.3: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.080 ms\--- alpine2 <span class="token function">ping</span> statistics ---2 packets transmitted, 2 packets received, 0% packet lossround-trip min/avg/max <span class="token operator">=</span> 0.075/0.077/0.080 ms<span class="token comment" spellcheck="true"># ping -c 2 alpine3</span>ping: bad address <span class="token string">'alpine3'</span><span class="token comment" spellcheck="true"># ping -c 2 172.17.0.2</span>PING 172.17.0.2 <span class="token punctuation">(</span>172.17.0.2<span class="token punctuation">)</span>: 56 data bytes64 bytes from 172.17.0.2: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.089 ms64 bytes from 172.17.0.2: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.075 ms\--- 172.17.0.2 <span class="token function">ping</span> statistics ---2 packets transmitted, 2 packets received, 0% packet lossround-trip min/avg/max <span class="token operator">=</span> 0.075/0.082/0.089 ms<span class="token comment" spellcheck="true"># ping -c 2 alpine4</span>PING alpine4 <span class="token punctuation">(</span>172.18.0.4<span class="token punctuation">)</span>: 56 data bytes64 bytes from 172.18.0.4: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.033 ms64 bytes from 172.18.0.4: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.064 ms\--- alpine4 <span class="token function">ping</span> statistics ---2 packets transmitted, 2 packets received, 0% packet lossround-trip min/avg/max <span class="token operator">=</span> 0.033/0.048/0.064 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>作为最终测试，请通过ping确保您的容器都可以连接到互联网<code>google.com</code>。您已经接入<code>alpine4</code>，因此请从那里开始尝试。接下来，断开alpine4并连接到alpine3 （仅连接到bridge网络）并重试。最后，连接到alpine1（仅连接到alpine-net网络），然后重试。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ping -c 2 google.com</span>PING google.com <span class="token punctuation">(</span>172.217.3.174<span class="token punctuation">)</span>: 56 data bytes64 bytes from 172.217.3.174: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>41 time<span class="token operator">=</span>9.778 ms64 bytes from 172.217.3.174: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>41 time<span class="token operator">=</span>9.634 ms\--- google.com <span class="token function">ping</span> statistics ---2 packets transmitted, 2 packets received, 0% packet lossround-trip min/avg/max <span class="token operator">=</span> 9.634/9.706/9.778 msCTRL+p CTRL+q$ docker container attach alpine3<span class="token comment" spellcheck="true"># ping -c 2 google.com</span>PING google.com <span class="token punctuation">(</span>172.217.3.174<span class="token punctuation">)</span>: 56 data bytes64 bytes from 172.217.3.174: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>41 time<span class="token operator">=</span>9.706 ms64 bytes from 172.217.3.174: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>41 time<span class="token operator">=</span>9.851 ms\--- google.com <span class="token function">ping</span> statistics ---2 packets transmitted, 2 packets received, 0% packet lossround-trip min/avg/max <span class="token operator">=</span> 9.706/9.778/9.851 msCTRL+p CTRL+q$ docker container attach alpine1<span class="token comment" spellcheck="true"># ping -c 2 google.com</span>PING google.com <span class="token punctuation">(</span>172.217.3.174<span class="token punctuation">)</span>: 56 data bytes64 bytes from 172.217.3.174: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>41 time<span class="token operator">=</span>9.606 ms64 bytes from 172.217.3.174: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>41 time<span class="token operator">=</span>9.603 ms\--- google.com <span class="token function">ping</span> statistics ---2 packets transmitted, 2 packets received, 0% packet lossround-trip min/avg/max <span class="token operator">=</span> 9.603/9.604/9.606 msCTRL+p CTRL+q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>停止并卸下所有容器和alpine-net网络。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container stop alpine1 alpine2 alpine3 alpine4$ docker container <span class="token function">rm</span> alpine1 alpine2 alpine3 alpine4$ docker network <span class="token function">rm</span> alpine-net<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 容器服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门系列  3. Docker 容器网络的概念及网络配置 网络概述</title>
      <link href="/posts/50310.html"/>
      <url>/posts/50310.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-网络概述"><a href="#1-网络概述" class="headerlink" title="1. 网络概述"></a>1. 网络概述</h2><p>  Docker容器和服务如此强大的原因之一是你可以将它们连接在一起，或将它们连接到非Docker工作负载。Docker容器和服务甚至不需要知道它们已部署在Docker上，也不必知道它们的对等对象是否也是Docker工作负载。无论您的Docker主机运行Linux，Windows还是两者结合，您都可以使用Docker以与平台无关的方式管理它们。</p><p>本主题定义了一些基本的 Docker 网络概念，并帮助您设计和部署应用程序以充分利用这些功能</p><p>这些内容大多适用于所有的 Docker 安装。 然而，一些高级功能仅适用于Docker 企业版客户。</p><h3 id="1-1-网络驱动"><a href="#1-1-网络驱动" class="headerlink" title="1.1 网络驱动"></a>1.1 网络驱动</h3><p>Docker的网络子系统可使用驱动程序插拔式接入。默认情况下，有几个驱动程序，它们提供核心联网功能：</p><ul><li><p><code>bridge</code>：<code>网桥网络</code> 默认的网络驱动程序。如果您没有指定驱动程序，那么这就是您正在创建的网络类型。桥接网络通常在应用程序运行在需要通信的独立容器中时使用。</p></li><li><p><code>host</code>：<code>主机网络</code> 对于独立容器，请删除容器与Docker主机之间的网络隔离，然后直接使用主机的网络。host 仅可用于Docker 17.06及更高版本上的集群服务。</p></li><li><p><code>overlay</code>：<code>覆盖网络</code> 将多个 Docker 守护进程连接在一起，使群服务能够相互通信。 您还可以使用覆盖网络来促进群服务和独立容器之间的通信，或者在不同的 Docker 守护进程上的两个独立容器之间的通信。 这种策略消除了在这些容器之间执行操作系统级路由的需要。</p></li><li><p><code>macvlan</code>：<code>Macvlan网络</code>网络允许你为容器分配 MAC 地址，使它看起来像是你网络上的一个物理设备。 Docker 守护进程通过容器的 MAC 地址将流量路由到容器。 在处理希望直接连接到物理网络的遗留应用程序时，使用 macvlan 驱动程序有时是最佳选择，而不是通过 Docker 主机的网络栈进行路由。</p></li><li><p><code>none</code>：对于此容器，禁用所有联网。通常与自定义网络驱动程序一起使用。none不适用于群体服务。请参阅 禁用容器联网。</p></li><li><p><code>网络插件</code>：您可以在Docker上安装和使用第三方网络插件。这些插件可从 Docker Hub 或第三方供应商处获得。有关安装和使用给定网络插件的信息，请参阅供应商的文档。</p></li></ul><h4 id="网络驱动程序摘要"><a href="#网络驱动程序摘要" class="headerlink" title="网络驱动程序摘要"></a>网络驱动程序摘要</h4><ul><li>当您需要多个容器在同一Docker主机上进行通信时，最好使用用户定义的<code>网桥网络</code>。</li><li>当网络堆栈不应与Docker主机隔离时，但您希望容器的其他方面隔离时，<code>主机网络</code>是最佳选择。</li><li>当您需要在不同Docker主机上运行的容器进行通信时，或者当多个应用程序使用集群服务一起工作时，<code>覆盖网络</code>是最好的。</li><li>从VM设置迁移或需要容器看起来像网络上的物理主机（每个主机都有唯一的MAC地址）时，<code>Macvlan网络</code>是最好的。</li><li>第三方网络插件使您可以将Docker与专用网络堆栈集成。</li></ul><h3 id="1-2-Docker-EE网络功能"><a href="#1-2-Docker-EE网络功能" class="headerlink" title="1.2 Docker EE网络功能"></a>1.2 Docker EE网络功能</h3><p>以下两个功能仅在使用Docker 企业版和使用通用控制平面（UCP）管理Docker服务时才可用：</p><ul><li><p><code>HTTP路由网格</code> 可以让你分享多个服务之间的相同的网络IP地址和端口。根据客户端的请求，UCP使用主机名和端口的组合将流量路由到适当的服务。</p></li><li><p><code>会话粘性</code> 使您可以在HTTP标头中指定UCP用于需要状态会话的应用程序将后续请求路由到同一服务任务的信息。</p></li></ul><h2 id="2-容器网络"><a href="#2-容器网络" class="headerlink" title="2. 容器网络"></a>2. 容器网络</h2><p>容器使用的网络类型，无论是桥接、覆盖、 macvlan 网络还是定制网络插件，都是从容器内部透明的。 从容器的角度来看，它有一个具有 IP 地址、网关、路由表、 DNS 服务和其他网络详细信息的网络接口(假设容器没有使用 none 网络驱动程序)。</p><h3 id="2-1-发布端口"><a href="#2-1-发布端口" class="headerlink" title="2.1 发布端口"></a>2.1 发布端口</h3><p>默认情况下，当您创建一个容器时，它不会向外部世界发布它的任何端口。 若要使一个端口可用于 Docker 以外的服务，或未连接到容器网络的 Docker 容器，请使用 – publish 或-p 标志。 这将创建一个防火墙规则，该规则将容器端口映射到 Docker 主机上的端口。 下面是一些例子。</p><table><thead><tr><th align="center">标志值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">-p 8080:80</td><td align="left">将容器中的 TCP 端口80映射到 Docker 主机上的端口8080</td></tr><tr><td align="center">-p 192.168.1.100:8080:80</td><td align="left">将容器中的 TCP 端口80映射到 Docker 主机上的端口8080，以连接到主机 IP 192.168.1.100</td></tr><tr><td align="center">-p 8080:80/udp</td><td align="left">将容器中的 UDP 端口80映射到 Docker 主机上的8080端口</td></tr><tr><td align="center">-p 8080:80/tcp -p 8080:80/udp</td><td align="left">将容器中的 TCP 端口80映射到 Docker 主机上的 TCP 端口8080，并将容器中的 UDP 端口80映射到 Docker 主机上的 UDP 端口8080</td></tr></tbody></table><h3 id="2-2-IP地址和主机名"><a href="#2-2-IP地址和主机名" class="headerlink" title="2.2 IP地址和主机名"></a>2.2 IP地址和主机名</h3><p>默认情况下，容器为它连接的每个 Docker 网络分配一个 IP 地址。 Ip 地址是从分配给网络的池中分配的，因此 Docker 守护进程有效地充当每个容器的 DHCP 服务器。 每个网络还有一个默认的子网掩码和网关。</p><p>当容器启动时，它只能使用 <code>--network</code> 连接到单个网络。 但是，可以使用 <code>docker network connect</code> 将正在运行的容器连接到多个网络。 当使用 <code>--network</code> 标志启动容器时，可以使用 <code>--ip</code> 或 <code>--ip6</code> 标志指定分配给该网络上的容器的 IP 地址。</p><p>当您使用 <code>docker newwork connect</code>将现有容器连接到另一个网络时，您可以使用该命令上的 <code>--ip</code> 或 <code>--ip6</code> 标志来指定容器在附加网络上的 IP 地址。</p><p>同样，容器的主机名默认为 Docker 中容器的 ID。 您可以使用 <code>--hostname</code> 覆盖主机名。 当使用 <code>docker newwork connect</code> 连接到现有网络时，可以使用 <code>--alias</code> 标志为该网络上的容器指定一个额外的网络别名。</p><h3 id="2-3-DNS服务"><a href="#2-3-DNS服务" class="headerlink" title="2.3 DNS服务"></a>2.3 DNS服务</h3><p>默认情况下，容器继承 Docker 守护进程的 DNS 设置，包括 <code>/etc/hosts</code> 和 <code>/etc/resolv.conf</code>。你可以根据每个容器重写这些设置。</p><table><thead><tr><th align="center">标志值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">–dns</td><td align="left">DNS服务器的IP地址。要指定多个DNS服务器，请使用多个–dns标志。如果容器无法访问您指定的任何IP地址，8.8.8.8则会添加Google的公共DNS服务器，以便您的容器可以解析Internet域。</td></tr><tr><td align="center">–dns-searc</td><td align="left">一个DNS搜索域，用于搜索非完全限定的主机名。要指定多个DNS搜索前缀，请使用多个–dns-search标志。</td></tr><tr><td align="center">–dns-opt</td><td align="left">代表DNS选项及其值的键/值对</td></tr><tr><td align="center">–hostname</td><td align="left">容器本身使用的主机名。如果未指定，则默认为容器的ID。</td></tr></tbody></table><h3 id="2-4-代理服务器"><a href="#2-4-代理服务器" class="headerlink" title="2.4 代理服务器"></a>2.4 代理服务器</h3><p>如果你的容器需要使用 HTTP，HTTPS，或者 FTP 代理服务器，你可以用不同的方式配置它:</p><ul><li><p>在Docker 17.07及更高版本中，您可以 配置Docker客户端以将代理信息自动传递到容器。</p></li><li><p>在Docker 17.06及更低版本中，您必须 在容器内设置适当的环境变量。您可以在构建映像时执行此操作（这会降低映像的可移植性），或者在创建或运行容器时执行此操作</p></li></ul><h4 id="配置-Docker-客户机"><a href="#配置-Docker-客户机" class="headerlink" title="配置 Docker 客户机"></a>配置 Docker 客户机</h4><ol><li><p>在 Docker 客户机上，创建或编辑文件 <code>~/.Docker/config</code>. 在启动容器的用户的主目录中。 添加如下所示的 JSON，必要时用 <code>httpsProxy</code> 或 <code>ftpProxy</code> 替换代理类型，并替换代理服务器的地址和端口。 您可以同时配置多个代理服务器。</p><p>通过将 noProxy 键设置为一个或多个逗号分隔的 IP 地址或主机，可以有选择地排除主机或范围，使其无法通过代理服务器。 支持使用 * 字符作为通配符，如本例所示。</p><pre><code>{ "proxies":     {         "default":         {             "httpProxy": "http://127.0.0.1:3001",             "httpsProxy": "http://127.0.0.1:3001",             "noProxy": "*.test.example.com,.example2.com"         }     } }</code></pre><p>保存文件</p></li><li><p>在创建或启动新容器时，环境变量将在容器中自动设置。</p></li></ol><h4 id="使用环境变量"><a href="#使用环境变量" class="headerlink" title="使用环境变量"></a>使用环境变量</h4><p>在构建映像时，或者在创建或运行容器时使用 <code>--env</code> 标志时，可以将以下一个或多个变量设置为适当的值。 这种方法降低了图像的可移植性，因此如果您使用的是 Docker 17.07或更高版本，则应该配置 Docker 客户机。</p><table><thead><tr><th align="center">变量</th><th align="left">Dockfile示例</th><th align="left">docker run示例</th></tr></thead><tbody><tr><td align="center">HTTP_PROXY</td><td align="left">ENV HTTP_PROXY “<a href="http://127.0.0.1:3001&quot;">http://127.0.0.1:3001"</a></td><td align="left">–env HTTP_PROXY=”<a href="http://127.0.0.1:3001&quot;">http://127.0.0.1:3001"</a></td></tr><tr><td align="center">HTTPS_PROXY</td><td align="left">ENV HTTPS_PROXY “<a href="https://127.0.0.1:3001&quot;">https://127.0.0.1:3001"</a></td><td align="left">–env HTTPS_PROXY=”<a href="https://127.0.0.1:3001&quot;">https://127.0.0.1:3001"</a></td></tr><tr><td align="center">FTP_PROXY</td><td align="left">ENV FTP_PROXY “<a href="ftp://127.0.0.1:3001&quot;">ftp://127.0.0.1:3001"</a></td><td align="left">–env FTP_PROXY=”<a href="ftp://127.0.0.1:3001&quot;">ftp://127.0.0.1:3001"</a></td></tr><tr><td align="center">NO_PROXY</td><td align="left">ENV NO_PROXY “*.test.example.com,.example2.com”</td><td align="left">–env NO_PROXY=”*.test.example.com,.example2.com”</td></tr></tbody></table><h3 id="2-5-启用IPv6支持"><a href="#2-5-启用IPv6支持" class="headerlink" title="2.5 启用IPv6支持"></a>2.5 启用IPv6支持</h3><p>在 Docker 容器或群服务中使用 IPv6之前，需要在 Docker 守护进程中启用 IPv6支持。 之后，您可以选择对任何容器、服务或网络使用 IPv4或 IPv6(或者两者都使用)。</p><blockquote><p><strong>注意: IPv6网络只支持在 Linux 主机上运行的 Docker 守护进程。</strong></p></blockquote><ol><li>编辑 <code>/etc/docker/daemon.json</code> 并将 <code>ipv6</code>键设置为 <code>true</code>。</li></ol><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">{</span>  <span class="token string">"ipv6"</span><span class="token keyword">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>保存文件</p><ol start="2"><li>重新加载 Docker 配置文件。</li></ol><pre class="line-numbers language-bash"><code class="language-bash">$ systemctl reload docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在您可以使用 <code>--ipv6</code> 标志创建网络，并使用 <code>--ip6</code> 标志分配容器的 IPv6 地址。</p><h3 id="2-6-Docker-和-iptables"><a href="#2-6-Docker-和-iptables" class="headerlink" title="2.6 Docker 和 iptables"></a>2.6 Docker 和 iptables</h3><p>在 Linux 上，Docker 操纵 iptables 规则来提供网络隔离。 虽然这是一个实现细节，你不应该修改 Docker 插入到你的 iptables 策略中的规则，但是如果你想在 Docker 管理的策略之外还有自己的策略，它确实会对你需要做的事情产生一些影响。</p><p>如果您正在一个公开到 Internet 的主机上运行 Docker，那么您可能希望将 iptables 策略放在适当的位置，以防止对在您的主机上运行的容器或其他服务的未经授权的访问。 本页描述了如何实现这一点，以及需要注意的事项。</p><h4 id="在-Docker-规则之前添加-iptables-策略"><a href="#在-Docker-规则之前添加-iptables-策略" class="headerlink" title="在 Docker 规则之前添加 iptables 策略"></a>在 Docker 规则之前添加 iptables 策略</h4><p>Docker 安装了两个自定义 iptables 链，分别名为 Docker-user 和 Docker，它确保传入的数据包总是首先由这两个 iptables 链检查。</p><p>Docker 的所有 iptables 规则都添加到 Docker 链中。 不要手动操作此链。 如果需要在 Docker 的规则加载之前添加规则，请将它们添加到 Docker-user 链中。 这些规则在 Docker 自动创建任何规则之前被应用。</p><p>添加到 FORWARD 链中的规则——手动地，或者由另一个基于 iptables 的防火墙——在这些链之后进行评估。 这意味着，如果您通过 Docker 公开一个端口，那么无论您的防火墙配置了什么规则，该端口都会公开。 如果希望即使在通过 Docker 公开端口时也应用这些规则，则必须将这些规则添加到 Docker-user 链中。</p><h5 id="限制与-Docker-主机的连接"><a href="#限制与-Docker-主机的连接" class="headerlink" title="限制与 Docker 主机的连接"></a>限制与 Docker 主机的连接</h5><p>默认情况下，所有外部源 ip 都允许连接到 Docker 主机。 若要只允许特定的 IP 或网络访问容器，请在 DOCKER-USER 过滤器链的顶部插入否定规则。 例如，以下规则限制除192.168.1.1以外的所有 IP 地址的外部访问:</p><pre class="line-numbers language-bash"><code class="language-bash">$ iptables -I DOCKER-USER -i ext_if <span class="token operator">!</span> -s 192.168.1.1 -j DROP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>请注意，如果要符合主机的实际外部接口，则需要更改 ext。 您可以改为允许来自源子网的连接。 以下规则只允许从子网192.168.1.0 / 24访问:</p><pre class="line-numbers language-bash"><code class="language-bash">$ iptables -I DOCKER-USER -i ext_if <span class="token operator">!</span> -s 192.168.1.0/24 -j DROP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后，您可以使用 – src-range 指定一个要接受的 IP 地址范围(记住在使用 – src-range 或 – dst-range 时也要添加-m iprange) :</p><pre class="line-numbers language-bash"><code class="language-bash">$ iptables -I DOCKER-USER -m iprange -i ext_if <span class="token operator">!</span> --src-range 192.168.1.1-192.168.1.3 -j DROP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您可以将-s 或 – src-range 与-d 或 – dst-range 组合起来，以控制源和目标。 例如，如果 Docker 守护进程同时监听192.168.1.99和10.1.2.3，您可以制定特定于10.1.2.3的规则，并保持192.168.1.99处于开放状态。</p><p>Iptables 比较复杂，而且更复杂的规则超出了本主题的范围。 更多信息请参见 netfilter. org HOWTO。</p><h3 id="路由器上的-Docker"><a href="#路由器上的-Docker" class="headerlink" title="路由器上的 Docker"></a>路由器上的 Docker</h3><p>Docker 还为 FORWARD 链设置 DROP 策略。 如果你的 Docker 主机也作为一个路由器，这将导致该路由器不再转发任何流量。 如果您希望您的系统继续发挥路由器的功能，可以向 DOCKER-USER 链添加显式的 ACCEPT 规则以允许它:</p><pre class="line-numbers language-bash"><code class="language-bash">$ iptables -I DOCKER-USER -i src_if -o dst_if -j ACCEPT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="防止-Docker-操纵-iptables"><a href="#防止-Docker-操纵-iptables" class="headerlink" title="防止 Docker 操纵 iptables"></a>防止 Docker 操纵 iptables</h3><p>在 <code>/etc/Docker/daemon.json</code> 的 Docker 引擎配置文件中，可以将 iptables 键设置为 false。 但是这个选项并不适合大多数用户。 完全阻止 Docker 创建 iptables 规则是不可能的，并且在事后创建这些规则非常复杂，超出了本说明的范围。 将 iptables 设置为 false 很可能会破坏 Docker 引擎的容器网络。</p><h3 id="设置容器的默认绑定地址"><a href="#设置容器的默认绑定地址" class="headerlink" title="设置容器的默认绑定地址"></a>设置容器的默认绑定地址</h3><p>默认情况下，Docker 守护进程将在0.0.0.0地址上公开端口，即主机上的任何地址。 如果希望更改该行为以便只公开内部 IP 地址上的端口，可以使用 <code>--ip</code> 选项指定不同的 IP 地址。 但是，设置 <code>--ip</code> 只改变默认值，它不将服务限制在该 IP 上。</p><h2 id="3-禁用容器联网"><a href="#3-禁用容器联网" class="headerlink" title="3. 禁用容器联网"></a>3. 禁用容器联网</h2><p>如果希望完全禁用容器上的网络堆栈，可以在启动容器时使用 <code>--network none</code> 标志。 在容器中，只创建环回设备。 下面的例子说明了这一点。</p><ol><li>创建容器</li></ol><pre class="line-numbers language-bash"><code class="language-bash">$ docker run --rm -dit \  --network none \  --name no-net-alpine \  alpine:latest \  ash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>通过在容器中执行一些常见的网络命令来检查容器的网络堆栈。</li></ol><pre class="line-numbers language-bash"><code class="language-bash">$ docker <span class="token function">exec</span> no-net-alpine ip <span class="token function">link</span> show1: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">></span> mtu 65536 qdisc noqueue state UNKNOWN qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:002: tunl0@NONE: <span class="token operator">&lt;</span>NOARP<span class="token operator">></span> mtu 1480 qdisc noop state DOWN qlen 1    link/ipip 0.0.0.0 brd 0.0.0.03: ip6tnl0@NONE: <span class="token operator">&lt;</span>NOARP<span class="token operator">></span> mtu 1452 qdisc noop state DOWN qlen 1    link/tunnel6 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00 brd 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">$ docker <span class="token function">exec</span> no-net-alpine ip route<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二个命令返回空，因为没有路由表。</p><ol start="3"><li>停止容器。它会自动删除，因为它是用 – rm 标志创建的。</li></ol><pre class="line-numbers language-bash"><code class="language-bash">$ docker container <span class="token function">rm</span> no-net-alpine<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 容器服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 入门系列  2. Docker 核心概念和安装使用</title>
      <link href="/posts/17098.html"/>
      <url>/posts/17098.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、-核心概念：镜像、容器与仓库"><a href="#一、-核心概念：镜像、容器与仓库" class="headerlink" title="一、 核心概念：镜像、容器与仓库"></a>一、 核心概念：镜像、容器与仓库</h2><p>Docker 主要包含三个核心概念，分别是镜像、容器和仓库，理解了这三个概念，就理解了 Docker 的整个生命周期。</p><ul><li><p><strong>镜像：</strong> Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p></li><li><p><strong>容器：</strong> 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间容器可以被。创建、启动、停止、删除和暂停等等，说到镜像与容器之间的关系，可以类比面向对象程序设计中的类和实例。</p></li><li><p><strong>仓库：</strong> 镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。一个 Docker Registry 中可以包含多个仓库；每个仓库可以包含多个标签；每个标签对应一个镜像，其中标签可以理解为镜像的版本号。</p></li></ul><h3 id="1-镜像（Image）-一个特殊的文件系统"><a href="#1-镜像（Image）-一个特殊的文件系统" class="headerlink" title="1. 镜像（Image）- 一个特殊的文件系统"></a>1. 镜像（Image）- 一个特殊的文件系统</h3><p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。</p><p><strong>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</strong> 镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589436136/hexo/docker/docker-filesystems-debian_l2gohi.png" alt="rootfs"></p><p>因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589436395/hexo/docker/docker-filesystems-multilayer_ug4ouk.png" alt="multilayer"></p><blockquote><p>Docker 设计时，就充分利用 Union FS的技术，将其设计为 分层存储的架构 。 镜像实际是由多层文件系统联合组成。</p></blockquote><p><strong>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</strong>比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p><strong>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</strong></p><p><strong>总的来说，你最需要记住这点：</strong></p><blockquote><p>在 Dockerfile 中， 每一条指令都会创建一个镜像层，继而会增加整体镜像的大小。</p></blockquote><p><code>镜像作为 Docker 最突出的创新之一，它变革了软件交付标准。理解镜像，对理解整个 Docker 的生命周期非常重要。</code></p><h3 id="2-容器（Container-镜像运行时的实体"><a href="#2-容器（Container-镜像运行时的实体" class="headerlink" title="2. 容器（Container) - 镜像运行时的实体"></a>2. 容器（Container) - 镜像运行时的实体</h3><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，<strong>容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等</strong> 。</p><p>Docker容器将应用程序和运行所需的所有内容封装到一个黑色沙箱中。这包括操作系统，应用程序代码，运行时，系统工具，系统库等.Docker容器是基于Docker镜像构建的。由于镜像是只读的，因此Docker在镜像的只读文件系统上添加了一个读写文件系统来创建容器。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589438151/hexo/docker/container_run_oaqnl8.png" alt="container"></p><p><strong>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</strong></p><blockquote><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p></blockquote><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据 ，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， 使用数据卷后，容器可以随意删除、重新 run ，数据却不会丢失。</p><h3 id="3-仓库（Repository）-集中存放镜像文件的地方"><a href="#3-仓库（Repository）-集中存放镜像文件的地方" class="headerlink" title="3. 仓库（Repository）- 集中存放镜像文件的地方"></a>3. 仓库（Repository）- 集中存放镜像文件的地方</h3><p><strong>Docker 仓库</strong> 是集中存放镜像文件的场所。镜像构建完成后，可以很容易的在当前宿主上运行，但是， <strong>如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务</strong>。</p><p>一个 <code>Docker Registry</code> 中可以包含多个 <strong>仓库（Repository）</strong>；每个仓库可以包含多个 <strong>标签（Tag）</strong>；每个标签对应一个镜像。所以说：<strong>镜像仓库是Docker用来集中存放镜像文件的地方类似于我们之前常用的代码仓库</strong>。</p><p>通常，<strong>一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本</strong> 。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p><p>仓库又可以分为两种形式：</p><ul><li><strong>public(公有仓库)</strong></li><li><strong>private(私有仓库)</strong></li></ul><h4 id="1-公有仓库"><a href="#1-公有仓库" class="headerlink" title="1) 公有仓库"></a>1) 公有仓库</h4><p><strong>Docker Registry 公开服务</strong> 是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公有仓库是官方的 <strong>Docker Hub</strong> ，这也是默认的 Registry，并拥有大量的高质量的官方镜像，网址为：<a href="https://hub.docker.com" target="_blank" rel="noopener">hub.docker.com</a> 。在国内访问Docker Hub 可能会比较慢国内也有一些云服务商提供类似于 <strong>Docker Hub</strong> 的公开服务。比如 <a href="https://www.163yun.com/product/repo" target="_blank" rel="noopener">网易云镜像服务</a>、<a href="https://www.daocloud.io" target="_blank" rel="noopener">DaoCloud 镜像市场</a>、<a href="https://cr.console.aliyun.com" target="_blank" rel="noopener">阿里云镜像库</a>等。</p><h4 id="2-私有仓库"><a href="#2-私有仓库" class="headerlink" title="2) 私有仓库"></a>2) 私有仓库</h4><p>除了使用公有仓库外，用户还可以在本地搭建<strong>私有仓库 Docker Registry</strong>。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/" target="_blank" rel="noopener">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。</p><p>开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 Docker Trusted Registry 中，提供了这些高级功能。</p><p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，Harbor 和 Sonatype Nexus。</p><h2 id="二、Docker-安装"><a href="#二、Docker-安装" class="headerlink" title="二、Docker 安装"></a>二、Docker 安装</h2><h3 id="1-在macOS系统安装"><a href="#1-在macOS系统安装" class="headerlink" title="1. 在macOS系统安装"></a>1. 在macOS系统安装</h3><h4 id="1-1-使用-Homebrew-安装"><a href="#1-1-使用-Homebrew-安装" class="headerlink" title="1.1 使用 Homebrew 安装"></a>1.1 使用 Homebrew 安装</h4><p>Homebrew 的 Cask 已经支持 Docker Desktop for Mac，因此可以很方便的使用 Homebrew Cask 来进行安装：</p><blockquote><p>安装 <strong>HomeBrew</strong></p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">/bin/bash -c <span class="token string">"<span class="token variable"><span class="token variable">$(</span>curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh<span class="token variable">)</span></span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>安装 <strong>Docker</strong></p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">brew cask <span class="token function">install</span> docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-2-手动下载安装Docker"><a href="#1-2-手动下载安装Docker" class="headerlink" title="1.2 手动下载安装Docker"></a>1.2 手动下载安装Docker</h4><p>如果需要手动下载，请点击以下链接下载 <a href="https://download.docker.com/mac/stable/Docker.dmg" target="_blank" rel="noopener">Stable</a> 或 <a href="https://download.docker.com/mac/edge/Docker.dmg" target="_blank" rel="noopener">Edge</a> 版本的 Docker Desktop for Mac。</p><p>如同 macOS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将那只叫 Moby 的鲸鱼图标拖拽到 Application 文件夹即可（其间需要输入用户密码）。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589441197/hexo/docker/install-mac-dmg_fqqfsl.png" alt="docker dmg"></p><h4 id="1-3-运行Docker桌面服务"><a href="#1-3-运行Docker桌面服务" class="headerlink" title="1.3 运行Docker桌面服务"></a>1.3 运行Docker桌面服务</h4><p>从应用中找到 Docker 图标并点击运行。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589441564/hexo/docker/docker_re2pia.png" alt="docker run"></p><p>运行之后，会在右上角菜单栏看到多了一个鲸鱼图标，这个图标表明了 Docker 的运行状态。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589441905/hexo/docker/dock_tray_oqtgo9.png" alt="docker tray"></p><p>点击鲸鱼图标会弹出操作菜单</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589442071/hexo/docker/docker_menu_vj0sul.png" alt="docker menu"></p><p>启动终端后，通过命令可以检查安装后的 Docker 版本。</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker --versionDocker version 19.03.8, build afacb8b~ via ⬢ v12.16.3➜ docker-compose --versiondocker-compose version 1.25.5, build 8a1c60f6~ via ⬢ v12.16.3➜ kubectl versionClient Version: version.Info<span class="token punctuation">{</span>Major:<span class="token string">"1"</span>, Minor:<span class="token string">"16+"</span>, GitVersion:<span class="token string">"v1.16.6-beta.0"</span>, GitCommit:<span class="token string">"e7f962ba86f4ce7033828210ca3556393c377bcc"</span>, GitTreeState:<span class="token string">"clean"</span>, BuildDate:<span class="token string">"2020-01-15T08:26:26Z"</span>, GoVersion:<span class="token string">"go1.13.5"</span>, Compiler:<span class="token string">"gc"</span>, Platform:<span class="token string">"darwin/amd64"</span><span class="token punctuation">}</span>The connection to the server localhost:8080 was refused - did you specify the right host or port?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过鲸鱼图标弹出菜单的 About Docker Desktop </p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589442398/hexo/docker/version_etpeqx.png" alt="docker version"></p><h4 id="1-4-镜像加速"><a href="#1-4-镜像加速" class="headerlink" title="1.4 镜像加速"></a>1.4 镜像加速</h4><p>当然了，由于某些原因，国内从 Docker Hub 上拉取内容会非常缓慢，这个时候就可以配置一个镜像加速器环境。详情说明可以移步Docker 中国官方镜像加速，对于 macOS 用户，在任务栏点击应用图标 -&gt; Perferences… -&gt; Docker Engine -&gt; configuration file，在文件中填写加速器地址 <a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a> 即可。修改完成之后，点击 Apply &amp; Restart 即可。</p><p>国内很多云服务商都提供了国内加速器服务，例如：</p><ul><li>网易云加速器 <a href="https://hub-mirror.c.163.com" target="_blank" rel="noopener">https://hub-mirror.c.163.com</a></li><li>百度云加速器 <a href="https://mirror.baidubce.com" target="_blank" rel="noopener">https://mirror.baidubce.com</a></li><li>阿里云加速器 <a href="https://kfwkfulq.mirror.aliyuncs.com" target="_blank" rel="noopener">https://kfwkfulq.mirror.aliyuncs.com</a></li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token string">"registry-mirrors"</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token string">"https://registry.docker-cn.com"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589449037/hexo/docker/mirrors_umiscp.png" alt="mirrors"></p><h2 id="三、-镜像使用"><a href="#三、-镜像使用" class="headerlink" title="三、 镜像使用"></a>三、 镜像使用</h2><p>Docker 使用 C/S 结构，即客户端/服务器体系结构。 Docker 客户端与 Docker 服务器进行交互，Docker服务端负责构建、运行和分发 Docker 镜像。 Docker 客户端和服务端可以运行在一台机器上，也可以通过 RESTful 、 stock 或网络接口与远程 Docker 服务端进行通信。</p><blockquote><p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p></blockquote><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589457087/hexo/docker/Docker-service_dqbfjj.jpg" alt="docker"></p><p><strong>这张图展示了 Docker 客户端、服务端和 Docker 仓库（即 Docker Hub 和 Docker Cloud ），默认情况下Docker 会在 Docker 中央仓库寻找镜像文件，这种利用仓库管理镜像的设计理念类似于 Git ，当然这个仓库是可以通过修改配置来指定的，甚至我们可以创建我们自己的私有仓库。</strong></p><h3 id="1-Docker的简单运用—ubuntu-18-04"><a href="#1-Docker的简单运用—ubuntu-18-04" class="headerlink" title="1. Docker的简单运用—ubuntu:18.04"></a>1. Docker的简单运用—ubuntu:18.04</h3><h4 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1) 获取镜像"></a>1) 获取镜像</h4><p>之前提到过，Docker Hub 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p><p>从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为：</p><pre class="line-numbers language-bash"><code class="language-bash">docker pull <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>Docker Registry 地址<span class="token punctuation">[</span>:端口号<span class="token punctuation">]</span>/<span class="token punctuation">]</span>仓库名<span class="token punctuation">[</span>:标签<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>具体的选项可以通过 docker pull –help 命令看到，这里我们说一下镜像名称的格式。</p><ul><li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub。</li><li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li></ul><p>直接运行下面的命令，将名为 <code>ubuntu:18.04</code> 的 image 文件从仓库抓取到本地</p><pre class="line-numbers language-bash"><code class="language-bash">docker pull ubuntu:18.04<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。</p><blockquote><p>运行结果如下</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">➜ docker pull ubuntu:18.0418.04: Pulling from library/ubuntu23884877105a: Pull completebc38caa0f5b9: Pull complete2910811b6c42: Pull complete36505266dcc6: Pull completeDigest: sha256:3235326357dfb65f1781dbc4df3b834546d8bf914e82cce58e6e6b676e23ce8fStatus: Downloaded newer image <span class="token keyword">for</span> ubuntu:18.04docker.io/library/ubuntu:18.04<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 sha256 的摘要，以确保下载一致性。</p><h4 id="2-列出镜像"><a href="#2-列出镜像" class="headerlink" title="2) 列出镜像"></a>2) 列出镜像</h4><p>要想列出已经下载下来的镜像，可以使用 docker image ls 命令。</p><pre class="line-numbers language-bash"><code class="language-bash">docker image <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>运行结果如下</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">➜ docker image <span class="token function">ls</span> -aREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               c3c304cb4f22        2 weeks ago         64.2MBhello-world         latest              bf756fb1ae65        4 months ago        13.3kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p><p>其中仓库名、标签在之前的基础概念章节已经介绍过了。<strong><code>镜像 ID</code></strong> 则是镜像的唯一标识，一个镜像可以对应多个 标签。因此，在上面的例子中，我们可以看到 ubuntu:18.04 和 ubuntu:latest 拥有相同的 ID，因为它们对应的是同一个镜像。</p><h4 id="3-运行镜像"><a href="#3-运行镜像" class="headerlink" title="3) 运行镜像"></a>3) 运行镜像</h4><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 ubuntu:18.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。</p><p>执行以下命令 运行镜像</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -it --rm ubuntu:18.04 <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>运行结果如下</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">➜ docker run -it --rm ubuntu:18.04 <span class="token function">bash</span>root@3a5e608746e1:/<span class="token comment" spellcheck="true"># cat /etc/os-release</span>NAME<span class="token operator">=</span><span class="token string">"Ubuntu"</span>VERSION<span class="token operator">=</span><span class="token string">"18.04.4 LTS (Bionic Beaver)"</span>ID<span class="token operator">=</span>ubuntuID_LIKE<span class="token operator">=</span>debianPRETTY_NAME<span class="token operator">=</span><span class="token string">"Ubuntu 18.04.4 LTS"</span>VERSION_ID<span class="token operator">=</span><span class="token string">"18.04"</span>HOME_URL<span class="token operator">=</span><span class="token string">"https://www.ubuntu.com/"</span>SUPPORT_URL<span class="token operator">=</span><span class="token string">"https://help.ubuntu.com/"</span>BUG_REPORT_URL<span class="token operator">=</span><span class="token string">"https://bugs.launchpad.net/ubuntu/"</span>PRIVACY_POLICY_URL<span class="token operator">=</span><span class="token string">"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"</span>VERSION_CODENAME<span class="token operator">=</span>bionicUBUNTU_CODENAME<span class="token operator">=</span>bionicroot@3a5e608746e1:/<span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>docker run</code> 就是运行容器的命令，我们这里简要的说明一下上面用到的参数。</p><ul><li>-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li>–rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。</li><li>ubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。</li><li>bash：放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash。</li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <strong>Ubuntu 18.04.1 LTS</strong> 系统。</p><p>最后我们通过 exit 退出了这个容器。</p><h4 id="4-删除本地镜像"><a href="#4-删除本地镜像" class="headerlink" title="4) 删除本地镜像"></a>4) 删除本地镜像</h4><p>如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为：</p><pre class="line-numbers language-bash"><code class="language-bash">docker image <span class="token function">rm</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token operator">&lt;</span>镜像1<span class="token operator">></span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>镜像2<span class="token operator">></span> <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用 ID、镜像名、摘要删除镜像</p><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p><p>比如我们有下列镜像：</p><pre class="line-numbers language-bash"><code class="language-bash">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               c3c304cb4f22        2 weeks ago         64.2MBhello-world         latest              bf756fb1ae65        4 months ago        13.3kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用<code>长 ID</code>，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除 ubuntu 镜像，可以执行：</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker image <span class="token function">rm</span> c3c304cb4f22Untagged: ubuntu:18.04Untagged: ubuntu@sha256:3235326357dfb65f1781dbc4df3b834546d8bf914e82cce58e6e6b676e23ce8fDeleted: sha256:c3c304cb4f22ceb8a6fcc29a0cd6d3e4383ba9eb9b5fb552f87de7c0ba99edacDeleted: sha256:82751c4dcc36265daceeee0abd938806b591eb66700863186377348c96e8aeadDeleted: sha256:24b16cac34768092d57cdb429a12de6c9ee870a3724d70098a189ae0ac344c42Deleted: sha256:b1daff3b271fede2bec31812c398e28952f792935f608e467271cdfaccab7de2Deleted: sha256:b7f7d2967507ba709dbd1dd0426a5b0cdbe1ff936c131f8958c8d0f910eea19e<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们也可以用镜像名，也就是 &lt;仓库名&gt;:&lt;标签&gt;，来删除镜像。</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker image <span class="token function">rm</span> ubuntu:18.04Untagged: ubuntu:18.04Untagged: ubuntu@sha256:3235326357dfb65f1781dbc4df3b834546d8bf914e82cce58e6e6b676e23ce8fDeleted: sha256:c3c304cb4f22ceb8a6fcc29a0cd6d3e4383ba9eb9b5fb552f87de7c0ba99edacDeleted: sha256:82751c4dcc36265daceeee0abd938806b591eb66700863186377348c96e8aeadDeleted: sha256:24b16cac34768092d57cdb429a12de6c9ee870a3724d70098a189ae0ac344c42Deleted: sha256:b1daff3b271fede2bec31812c398e28952f792935f608e467271cdfaccab7de2Deleted: sha256:b7f7d2967507ba709dbd1dd0426a5b0cdbe1ff936c131f8958c8d0f910eea19e<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，更精确的是使用 镜像摘要 删除镜像。</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker image <span class="token function">ls</span> --digestsREPOSITORY          TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZEhello-world         latest              sha256:6a65f928fb91fcfbc963f7aa6d57c8eeb426ad9a20c7ee045538ef34847f44f1   bf756fb1ae65        4 months ago        13.3kB➜ docker image <span class="token function">rm</span> hello-world:latest@sha256:6a65f928fb91fcfbc963f7aa6d57c8eeb426ad9a20c7ee045538ef34847f44f1Untagged: hello-world:latest@sha256:6a65f928fb91fcfbc963f7aa6d57c8eeb426ad9a20c7ee045538ef34847f44f1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、操作容器"><a href="#四、操作容器" class="headerlink" title="四、操作容器"></a>四、操作容器</h2><h3 id="1-查看容器"><a href="#1-查看容器" class="headerlink" title="1. 查看容器"></a>1. 查看容器</h3><p>我们要想知道当前有哪些容器在运行，我们可以用如下命令：<br><strong>docker ps -a</strong> <code>-a</code> 是查看当前所有正在运行的容器</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">ps</span> -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>运行结果如下</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES45448b240593        hello-world         <span class="token string">"/hello"</span>            9 minutes ago       Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 9 minutes ago                       keen_pasteur<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-启动容器"><a href="#2-启动容器" class="headerlink" title="2. 启动容器"></a>2. 启动容器</h3><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p><h4 id="2-1-新建并启动"><a href="#2-1-新建并启动" class="headerlink" title="2.1 新建并启动"></a>2.1 新建并启动</h4><p>所需要的命令主要为 docker run。</p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker run ubuntu:18.04 /bin/echo <span class="token string">'Hello world'</span>Hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这跟在本地直接执行 /bin/echo ‘hello world’ 几乎感觉不出任何区别。</p><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker run -t -i ubuntu:18.04 /bin/bashroot@c0a95c27382a:/<span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。<br>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker run -t -i ubuntu:18.04 /bin/bashroot@c0a95c27382a:/<span class="token comment" spellcheck="true"># pwd</span>/root@c0a95c27382a:/<span class="token comment" spellcheck="true"># ls</span>bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  varroot@c0a95c27382a:/<span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h4 id="2-2-启动已终止容器"><a href="#2-2-启动已终止容器" class="headerlink" title="2.2 启动已终止容器"></a>2.2 启动已终止容器</h4><p>可以利用 docker container start 命令，直接将一个已经终止的容器启动运行。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 ps 或 top 来查看进程信息。</p><pre class="line-numbers language-bash"><code class="language-bash">root@b0f1a106dcdf:/<span class="token comment" spellcheck="true"># ps</span>  PID TTY          TIME CMD    1 pts/0    00:00:00 <span class="token function">bash</span>   11 pts/0    00:00:00 <span class="token function">ps</span>root@b0f1a106dcdf:/<span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><h3 id="3-守护态运行"><a href="#3-守护态运行" class="headerlink" title="3. 守护态运行"></a>3. 守护态运行</h3><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker run ubuntu:18.04 /bin/sh -c <span class="token string">"while true; do echo hello world; sleep 1; done"</span>hello worldhello worldhello worldhello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p><p>如果使用了 -d 参数运行容器。</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker run -d ubuntu:18.04 /bin/sh -c <span class="token string">"while true; do echo hello world; sleep 1; done"</span>f8849adf1f3ce58981c95142abc65729da41b3b5a4e89edb2d0a8c5ac967f171~ via ⬢ v12.16.3➜<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 docker logs 查看)。</p><p><strong>注： 容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。</strong></p><p>使用 -d 参数启动后会返回一个唯一的 id，也可以通过 docker container ls 命令来查看容器信息。</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker container <span class="token function">ls</span>CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS               NAMESf8849adf1f3c        ubuntu:18.04        <span class="token string">"/bin/sh -c 'while t…"</span>   About a minute ago   Up About a minute                       funny_matsumotoc0a95c27382a        ubuntu:18.04        <span class="token string">"/bin/bash"</span>              9 minutes ago        Up 4 minutes                            musing_margulis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>要获取容器的输出信息，可以通过 docker container logs 命令。</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker container logs f8849adf1f3chello worldhello worldhello worldhello worldhello worldhello world<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-终止容器"><a href="#4-终止容器" class="headerlink" title="4. 终止容器"></a>4. 终止容器</h3><p>可以使用 docker container stop 来终止一个运行中的容器。</p><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p><p>例如对于上一章节中只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。</p><p>终止状态的容器可以用 docker container ls -a 命令看到。例如</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker container <span class="token function">ls</span> -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMESf8849adf1f3c        ubuntu:18.04        <span class="token string">"/bin/sh -c 'while t…"</span>   4 minutes ago       Up 4 minutes                                    funny_matsumoto208d3180e5ca        ubuntu:18.04        <span class="token string">"/bin/sh -c 'while t…"</span>   5 minutes ago       Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 5 minutes ago                        hardcore_dubinskyb0f1a106dcdf        ubuntu:18.04        <span class="token string">"/bin/bash"</span>              7 minutes ago       Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 5 minutes ago                        naughty_lumierec0a95c27382a        ubuntu:18.04        <span class="token string">"/bin/bash"</span>              12 minutes ago      Up 8 minutes                                    musing_margulis1b10a73accd8        ubuntu:18.04        <span class="token string">"/bin/echo 'Hello wo…"</span>   13 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 8 minutes ago                        eager_napier37c02b640650        ubuntu:18.04        <span class="token string">"/bin/echo 'Hello wo…"</span>   13 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 13 minutes ago                       confident_leavitt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>处于终止状态的容器，可以通过 docker container start 命令来重新启动。</p><p>此外，docker container restart 命令会将一个运行态的容器终止，然后再重新启动它。</p><h3 id="5-进入容器"><a href="#5-进入容器" class="headerlink" title="5. 进入容器"></a>5. 进入容器</h3><p>在使用 -d 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令，原因会在下面说明。</p><h4 id="5-1-attach-命令"><a href="#5-1-attach-命令" class="headerlink" title="5.1 attach 命令"></a>5.1 attach 命令</h4><p>下面示例如何使用 docker attach 命令。</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker run -dit ubuntudd8d472bb3b30ba6ab4a230d5734a97c61d0205d8d09ac080c88d3ace0a2fffd~ via ⬢ v12.16.3➜ docker container <span class="token function">ls</span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESdd8d472bb3b3        ubuntu              <span class="token string">"/bin/bash"</span>         7 seconds ago       Up 6 seconds                            optimistic_pasteur~ via ⬢ v12.16.3➜ docker attach dd8d472bb3b3root@dd8d472bb3b3:/<span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意： 如果从这个 stdin 中 exit，会导致容器的停止。</p><h4 id="5-2-exec-命令"><a href="#5-2-exec-命令" class="headerlink" title="5.2 exec 命令"></a>5.2 exec 命令</h4><p>docker exec 后边可以跟多个参数，这里主要说明 -i -t 参数。</p><p>只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker run -dit ubuntuc9ca08210d46abaee7228c4541f164908063cbd681c4aa541fe4e060da532d45~ via ⬢ v12.16.3➜ docker container <span class="token function">ls</span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESc9ca08210d46        ubuntu              <span class="token string">"/bin/bash"</span>         6 seconds ago       Up 6 seconds                            pedantic_albattani~ via ⬢ v12.16.3➜ docker <span class="token function">exec</span> -i c9ca <span class="token function">bash</span><span class="token function">ls</span>binbootdevetchomeliblib32lib64libx32mediamntoptprocrootrunsbinsrvsystmpusrvar^C~ via ⬢ v12.16.3 took 41s➜ docker <span class="token function">exec</span> -it c9ca <span class="token function">bash</span>root@c9ca08210d46:/<span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 docker exec 的原因。</p><h3 id="6-容器的导出和导入"><a href="#6-容器的导出和导入" class="headerlink" title="6. 容器的导出和导入"></a>6. 容器的导出和导入</h3><h4 id="6-1-导出容器"><a href="#6-1-导出容器" class="headerlink" title="6.1 导出容器"></a>6.1 导出容器</h4><p>如果要导出本地某个容器，可以使用 docker export 命令。</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker <span class="token function">ps</span> -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                       PORTS               NAMESc9ca08210d46        ubuntu              <span class="token string">"/bin/bash"</span>              5 minutes ago       Up 5 minutes                                     pedantic_albattanidd8d472bb3b3        ubuntu              <span class="token string">"/bin/bash"</span>              8 minutes ago       Exited <span class="token punctuation">(</span>127<span class="token punctuation">)</span> 6 minutes ago                       optimistic_pasteur208d3180e5ca        ubuntu:18.04        <span class="token string">"/bin/sh -c 'while t…"</span>   17 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 17 minutes ago                        hardcore_dubinskyb0f1a106dcdf        ubuntu:18.04        <span class="token string">"/bin/bash"</span>              19 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 17 minutes ago                        naughty_lumiere1b10a73accd8        ubuntu:18.04        <span class="token string">"/bin/echo 'Hello wo…"</span>   26 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 20 minutes ago                        eager_napier37c02b640650        ubuntu:18.04        <span class="token string">"/bin/echo 'Hello wo…"</span>   26 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 26 minutes ago                        confident_leavitt~ via ⬢ v12.16.3➜ docker <span class="token function">export</span> 37c02b640650 <span class="token operator">></span> ubuntu.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样将导出容器快照到本地文件。</p><h4 id="6-1-导入容器"><a href="#6-1-导入容器" class="headerlink" title="6.1 导入容器"></a>6.1 导入容器</h4><p>可以使用 docker import 从容器快照文件中再导入为镜像，例如</p><pre class="line-numbers language-bash"><code class="language-bash">➜ <span class="token function">cat</span> ubuntu.tar <span class="token operator">|</span> docker <span class="token function">import</span> - test/ubuntu:v1.0sha256:d21f5263937d78928f78d3c76268783e930a989255fbc5db09453deabd45c537~ via ⬢ v12.16.3 took 2s➜ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEtest/ubuntu         v1.0                d21f5263937d        9 seconds ago       64.2MBubuntu              latest              1d622ef86b13        2 weeks ago         73.9MBubuntu              18.04               c3c304cb4f22        2 weeks ago         64.2MBhello-world         latest              bf756fb1ae65        4 months ago        13.3kB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><pre class="line-numbers language-bash"><code class="language-bash">docker <span class="token function">import</span> http://example.com/exampleimage.tgz example/imagerepo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p><h3 id="6-删除容器"><a href="#6-删除容器" class="headerlink" title="6. 删除容器"></a>6. 删除容器</h3><h4 id="6-1-删除容器"><a href="#6-1-删除容器" class="headerlink" title="6.1 删除容器"></a>6.1 删除容器</h4><p>可以使用 docker container rm 来删除一个处于终止状态的容器。例如</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker <span class="token function">ps</span> -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                        PORTS               NAMESc9ca08210d46        ubuntu              <span class="token string">"/bin/bash"</span>              10 minutes ago      Up 10 minutes                                     pedantic_albattanidd8d472bb3b3        ubuntu              <span class="token string">"/bin/bash"</span>              12 minutes ago      Exited <span class="token punctuation">(</span>127<span class="token punctuation">)</span> 10 minutes ago                       optimistic_pasteur208d3180e5ca        ubuntu:18.04        <span class="token string">"/bin/sh -c 'while t…"</span>   22 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 21 minutes ago                         hardcore_dubinskyb0f1a106dcdf        ubuntu:18.04        <span class="token string">"/bin/bash"</span>              24 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 22 minutes ago                         naughty_lumiere1b10a73accd8        ubuntu:18.04        <span class="token string">"/bin/echo 'Hello wo…"</span>   30 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 24 minutes ago                         eager_napier37c02b640650        ubuntu:18.04        <span class="token string">"/bin/echo 'Hello wo…"</span>   30 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 30 minutes ago                         confident_leavitt~ via ⬢ v12.16.3➜ docker container <span class="token function">rm</span> 37c02b64065037c02b640650<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</p><h4 id="6-2-清理所有处于终止状态的容器"><a href="#6-2-清理所有处于终止状态的容器" class="headerlink" title="6.2 清理所有处于终止状态的容器"></a>6.2 清理所有处于终止状态的容器</h4><p>用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker <span class="token function">ps</span> -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                        PORTS               NAMESc9ca08210d46        ubuntu              <span class="token string">"/bin/bash"</span>              12 minutes ago      Up 12 minutes                                     pedantic_albattanidd8d472bb3b3        ubuntu              <span class="token string">"/bin/bash"</span>              14 minutes ago      Exited <span class="token punctuation">(</span>127<span class="token punctuation">)</span> 12 minutes ago                       optimistic_pasteur208d3180e5ca        ubuntu:18.04        <span class="token string">"/bin/sh -c 'while t…"</span>   23 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 23 minutes ago                         hardcore_dubinskyb0f1a106dcdf        ubuntu:18.04        <span class="token string">"/bin/bash"</span>              25 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 23 minutes ago                         naughty_lumiere1b10a73accd8        ubuntu:18.04        <span class="token string">"/bin/echo 'Hello wo…"</span>   32 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 26 minutes ago                         eager_napier~ via ⬢ v12.16.3➜ docker container pruneWARNING<span class="token operator">!</span> This will remove all stopped containers.Are you sure you want to continue? <span class="token punctuation">[</span>y/N<span class="token punctuation">]</span> yDeleted Containers:dd8d472bb3b30ba6ab4a230d5734a97c61d0205d8d09ac080c88d3ace0a2fffd208d3180e5cac70cff44d499951138c968f15921d6e1fcdf1756f8d3c74e890fb0f1a106dcdf1773985fb601f2292683ed825d483675e695eb2cebd9c26b6e4e1b10a73accd84fc078433165ce7fa7527509bd3d2c1c2a33172bc64b98b41944Total reclaimed space: 74B~ via ⬢ v12.16.3 took 3s➜ docker <span class="token function">ps</span> -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESc9ca08210d46        ubuntu              <span class="token string">"/bin/bash"</span>         12 minutes ago      Up 12 minutes                           pedantic_albattani<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 容器服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 入门系列 1. Docker 简介</title>
      <link href="/posts/26481.html"/>
      <url>/posts/26481.html</url>
      
        <content type="html"><![CDATA[<p>  本系列笔记是作为一个新手小白，从了解 Docker 是什么、Docker 技术包含哪些概念到上手使用、安装以及发布 Docker 镜像的整个过程。小白在学习过程中遵循简介、入门、上手到深入的顺序，根据个人学习实践过程进行书写与记录。</p><h2 id="一、-Docker-简介"><a href="#一、-Docker-简介" class="headerlink" title="一、 Docker 简介"></a>一、 Docker 简介</h2><p>  Docker是DotCloud开源的、可以将任何应用包装在Linux container中运行的工具。Docker是供开发人员和系统管理员：使用容器构建，运行和共享应用程序的平台。使用容器来部署应用程序称为容器化。容器不是新的技术，但用于轻松部署应用程序的Docker却是新的未来。</p><h3 id="1-容器的概念"><a href="#1-容器的概念" class="headerlink" title="1. 容器的概念"></a>1. 容器的概念</h3><p>  <strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。而 Linux 容器是 Linux 发展出了另一种虚拟化技术，简单来讲， Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离，相当于是在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p><p>  <strong><code>Docker</code> 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个<code>虚拟容器</code>里运行，就好像在真实的物理机上运行一样。有了 <code>Docker</code> ，就不用担心环境问题。</strong></p><p>  <code>Docker</code> 利用 Linux 核心中的资源分脱机制，例如 <code>cgroups</code>，以及 Linux 核心名字空间（name space），来创建独立的软件容器（<code>containers</code>），属于<strong>操作系统层面的虚拟化</strong>技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。<code>Docker</code> 在容器的基础上进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护，使得其比虚拟机技术更为轻便、快捷。<code>Docker</code> 可以在单一 Linux 实体下运作，避免因为创建一个虚拟机而造成的额外负担。</p><p>容器化越来越受欢迎，因为容器具有一下有点:</p><blockquote><ul><li>灵活：即使最复杂的也可以容器化。</li><li>轻量级：容器利用并共享主机内核，在系统资源方面比虚拟机效率更高。</li><li>可移植性：您可以在本地构建，部署到云并在任何地方运行。</li><li>松散耦合：容器是高度自给自足并封装的容器，使您可以在不破坏其他容器的情况下更换或升级它们。</li><li>可扩展：您可以在数据中心内增加并自动分布容器副本。</li><li>安全：容器将积极的约束和隔离应用于流程，而无需用户方面的任何配置。</li></ul></blockquote><h3 id="2-容器和虚拟机"><a href="#2-容器和虚拟机" class="headerlink" title="2. 容器和虚拟机"></a>2. 容器和虚拟机</h3><p>容器在Linux上本地运行，并与其他容器共享主机的内核。它运行一个离散进程，不占用任何其他可执行文件更多的内存，从而使其轻巧。由于容器是进程级别的，相比虚拟机有很多优势</p><p>相比之下，虚拟机（VM）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。并通过虚拟机管理程序对主机资源进行虚拟访问。通常，VM会产生大量开销，超出了应用程序逻辑所消耗的开销。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589358055/hexo/Container_kgmlbw.png" alt="容器技术"></td><td><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589358057/hexo/VM_ioupe2.png" alt="虚拟机"></td></tr></tbody></table><h4 id="1-容器技术"><a href="#1-容器技术" class="headerlink" title="1) 容器技术"></a>1) 容器技术</h4><p>容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。容器内没有自己的内核，也没有进行硬件虚拟。</p><h4 id="2-虚拟机"><a href="#2-虚拟机" class="headerlink" title="2) 虚拟机"></a>2) 虚拟机</h4><p>对于虚拟机技术来说，传统虚拟机如 VMware ， VisualBox 之类的需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。</p><blockquote><p>容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。通过使用容器，我们可以轻松打包应用程序的代码、配置和依赖关系，将其变成容易使用的构建块，从而实现环境一致性、运营效率、开发人员生产力和版本控制等诸多目标。容器可以帮助保证应用程序快速、可靠、一致地部署，其间不受部署环境的影响。容器还赋予我们对资源更多的精细化控制能力，让我们的基础设施效率更高。通过上面这幅图我们可以很直观的反映出这两者的区别所在。</p></blockquote><p><strong>具体来说与虚拟机技术对比，Docker 容器存在以下几个特点：</strong></p><p>  <strong>1. 更快的启动速度：</strong> 因为 Docker 直接运行于宿主内核，无需启动完整的操作系统，因此启动速度属于秒级别，而虚拟机通常需要几分钟去启动。</p><p>  <strong>2. 更高效的资源利用率：</strong>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。</p><p>  <strong>3. 更高的系统支持量：</strong>Docker 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境，Docker 运行的镜像数远多于虚拟机数量，对系统的利用率非常高。</p><p>  <strong>4. 持续交付与部署：</strong>对开发和运维人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至进行自动部署。</p><p>  <strong>5. 更轻松的迁移：</strong>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><p>  <strong>6. 更轻松的维护与扩展：</strong>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><p>  <strong>7. 更弱的隔离性：</strong>Docker 属于进程之间的隔离，虚拟机可实现系统级别隔离。</p><p>  <strong>8. 更弱的安全性：</strong>Docker 的租户 root 和宿主机 root 等同，一旦容器内的用户从普通用户权限提升为 root 权限，它就直接具备了宿主机的 root 权限，进而可进行无限制的操作。虚拟机租户 root 权限和宿主机的 root 虚拟机权限是分离的，并且利用硬件隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击。</p><h3 id="3-Docker的用途"><a href="#3-Docker的用途" class="headerlink" title="3. Docker的用途"></a>3. Docker的用途</h3><p>  <code>Docker</code> 的主要用途，目前有三大类。</p><p>  （1）提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p><p>  （2）提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p><p>  （3）组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p><h3 id="4-容器编排"><a href="#4-容器编排" class="headerlink" title="4. 容器编排"></a>4. 容器编排</h3><p><code>Docker</code>平台以及周边生态系统包含很多工具来管理容器的生命周期。<br>  例如，<strong>Docker Command Line Interface(CLI)支持下面的容器活动:</strong></p><p>   - 从注册表中拉取仓库。<br>   - 运行容器并可选的附加一个终端给它。<br>   - 将容器提交新镜像。<br>   - 上传镜像到注册中心。<br>   - 终止运行中的容器。</p><p><strong>Docker Command Line Interface(CLI) 满足在单个主机上管理容器的需求，但是面对部署在多个主机上的容器时就无所适从了。为了超越单个容器管理，我们必须转向编排工具。<code>容器编排工具</code>将生命周期管理能力扩展到部署在大量机器集群上部署的复杂的、多容器工作负载。通过抽象主机基础结构， 编排工具允许用户将整个集群视为单个部署目标。</strong></p><blockquote><p><strong>容器编排工具</strong> 提供调度和集群的技术，提供用于基于容器应用可扩展性的基本机制。这些工具使用容器服务，并编排他们以决定容器之间如何进行交互。此外，编排允许容器可以存在并执行在集群上，这使得他们能够扩展来适应增加的处理负荷。</p></blockquote><p>  典型的容器编排工具有助于虚拟化一组机器并将它们作为单个集群管理。容器编排工具也有助于将机器上的工作负载或容器移动到消费者透明的位置。很多工具目前既支持基于DOCKER的容器，也支持非容器化二进制文件部署，例如独立的Spring Boot应用程序。这些容器编排工具的基本功能是从应用程序中抽象出实际的服务器实例。</p><blockquote><p><strong>容器编排工具</strong> 为开发人员和基础设施团队提供了一个抽象层来处理大规模的容器化部署。<code>容器编排工具</code>提供的特征在众多提供者之间有所不同，然而常见的公共特征包含准备、发现、资源管理、监视和部署。</p></blockquote><p><strong>容器编排工具的一些关键能力概括如下：</strong></p><ul><li><strong>集群管理：</strong>将虚拟机和物理机器的集群管理为一台大型机器。这些机器在资源能力方面可能有些差异，但大体上都是以Linux作为操作系统的机器。这些虚拟集群可以建立在云上、本地或两者的混合。</li><li><strong>部署：</strong>能处理有大量机器的应用程序和容器的自动部署。支持多个版本的应用程序容器，并且还支持跨越大量集群机器的滚动升级。这些工具还能够处理故障回滚。</li><li><strong>可伸缩性：</strong>支持应用实例的自动和手动伸缩，以性能优化为主要目标。</li><li><strong>健康：</strong>它管理集群、节点和应用程序的健康。可以从集群中移除异常的机器和应用程序实例。</li><li><strong>基础结构抽象化：</strong>开发人员不必担心机器、容量等问题。完全是容器编排工具来决定如何调度和运行应用程序。这些工具也抽象化机器的细节、能力、使用和位置。对于应用程序所有者来说，它们相当于一个容量几乎无限的大型机器。</li><li><strong>资源优化：</strong>这些工具以有效的方式在一组可用机器上分配容器工作负载，从而降低成本，通过从简单的到复杂的算法可有效地提高利用率。</li><li><strong>资源分配：</strong>基于应用程序开发人员设置的资源可用性和约束来分配服务器。资源分配将基于约束、规则、端口要求、应用依赖性、健康等等。</li><li><strong>服务可用性：</strong>确保服务在集群中正常运行。在机器故障的情况下，容器编排会自动通过在集群中的其他机器上重新启动这些服务来处理故障。</li><li><strong>敏捷性：</strong>敏捷性工具能够快速分配工作负载到可用资源，或者在资源需求发生变化时跨机器移动工作量。此外，可以根据业务临界性、业务优先级等来设置约束重新调整资源。</li><li><strong>隔离：</strong>一些工具提供了资源隔离。因此，即使应用程序不是容器化的，也可以实现资源隔离。</li></ul><h3 id="5-编排工具"><a href="#5-编排工具" class="headerlink" title="5. 编排工具"></a>5. 编排工具</h3><h4 id="1-Kubernetes"><a href="#1-Kubernetes" class="headerlink" title="1) Kubernetes"></a>1) Kubernetes</h4><p>  Kubernetes是一个开源的，开箱即用的容器集群管理器和业务流程。它具有出色的构建 调度器 和资源管理器，用于以更有效和高度可用的方式部署容器。Kubernetes已成为许多组织事实上的容器编排工具。kubernetes项目由google与世界各地的贡献者维护。它提供了本机Docker工具不提供的许多功能。而且，使用kubernetes很容易上手。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589374109/hexo/kubernetes_yxk3g7.jpg" alt="Kubernetes"></p><h4 id="2-OpenShift"><a href="#2-OpenShift" class="headerlink" title="2) OpenShift"></a>2) OpenShift</h4><p>  Openshift建立在kubernetes之上。Openshift项目由Redhat维护。它同时具有开源（openshift orgin）和企业版（openshift容器平台）。连同核心的Kubernetes功能，它提供了用于容器管理和编排的开箱即用组件。<br><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589374123/hexo/OpenShift_rfa8hh.jpg" alt="OpenShift"></p><h4 id="3-Docker-Swarm"><a href="#3-Docker-Swarm" class="headerlink" title="3) Docker Swarm"></a>3) Docker Swarm</h4><p>  Docker生态系统包括从开发到生产部署框架的工具。在该列表中，docker swarm适用于集群管理。可以使用docker-compose，swarm，overlay网络和良好的服务发现工具（例如etcd或consul）的组合来管理Docker容器集群。</p><p>与其他开源容器集群管理工具相比，Docker swarm在功能方面仍日趋成熟。考虑到庞大的Docker贡献者，Docker swarm拥有其他工具拥有的所有最佳功能不会太久。Docker记录了在生产中使用docker swarm 的良好生产计划。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589374125/hexo/Swarm_fbtool.jpg" alt="Docker Swarm"></p><h4 id="4-Mesos"><a href="#4-Mesos" class="headerlink" title="4) Mesos"></a>4) Mesos</h4><p>  Mesos是另一个可以非常有效地管理容器编排的群集管理工具。它是由Twitter为其基础架构创建的，然后获得了开源。它已被eBay，Airbnb等公司使用。Mesos并不是用于容器的专用工具，</p><p>Mesos不是用于容器的专用工具，相反，您可以将其用于VM或物理机群集，以运行容器以外的工作负载（大数据等）。它具有一个称为Marathon的有效框架，用于在Mesos群集上部署和管理容器。<br><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589374127/hexo/Mesos_xjlyvv.jpg" alt="Mesos"></p><h3 id="6-服务网格"><a href="#6-服务网格" class="headerlink" title="6. 服务网格"></a>6. 服务网格</h3><p>  容器和容器编排技术的兴起使得新的基础架构成为了可能，使我们能够摆脱服务发现/负载平衡/断路器框架的束缚。 这个新的基础设施就是“服务网格”，那服务网格是什么呢？</p><blockquote><p><strong>服务网格</strong> 是一个<code>基础架构层</code> - 主要是一个代理集合，每个逻辑服务都有一个代理 - 与Docker Swarm或Kubernetes等容器编排解决方案集成，并提供服务发现，负载平衡，断路器，故障注入，安全，监控，跟踪以及更多以非侵入性的方式提供的开箱即用功能。</p></blockquote><p>由于服务网格在容器级别运行，它并不关心使用什么技术或编程语言来编写微服务。 你可以将微服务使用Java，C ++，Rust，Go，NodeJS来编写简单HTTP服务器，这些都已不再重要。</p><p>可以将服务网格有效地视为分布式容器化应用基础架构级的面向切面编程。 服务网格中的代理就像AOP中的一个切面。 它们包裹了一个容器化的微服务，就像AspectJ切面可以包裹和测试java方法一样，通过分离横切关注点来简化系统。</p><p>在服务网格中，请求将通过所在基础架构层中的代理在微服务之间路由。正因如此，构成服务网格的各个代理有时也被称为“sidecar”（边车），这是因为它们与每个服务并行运行，而非在内部运行。总之，这些“sidecar”代理（与每项服务分离）构成了网格式网络。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589376166/hexo/sidecar_ce6pve.png" alt="sidecar"></p><p>服务网格是如何实现的呢？它通常会为每个服务实例提供一个称为边车（sidecar）的代理实例。这些边车会处理服务间的通信，监控和安全相关的问题， 以及任何可以从各个服务中抽象出来的东西。这样，开发人员就可以专注于服务中应用程序代码的开发，支持和维护，而运维团队可以负责维护服务网格以及运行应用程序。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589376932/hexo/contrl_plane_kuexpi.png" alt="contrl plane"></p><p>服务网格应用中管理实例之间的网络流量的的部分称为数据平面。另外有一个独立的控制平面负责生成和部署数据平面的配置（这个配置可以控制数据平面的行为）。控制平面通常包含（或被设计为连接到）一个API，命令行界面和用于管理App的图形用户界面。</p><p><strong>Sidecar 设计模式已经越来越受欢迎，并在社区内得到更广泛的采用。构建具有高度可扩展性、弹性、安全性和可观察性的微服务架构具有挑战性。Service Mesh 架构的发展已经改变了游戏规则。它降低了与微服务架构相关的复杂性，并提供了许多功能，如负载平衡、服务发现、流量管理、熔断、遥测、故障注入等。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 容器服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Docker 中运行 OpenWrt 旁路网关 透明网关</title>
      <link href="/posts/53042.html"/>
      <url>/posts/53042.html</url>
      
        <content type="html"><![CDATA[<p>在接下来的文章中，我们将在 <code>Docker</code> 容器中运行 <code>OpenWrt</code>，并通过设置，让 <code>Docker</code> 容器中的 <code>OpenWrt</code> 网关接管路由器自身的网关，减轻路由器的负担，同时，由于网关被 <code>OpenWrt</code> 接管，所以 <code>OpenWrt</code> 中的大部分应用都是可用的，比如酸酸乳，V2ray，去广告等。做个不恰当的比喻， <code>OpenWrt</code> 网关接管路由器自身的网关后，你可以理解为路由器是 <code>OpenWrt</code> 的一块外置网卡。</p><h2 id="一、概念介绍"><a href="#一、概念介绍" class="headerlink" title="一、概念介绍"></a>一、概念介绍</h2><h3 id="1-OpenWrt"><a href="#1-OpenWrt" class="headerlink" title="1. OpenWrt"></a>1. OpenWrt</h3><blockquote><p><strong>OpenWrt</strong>：是一个高度模块化、高度自动化的嵌入式的Linux发行版，她拥有强大的网络组件和扩展性，常常被用于工控设备、智能家居、路由器等设备中。它还提供了上百个已编译好的软件，而且数量还在不断增加。</p></blockquote><p><code>OpenWrt</code>使用框架来构建应用程序，不需要构建一个完整的固件，对于用户来说，将会拥有完全定制的玩法。OpenWRT支持各种处理器架构，无论是对ARM，X86，PowerPC或者MIPS都有很好的支持。</p><h3 id="2-旁路网关"><a href="#2-旁路网关" class="headerlink" title="2. 旁路网关"></a>2. 旁路网关</h3><p>那么，什么是旁路网关(旁路由)呢？</p><blockquote><p><strong>所谓的旁路网关</strong>：就是在路由器之外的其他硬件设备上搭建一个网关环境，把路由器肩负的网关重任交给其他更适合的设备来做，同时，旁路网关处理完的结果会返回给主路由器，由主路由器继续进行转发处理。</p></blockquote><p>普通的路由器往往集无线信号转发、网关、DNS 服务等角色为一身，其中的“网关”角色负责路由器内部数据与外部网络的交换处理。但因为一般家用的路由器硬件性能很有限，在运行一些比较吃资源的应用（如酸酸乳、去广告等）时，几乎会占满所有硬件资源，导致路由器网络/系统不稳定等诸多问题。<br><br>既然路由器的硬件性能有限，那可不可以把网关的重任交给硬件性能更好的设备去做，让路由器安安心心地做好数据交换的工作哪？<br><br>当然可以了，我们可以增加一个<code>旁路网关</code>，让它预先处理数据，将复杂的功能完成后，再交给主路由进行转发和后续的工作。</p><p>这样，每个角色各司其职，路由器肩上的任务轻了，即使是油管 4K 也能轻松跑满网速了，而<code>旁路网关</code>也能提供更多的功能。由此资源的充分利用，一举两得。</p><h3 id="3-Docker"><a href="#3-Docker" class="headerlink" title="3. Docker"></a>3. Docker</h3><blockquote><p><strong>Docker</strong> 是一个开源，轻量级的应用容器引擎，基于GO语言开发，用于创建、管理和编排容器。与VMware 虚拟机相比，Docker 使用容器承载应用程序，而不使用操作系统，所以它的开销很少，性能很高。</p></blockquote><h2 id="二、Docker-安装"><a href="#二、Docker-安装" class="headerlink" title="二、Docker 安装"></a>二、Docker 安装</h2><h3 id="1-获取自动安装脚本"><a href="#1-获取自动安装脚本" class="headerlink" title="1. 获取自动安装脚本"></a>1. 获取自动安装脚本</h3><blockquote><p>以 <code>阿里云镜像</code>安装脚本内容</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 安装命令</span>curl -fsSL https://get.docker.com -o get-docker.shsh get-docker.sh --mirror Aliyun<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>安装过程如下</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Executing docker install script, commit: 1b02882d63b9cfc484ad6b0180171c679cfe0f3a</span>+ sh -c <span class="token function">apt-get</span> update -qq <span class="token operator">></span>/dev/null+ sh -c DEBIAN_FRONTEND<span class="token operator">=</span>noninteractive <span class="token function">apt-get</span> <span class="token function">install</span> -y -qq apt-transport-https ca-certificates curl <span class="token operator">></span>/dev/null+ sh -c curl -fsSL <span class="token string">"https://download.docker.com/linux/debian/gpg"</span> <span class="token operator">|</span> apt-key add -qq - <span class="token operator">></span>/dev/nullWarning: apt-key output should not be parsed <span class="token punctuation">(</span>stdout is not a terminal<span class="token punctuation">)</span>+ sh -c <span class="token keyword">echo</span> <span class="token string">"deb [arch=arm64] https://download.docker.com/linux/debian stretch stable"</span> <span class="token operator">></span> /etc/apt/sources.list.d/docker.list+ sh -c <span class="token function">apt-get</span> update -qq <span class="token operator">></span>/dev/null+ <span class="token punctuation">[</span> -n  <span class="token punctuation">]</span>+ sh -c <span class="token function">apt-get</span> <span class="token function">install</span> -y -qq --no-install-recommends docker-ce <span class="token operator">></span>/dev/null+ sh -c docker versionClient: Docker Engine - Community Version:           19.03.8 API version:       1.40 Go version:        go1.12.17 Git commit:        afacb8b Built:             Wed Mar 11 01:27:00 2020 OS/Arch:           linux/arm64 Experimental:      <span class="token boolean">false</span>Server: Docker Engine - Community Engine:  Version:          19.03.8  API version:      1.40 <span class="token punctuation">(</span>minimum version 1.12<span class="token punctuation">)</span>  Go version:       go1.12.17  Git commit:       afacb8b  Built:            Wed Mar 11 01:25:31 2020  OS/Arch:          linux/arm64  Experimental:     <span class="token boolean">false</span> containerd:  Version:          1.2.13  GitCommit:        7ad184331fa3e55e52b890ea95e65ba581ae3429 runc:  Version:          1.0.0-rc10  GitCommit:        dc9208a3303feef5b3839f4323d9beb36df0a9dd docker-init:  Version:          0.18.0  GitCommit:        fec3683If you would like to use Docker as a non-root user, you should now consideradding your user to the <span class="token string">"docker"</span> group with something like:  <span class="token function">sudo</span> <span class="token function">usermod</span> -aG docker your-userRemember that you will have to log out and back <span class="token keyword">in</span> <span class="token keyword">for</span> this to take effect<span class="token operator">!</span>WARNING: Adding a user to the <span class="token string">"docker"</span> group will grant the ability to run         containers <span class="token function">which</span> can be used to obtain root privileges on the         docker host.         Refer to https://docs.docker.com/engine/security/security/<span class="token comment" spellcheck="true">#docker-daemon-attack-surface</span>         <span class="token keyword">for</span> <span class="token function">more</span> information.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-开启网卡的混杂模式"><a href="#2-开启网卡的混杂模式" class="headerlink" title="2. 开启网卡的混杂模式"></a>2. 开启网卡的混杂模式</h3><blockquote><p>开启网卡的混杂模式（这样是为了目前这个阶段能正常安装并配置，要永久开启需修改配置文件，稍后详述）</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">ip <span class="token function">link</span> <span class="token keyword">set</span> eth0 promisc on<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-下载-OpenWrt-镜像"><a href="#3-下载-OpenWrt-镜像" class="headerlink" title="3. 下载 OpenWrt 镜像"></a>3. 下载 OpenWrt 镜像</h3><blockquote><p>在终端界面执行以下命令，下载OpenWrt的docker 镜像文件</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 镜像下载命令</span>docker pull buddyfly/openwrt-aarch64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>镜像下载过程如下</p><pre class="line-numbers language-bash"><code class="language-bash">Using default tag: latestlatest: Pulling from buddyfly/openwrt-aarch64aef47d0acf8a: Pull completeDigest: sha256:d3a3f4f9aaac4169d3b16c1f796b5d379c6234b997cb440daee80ef3ad1aba05Status: Downloaded newer image <span class="token keyword">for</span> buddyfly/openwrt-aarch64:latestdocker.io/buddyfly/openwrt-aarch64:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-创建-Docker-虚拟网络"><a href="#4-创建-Docker-虚拟网络" class="headerlink" title="4. 创建 Docker 虚拟网络"></a>4. 创建 Docker 虚拟网络</h3><blockquote><p>虚拟网络名称为<code>macnet</code>，驱动为<code>macvlan</code>模式，将 <code>subnet 10.10.10.0</code>修改为你自己主路由的网段，<code>geteway 10.10.10.1</code>修改为你自己的主路由网关】</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建虚拟网络</span>docker network create -d macvlan --subnet<span class="token operator">=</span>10.10.10.0/24 --gateway<span class="token operator">=</span>10.10.10.1 -o parent<span class="token operator">=</span>eth0 macnet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-启动-OpenWrt-容器"><a href="#5-启动-OpenWrt-容器" class="headerlink" title="5. 启动 OpenWrt 容器"></a>5. 启动 OpenWrt 容器</h3><blockquote><p>启动 OpenWrt 容器</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 开启容器</span>docker run --restart always -d --network macnet --privileged buddyfly/openwrt-aarch64:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-查看运行中的-OpenWrt-容器"><a href="#6-查看运行中的-OpenWrt-容器" class="headerlink" title="6. 查看运行中的 OpenWrt 容器"></a>6. 查看运行中的 OpenWrt 容器</h3><blockquote><p>查看运行中的容器</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看运行中的容器</span>docker <span class="token function">ps</span> -a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行结果如下</p><pre><code>root@aml4:~# docker ps -aCONTAINER ID        IMAGE                             COMMAND             CREATED             STATUS              PORTS               NAMESf76303c1b9f0        buddyfly/openwrt-aarch64:latest   "/sbin/init"        43 seconds ago      Up 40 seconds                           affectionate_liskovroot@aml4:~#</code></pre><h3 id="7-修改OpenWrt容器的IP地址"><a href="#7-修改OpenWrt容器的IP地址" class="headerlink" title="7. 修改OpenWrt容器的IP地址"></a>7. 修改OpenWrt容器的IP地址</h3><blockquote><p>进入openwrt容器修改network设置</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 进入容器命令行</span>docker <span class="token function">exec</span> -it f76303c1b9f0 /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>进入容器命令行结果如下</p><pre><code>root@aml4:~# docker exec -it f763 /bin/bashbash-4.4#</code></pre><blockquote><p>编辑网络配置文件</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 修改网络配置</span><span class="token function">vi</span> /etc/config/network<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>修改文件如下 将<code>option ipaddr 192.168.1.1</code> 改为你想作为旁路网关的空闲地址。我的网段为<code>10.10.10.X</code>,共享地址为<code>10.10.10.254</code></p><pre><code>config interface 'loopback'        option ifname 'lo'        option proto 'static'        option ipaddr '127.0.0.1'        option netmask '255.0.0.0'config globals 'globals'        option ula_prefix 'fd00:6e95:e381::/48'config interface 'lan'        option type 'bridge'        option ifname 'eth0'        option proto 'static'        option ipaddr '10.10.10.254'        option netmask '255.255.255.0'        option ip6assign '60'</code></pre><blockquote><p>重启网络服务</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">/etc/init.d/network restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="8-永久开启网卡混杂模式"><a href="#8-永久开启网卡混杂模式" class="headerlink" title="8. 永久开启网卡混杂模式"></a>8. 永久开启网卡混杂模式</h3><blockquote><p>重启网卡混杂模式会失效，需设为永久开启 修改/etc/network/interfaces文件：</p><p>谨慎操作，可能导致无法访问网络</p><p>添加 <code>up ip link set eth0 promisc on</code></p></blockquote><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589043064/hexo/promisc_tx2nev.png" alt="修改网卡接口配置"></p><h2 id="三、旁路网关配置"><a href="#三、旁路网关配置" class="headerlink" title="三、旁路网关配置"></a>三、旁路网关配置</h2><h3 id="1-登录旁路网关系统"><a href="#1-登录旁路网关系统" class="headerlink" title="1. 登录旁路网关系统"></a>1. 登录旁路网关系统</h3><blockquote><p>用户名 <code>root</code> 密码 <code>password</code></p></blockquote><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589041433/hexo/login_zgy4vg.png" alt="登录界面"></p><h3 id="2-更改系统主题"><a href="#2-更改系统主题" class="headerlink" title="2. 更改系统主题"></a>2. 更改系统主题</h3><blockquote><p>更改系统主题为<code>Argon-Dark</code></p></blockquote><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589043524/hexo/theme_es9ekm.png" alt="更改主题"></p><h3 id="3-更改上级路由"><a href="#3-更改上级路由" class="headerlink" title="3. 更改上级路由"></a>3. 更改上级路由</h3><blockquote><p>点击网络&gt;接口&gt;修改</p></blockquote><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589043893/hexo/lan_smvrcr.png" alt="进入LAN配置"></p><blockquote><p>修改IPv4网关为<code>10.10.10.1</code>,DHCP服务器 勾选 <code>忽略此接口</code></p></blockquote><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589044105/hexo/DHCP_bwtwdk.png" alt="修改上级路由"></p><h3 id="4-网络加速设置"><a href="#4-网络加速设置" class="headerlink" title="4. 网络加速设置"></a>4. 网络加速设置</h3><blockquote><p>开启DNS加速</p></blockquote><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589044491/hexo/ACC_s1tx1m.png" alt="更改主题"></p><h3 id="5-科学上网"><a href="#5-科学上网" class="headerlink" title="5. 科学上网"></a>5. 科学上网</h3><blockquote><p>开启科学上网</p></blockquote><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589044757/hexo/node_moj3rj.png" alt="添加节点"></p><blockquote><p>全局设置</p></blockquote><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589044938/hexo/passwall_gquzdn.png" alt="参数设置"></p><h3 id="6-配置旁路网关"><a href="#6-配置旁路网关" class="headerlink" title="6. 配置旁路网关"></a>6. 配置旁路网关</h3><blockquote><p>局域网中需要科学上网的机器配置旁路网关</p></blockquote><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589045268/hexo/IP_slznx9.png" alt="网关设置"></p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589045677/hexo/youtube_lpmeny.png" alt="油管测速"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 科学上网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> openwrt </tag>
            
            <tag> 旁路由 </tag>
            
            <tag> 透明网关 </tag>
            
            <tag> 科学上网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
