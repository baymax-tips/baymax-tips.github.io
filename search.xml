<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker 入门系列  2. Docker 核心概念和安装使用</title>
      <link href="/2020/05/13/docker-ru-men-xi-lie-2-docker-he-xin-gai-nian-he-an-zhuang-shi-yong/"/>
      <url>/2020/05/13/docker-ru-men-xi-lie-2-docker-he-xin-gai-nian-he-an-zhuang-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="一、-核心概念：镜像、容器与仓库"><a href="#一、-核心概念：镜像、容器与仓库" class="headerlink" title="一、 核心概念：镜像、容器与仓库"></a>一、 核心概念：镜像、容器与仓库</h2><p>Docker 主要包含三个核心概念，分别是镜像、容器和仓库，理解了这三个概念，就理解了 Docker 的整个生命周期。</p><ul><li><p><strong>镜像：</strong> Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p></li><li><p><strong>容器：</strong> 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间容器可以被。创建、启动、停止、删除和暂停等等，说到镜像与容器之间的关系，可以类比面向对象程序设计中的类和实例。</p></li><li><p><strong>仓库：</strong> 镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。一个 Docker Registry 中可以包含多个仓库；每个仓库可以包含多个标签；每个标签对应一个镜像，其中标签可以理解为镜像的版本号。</p></li></ul><h3 id="1-镜像（Image）-一个特殊的文件系统"><a href="#1-镜像（Image）-一个特殊的文件系统" class="headerlink" title="1. 镜像（Image）- 一个特殊的文件系统"></a>1. 镜像（Image）- 一个特殊的文件系统</h3><p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。</p><p><strong>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</strong> 镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589436136/hexo/docker/docker-filesystems-debian_l2gohi.png" alt="rootfs"></p><p>因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589436395/hexo/docker/docker-filesystems-multilayer_ug4ouk.png" alt="multilayer"></p><blockquote><p>Docker 设计时，就充分利用 Union FS的技术，将其设计为 分层存储的架构 。 镜像实际是由多层文件系统联合组成。</p></blockquote><p><strong>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</strong>比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p><strong>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</strong></p><p><strong>总的来说，你最需要记住这点：</strong></p><blockquote><p>在 Dockerfile 中， 每一条指令都会创建一个镜像层，继而会增加整体镜像的大小。</p></blockquote><p><code>镜像作为 Docker 最突出的创新之一，它变革了软件交付标准。理解镜像，对理解整个 Docker 的生命周期非常重要。</code></p><h3 id="2-容器（Container-镜像运行时的实体"><a href="#2-容器（Container-镜像运行时的实体" class="headerlink" title="2. 容器（Container) - 镜像运行时的实体"></a>2. 容器（Container) - 镜像运行时的实体</h3><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，<strong>容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等</strong> 。</p><p>Docker容器将应用程序和运行所需的所有内容封装到一个黑色沙箱中。这包括操作系统，应用程序代码，运行时，系统工具，系统库等.Docker容器是基于Docker镜像构建的。由于镜像是只读的，因此Docker在镜像的只读文件系统上添加了一个读写文件系统来创建容器。</p><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589438151/hexo/docker/container_run_oaqnl8.png" alt="container"></p><p><strong>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</strong></p><blockquote><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p></blockquote><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据 ，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， 使用数据卷后，容器可以随意删除、重新 run ，数据却不会丢失。</p><h3 id="3-仓库（Repository）-集中存放镜像文件的地方"><a href="#3-仓库（Repository）-集中存放镜像文件的地方" class="headerlink" title="3. 仓库（Repository）- 集中存放镜像文件的地方"></a>3. 仓库（Repository）- 集中存放镜像文件的地方</h3><p><strong>Docker 仓库</strong> 是集中存放镜像文件的场所。镜像构建完成后，可以很容易的在当前宿主上运行，但是， <strong>如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务</strong>。</p><p>一个 <code>Docker Registry</code> 中可以包含多个 <strong>仓库（Repository）</strong>；每个仓库可以包含多个 <strong>标签（Tag）</strong>；每个标签对应一个镜像。所以说：<strong>镜像仓库是Docker用来集中存放镜像文件的地方类似于我们之前常用的代码仓库</strong>。</p><p>通常，<strong>一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本</strong> 。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p><p>仓库又可以分为两种形式：</p><ul><li><strong>public(公有仓库)</strong></li><li><strong>private(私有仓库)</strong></li></ul><h4 id="1-公有仓库"><a href="#1-公有仓库" class="headerlink" title="1) 公有仓库"></a>1) 公有仓库</h4><p><strong>Docker Registry 公开服务</strong> 是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公有仓库是官方的 <strong>Docker Hub</strong> ，这也是默认的 Registry，并拥有大量的高质量的官方镜像，网址为：<a href="https://hub.docker.com" target="_blank" rel="noopener">hub.docker.com</a> 。在国内访问Docker Hub 可能会比较慢国内也有一些云服务商提供类似于 <strong>Docker Hub</strong> 的公开服务。比如 <a href="https://www.163yun.com/product/repo" target="_blank" rel="noopener">网易云镜像服务</a>、<a href="https://www.daocloud.io" target="_blank" rel="noopener">DaoCloud 镜像市场</a>、<a href="https://cr.console.aliyun.com" target="_blank" rel="noopener">阿里云镜像库</a>等。</p><h4 id="2-私有仓库"><a href="#2-私有仓库" class="headerlink" title="2) 私有仓库"></a>2) 私有仓库</h4><p>除了使用公有仓库外，用户还可以在本地搭建<strong>私有仓库 Docker Registry</strong>。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/" target="_blank" rel="noopener">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。</p><p>开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 Docker Trusted Registry 中，提供了这些高级功能。</p><p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，Harbor 和 Sonatype Nexus。</p><h2 id="二、Docker-安装"><a href="#二、Docker-安装" class="headerlink" title="二、Docker 安装"></a>二、Docker 安装</h2><h3 id="1-在macOS系统安装"><a href="#1-在macOS系统安装" class="headerlink" title="1. 在macOS系统安装"></a>1. 在macOS系统安装</h3><h4 id="1-1-使用-Homebrew-安装"><a href="#1-1-使用-Homebrew-安装" class="headerlink" title="1.1 使用 Homebrew 安装"></a>1.1 使用 Homebrew 安装</h4><p>Homebrew 的 Cask 已经支持 Docker Desktop for Mac，因此可以很方便的使用 Homebrew Cask 来进行安装：</p><blockquote><p>安装 <strong>HomeBrew</strong></p></blockquote><pre class=" language-bash"><code class="language-bash">/bin/bash -c <span class="token string">"<span class="token variable"><span class="token variable">$(</span>curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh<span class="token variable">)</span></span>"</span></code></pre><blockquote><p>安装 <strong>Docker</strong></p></blockquote><pre class=" language-bash"><code class="language-bash">brew cask <span class="token function">install</span> docker</code></pre><h4 id="1-2-手动下载安装Docker"><a href="#1-2-手动下载安装Docker" class="headerlink" title="1.2 手动下载安装Docker"></a>1.2 手动下载安装Docker</h4><p>如果需要手动下载，请点击以下链接下载 <a href="https://download.docker.com/mac/stable/Docker.dmg" target="_blank" rel="noopener">Stable</a> 或 <a href="https://download.docker.com/mac/edge/Docker.dmg" target="_blank" rel="noopener">Edge</a> 版本的 Docker Desktop for Mac。</p><p>如同 macOS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将那只叫 Moby 的鲸鱼图标拖拽到 Application 文件夹即可（其间需要输入用户密码）。</p><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589441197/hexo/docker/install-mac-dmg_fqqfsl.png" alt="docker dmg"></p><h4 id="1-3-运行Docker桌面服务"><a href="#1-3-运行Docker桌面服务" class="headerlink" title="1.3 运行Docker桌面服务"></a>1.3 运行Docker桌面服务</h4><p>从应用中找到 Docker 图标并点击运行。</p><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589441564/hexo/docker/docker_re2pia.png" alt="docker run"></p><p>运行之后，会在右上角菜单栏看到多了一个鲸鱼图标，这个图标表明了 Docker 的运行状态。</p><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589441905/hexo/docker/dock_tray_oqtgo9.png" alt="docker tray"></p><p>点击鲸鱼图标会弹出操作菜单</p><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589442071/hexo/docker/docker_menu_vj0sul.png" alt="docker menu"></p><p>启动终端后，通过命令可以检查安装后的 Docker 版本。</p><pre class=" language-bash"><code class="language-bash">➜ docker --versionDocker version 19.03.8, build afacb8b~ via ⬢ v12.16.3➜ docker-compose --versiondocker-compose version 1.25.5, build 8a1c60f6~ via ⬢ v12.16.3➜ kubectl versionClient Version: version.Info<span class="token punctuation">{</span>Major:<span class="token string">"1"</span>, Minor:<span class="token string">"16+"</span>, GitVersion:<span class="token string">"v1.16.6-beta.0"</span>, GitCommit:<span class="token string">"e7f962ba86f4ce7033828210ca3556393c377bcc"</span>, GitTreeState:<span class="token string">"clean"</span>, BuildDate:<span class="token string">"2020-01-15T08:26:26Z"</span>, GoVersion:<span class="token string">"go1.13.5"</span>, Compiler:<span class="token string">"gc"</span>, Platform:<span class="token string">"darwin/amd64"</span><span class="token punctuation">}</span>The connection to the server localhost:8080 was refused - did you specify the right host or port?</code></pre><p>通过鲸鱼图标弹出菜单的 About Docker Desktop </p><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589442398/hexo/docker/version_etpeqx.png" alt="docker version"></p><h4 id="1-4-镜像加速"><a href="#1-4-镜像加速" class="headerlink" title="1.4 镜像加速"></a>1.4 镜像加速</h4><p>当然了，由于某些原因，国内从 Docker Hub 上拉取内容会非常缓慢，这个时候就可以配置一个镜像加速器环境。详情说明可以移步Docker 中国官方镜像加速，对于 macOS 用户，在任务栏点击应用图标 -&gt; Perferences… -&gt; Docker Engine -&gt; configuration file，在文件中填写加速器地址 <a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a> 即可。修改完成之后，点击 Apply &amp; Restart 即可。</p><p>国内很多云服务商都提供了国内加速器服务，例如：</p><ul><li>网易云加速器 <a href="https://hub-mirror.c.163.com" target="_blank" rel="noopener">https://hub-mirror.c.163.com</a></li><li>百度云加速器 <a href="https://mirror.baidubce.com" target="_blank" rel="noopener">https://mirror.baidubce.com</a></li><li>阿里云加速器 <a href="https://kfwkfulq.mirror.aliyuncs.com" target="_blank" rel="noopener">https://kfwkfulq.mirror.aliyuncs.com</a></li></ul><pre class=" language-bash"><code class="language-bash"><span class="token string">"registry-mirrors"</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token string">"https://registry.docker-cn.com"</span><span class="token punctuation">]</span></code></pre><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589449037/hexo/docker/mirrors_umiscp.png" alt="mirrors"></p><h2 id="三、-镜像使用"><a href="#三、-镜像使用" class="headerlink" title="三、 镜像使用"></a>三、 镜像使用</h2><p>Docker 使用 C/S 结构，即客户端/服务器体系结构。 Docker 客户端与 Docker 服务器进行交互，Docker服务端负责构建、运行和分发 Docker 镜像。 Docker 客户端和服务端可以运行在一台机器上，也可以通过 RESTful 、 stock 或网络接口与远程 Docker 服务端进行通信。</p><blockquote><p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p></blockquote><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589457087/hexo/docker/Docker-service_dqbfjj.jpg" alt="docker"></p><p><strong>这张图展示了 Docker 客户端、服务端和 Docker 仓库（即 Docker Hub 和 Docker Cloud ），默认情况下Docker 会在 Docker 中央仓库寻找镜像文件，这种利用仓库管理镜像的设计理念类似于 Git ，当然这个仓库是可以通过修改配置来指定的，甚至我们可以创建我们自己的私有仓库。</strong></p><h3 id="1-Docker的简单运用—ubuntu-18-04"><a href="#1-Docker的简单运用—ubuntu-18-04" class="headerlink" title="1. Docker的简单运用—ubuntu:18.04"></a>1. Docker的简单运用—ubuntu:18.04</h3><h4 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1) 获取镜像"></a>1) 获取镜像</h4><p>之前提到过，Docker Hub 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p><p>从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为：</p><pre class=" language-bash"><code class="language-bash">docker pull <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>Docker Registry 地址<span class="token punctuation">[</span>:端口号<span class="token punctuation">]</span>/<span class="token punctuation">]</span>仓库名<span class="token punctuation">[</span>:标签<span class="token punctuation">]</span></code></pre><p>具体的选项可以通过 docker pull –help 命令看到，这里我们说一下镜像名称的格式。</p><ul><li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub。</li><li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li></ul><p>直接运行下面的命令，将名为 <code>ubuntu:18.04</code> 的 image 文件从仓库抓取到本地</p><pre class=" language-bash"><code class="language-bash">docker pull ubuntu:18.04</code></pre><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。</p><blockquote><p>运行结果如下</p></blockquote><pre class=" language-bash"><code class="language-bash">➜ docker pull ubuntu:18.0418.04: Pulling from library/ubuntu23884877105a: Pull completebc38caa0f5b9: Pull complete2910811b6c42: Pull complete36505266dcc6: Pull completeDigest: sha256:3235326357dfb65f1781dbc4df3b834546d8bf914e82cce58e6e6b676e23ce8fStatus: Downloaded newer image <span class="token keyword">for</span> ubuntu:18.04docker.io/library/ubuntu:18.04</code></pre><p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 sha256 的摘要，以确保下载一致性。</p><h4 id="2-列出镜像"><a href="#2-列出镜像" class="headerlink" title="2) 列出镜像"></a>2) 列出镜像</h4><p>要想列出已经下载下来的镜像，可以使用 docker image ls 命令。</p><pre class=" language-bash"><code class="language-bash">docker image <span class="token function">ls</span></code></pre><blockquote><p>运行结果如下</p></blockquote><pre class=" language-bash"><code class="language-bash">➜ docker image <span class="token function">ls</span> -aREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               c3c304cb4f22        2 weeks ago         64.2MBhello-world         latest              bf756fb1ae65        4 months ago        13.3kB</code></pre><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p><p>其中仓库名、标签在之前的基础概念章节已经介绍过了。<strong><code>镜像 ID</code></strong> 则是镜像的唯一标识，一个镜像可以对应多个 标签。因此，在上面的例子中，我们可以看到 ubuntu:18.04 和 ubuntu:latest 拥有相同的 ID，因为它们对应的是同一个镜像。</p><h4 id="3-运行镜像"><a href="#3-运行镜像" class="headerlink" title="3) 运行镜像"></a>3) 运行镜像</h4><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 ubuntu:18.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。</p><p>执行以下命令 运行镜像</p><pre class=" language-bash"><code class="language-bash">docker run -it --rm ubuntu:18.04 <span class="token function">bash</span></code></pre><blockquote><p>运行结果如下</p></blockquote><pre class=" language-bash"><code class="language-bash">➜ docker run -it --rm ubuntu:18.04 <span class="token function">bash</span>root@3a5e608746e1:/<span class="token comment" spellcheck="true"># cat /etc/os-release</span>NAME<span class="token operator">=</span><span class="token string">"Ubuntu"</span>VERSION<span class="token operator">=</span><span class="token string">"18.04.4 LTS (Bionic Beaver)"</span>ID<span class="token operator">=</span>ubuntuID_LIKE<span class="token operator">=</span>debianPRETTY_NAME<span class="token operator">=</span><span class="token string">"Ubuntu 18.04.4 LTS"</span>VERSION_ID<span class="token operator">=</span><span class="token string">"18.04"</span>HOME_URL<span class="token operator">=</span><span class="token string">"https://www.ubuntu.com/"</span>SUPPORT_URL<span class="token operator">=</span><span class="token string">"https://help.ubuntu.com/"</span>BUG_REPORT_URL<span class="token operator">=</span><span class="token string">"https://bugs.launchpad.net/ubuntu/"</span>PRIVACY_POLICY_URL<span class="token operator">=</span><span class="token string">"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"</span>VERSION_CODENAME<span class="token operator">=</span>bionicUBUNTU_CODENAME<span class="token operator">=</span>bionicroot@3a5e608746e1:/<span class="token comment" spellcheck="true">#</span></code></pre><p><code>docker run</code> 就是运行容器的命令，我们这里简要的说明一下上面用到的参数。</p><ul><li>-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li>–rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。</li><li>ubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。</li><li>bash：放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash。</li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <strong>Ubuntu 18.04.1 LTS</strong> 系统。</p><p>最后我们通过 exit 退出了这个容器。</p><h4 id="4-删除本地镜像"><a href="#4-删除本地镜像" class="headerlink" title="4) 删除本地镜像"></a>4) 删除本地镜像</h4><p>如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为：</p><pre class=" language-bash"><code class="language-bash">docker image <span class="token function">rm</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token operator">&lt;</span>镜像1<span class="token operator">></span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>镜像2<span class="token operator">></span> <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre><p>用 ID、镜像名、摘要删除镜像</p><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p><p>比如我们有下列镜像：</p><pre class=" language-bash"><code class="language-bash">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               c3c304cb4f22        2 weeks ago         64.2MBhello-world         latest              bf756fb1ae65        4 months ago        13.3kB</code></pre><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用<code>长 ID</code>，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除 ubuntu 镜像，可以执行：</p><pre class=" language-bash"><code class="language-bash">➜ docker image <span class="token function">rm</span> c3c304cb4f22Untagged: ubuntu:18.04Untagged: ubuntu@sha256:3235326357dfb65f1781dbc4df3b834546d8bf914e82cce58e6e6b676e23ce8fDeleted: sha256:c3c304cb4f22ceb8a6fcc29a0cd6d3e4383ba9eb9b5fb552f87de7c0ba99edacDeleted: sha256:82751c4dcc36265daceeee0abd938806b591eb66700863186377348c96e8aeadDeleted: sha256:24b16cac34768092d57cdb429a12de6c9ee870a3724d70098a189ae0ac344c42Deleted: sha256:b1daff3b271fede2bec31812c398e28952f792935f608e467271cdfaccab7de2Deleted: sha256:b7f7d2967507ba709dbd1dd0426a5b0cdbe1ff936c131f8958c8d0f910eea19e</code></pre><p>我们也可以用镜像名，也就是 &lt;仓库名&gt;:&lt;标签&gt;，来删除镜像。</p><pre class=" language-bash"><code class="language-bash">➜ docker image <span class="token function">rm</span> ubuntu:18.04Untagged: ubuntu:18.04Untagged: ubuntu@sha256:3235326357dfb65f1781dbc4df3b834546d8bf914e82cce58e6e6b676e23ce8fDeleted: sha256:c3c304cb4f22ceb8a6fcc29a0cd6d3e4383ba9eb9b5fb552f87de7c0ba99edacDeleted: sha256:82751c4dcc36265daceeee0abd938806b591eb66700863186377348c96e8aeadDeleted: sha256:24b16cac34768092d57cdb429a12de6c9ee870a3724d70098a189ae0ac344c42Deleted: sha256:b1daff3b271fede2bec31812c398e28952f792935f608e467271cdfaccab7de2Deleted: sha256:b7f7d2967507ba709dbd1dd0426a5b0cdbe1ff936c131f8958c8d0f910eea19e</code></pre><p>当然，更精确的是使用 镜像摘要 删除镜像。</p><pre class=" language-bash"><code class="language-bash">➜ docker image <span class="token function">ls</span> --digestsREPOSITORY          TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZEhello-world         latest              sha256:6a65f928fb91fcfbc963f7aa6d57c8eeb426ad9a20c7ee045538ef34847f44f1   bf756fb1ae65        4 months ago        13.3kB➜ docker image <span class="token function">rm</span> hello-world:latest@sha256:6a65f928fb91fcfbc963f7aa6d57c8eeb426ad9a20c7ee045538ef34847f44f1Untagged: hello-world:latest@sha256:6a65f928fb91fcfbc963f7aa6d57c8eeb426ad9a20c7ee045538ef34847f44f1</code></pre><h2 id="四、操作容器"><a href="#四、操作容器" class="headerlink" title="四、操作容器"></a>四、操作容器</h2><h3 id="1-查看容器"><a href="#1-查看容器" class="headerlink" title="1. 查看容器"></a>1. 查看容器</h3><p>我们要想知道当前有哪些容器在运行，我们可以用如下命令：<br><strong>docker ps -a</strong> <code>-a</code> 是查看当前所有正在运行的容器</p><pre class=" language-bash"><code class="language-bash">docker <span class="token function">ps</span> -a</code></pre><blockquote><p>运行结果如下</p></blockquote><pre class=" language-bash"><code class="language-bash">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES45448b240593        hello-world         <span class="token string">"/hello"</span>            9 minutes ago       Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 9 minutes ago                       keen_pasteur</code></pre><h3 id="2-启动容器"><a href="#2-启动容器" class="headerlink" title="2. 启动容器"></a>2. 启动容器</h3><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p><h4 id="2-1-新建并启动"><a href="#2-1-新建并启动" class="headerlink" title="2.1 新建并启动"></a>2.1 新建并启动</h4><p>所需要的命令主要为 docker run。</p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><pre class=" language-bash"><code class="language-bash">➜ docker run ubuntu:18.04 /bin/echo <span class="token string">'Hello world'</span>Hello world</code></pre><p>这跟在本地直接执行 /bin/echo ‘hello world’ 几乎感觉不出任何区别。</p><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><pre class=" language-bash"><code class="language-bash">➜ docker run -t -i ubuntu:18.04 /bin/bashroot@c0a95c27382a:/<span class="token comment" spellcheck="true">#</span></code></pre><p>其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。<br>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><pre class=" language-bash"><code class="language-bash">➜ docker run -t -i ubuntu:18.04 /bin/bashroot@c0a95c27382a:/<span class="token comment" spellcheck="true"># pwd</span>/root@c0a95c27382a:/<span class="token comment" spellcheck="true"># ls</span>bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  varroot@c0a95c27382a:/<span class="token comment" spellcheck="true">#</span></code></pre><p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h4 id="2-2-启动已终止容器"><a href="#2-2-启动已终止容器" class="headerlink" title="2.2 启动已终止容器"></a>2.2 启动已终止容器</h4><p>可以利用 docker container start 命令，直接将一个已经终止的容器启动运行。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 ps 或 top 来查看进程信息。</p><pre class=" language-bash"><code class="language-bash">root@b0f1a106dcdf:/<span class="token comment" spellcheck="true"># ps</span>  PID TTY          TIME CMD    1 pts/0    00:00:00 <span class="token function">bash</span>   11 pts/0    00:00:00 <span class="token function">ps</span>root@b0f1a106dcdf:/<span class="token comment" spellcheck="true">#</span></code></pre><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><h3 id="3-守护态运行"><a href="#3-守护态运行" class="headerlink" title="3. 守护态运行"></a>3. 守护态运行</h3><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。</p><pre class=" language-bash"><code class="language-bash">➜ docker run ubuntu:18.04 /bin/sh -c <span class="token string">"while true; do echo hello world; sleep 1; done"</span>hello worldhello worldhello worldhello world</code></pre><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p><p>如果使用了 -d 参数运行容器。</p><pre class=" language-bash"><code class="language-bash">➜ docker run -d ubuntu:18.04 /bin/sh -c <span class="token string">"while true; do echo hello world; sleep 1; done"</span>f8849adf1f3ce58981c95142abc65729da41b3b5a4e89edb2d0a8c5ac967f171~ via ⬢ v12.16.3➜</code></pre><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 docker logs 查看)。</p><p><strong>注： 容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。</strong></p><p>使用 -d 参数启动后会返回一个唯一的 id，也可以通过 docker container ls 命令来查看容器信息。</p><pre class=" language-bash"><code class="language-bash">➜ docker container <span class="token function">ls</span>CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS               NAMESf8849adf1f3c        ubuntu:18.04        <span class="token string">"/bin/sh -c 'while t…"</span>   About a minute ago   Up About a minute                       funny_matsumotoc0a95c27382a        ubuntu:18.04        <span class="token string">"/bin/bash"</span>              9 minutes ago        Up 4 minutes                            musing_margulis</code></pre><p>要获取容器的输出信息，可以通过 docker container logs 命令。</p><pre class=" language-bash"><code class="language-bash">➜ docker container logs f8849adf1f3chello worldhello worldhello worldhello worldhello worldhello world<span class="token punctuation">..</span>.</code></pre><h3 id="4-终止容器"><a href="#4-终止容器" class="headerlink" title="4. 终止容器"></a>4. 终止容器</h3><p>可以使用 docker container stop 来终止一个运行中的容器。</p><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p><p>例如对于上一章节中只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。</p><p>终止状态的容器可以用 docker container ls -a 命令看到。例如</p><pre class=" language-bash"><code class="language-bash">➜ docker container <span class="token function">ls</span> -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMESf8849adf1f3c        ubuntu:18.04        <span class="token string">"/bin/sh -c 'while t…"</span>   4 minutes ago       Up 4 minutes                                    funny_matsumoto208d3180e5ca        ubuntu:18.04        <span class="token string">"/bin/sh -c 'while t…"</span>   5 minutes ago       Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 5 minutes ago                        hardcore_dubinskyb0f1a106dcdf        ubuntu:18.04        <span class="token string">"/bin/bash"</span>              7 minutes ago       Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 5 minutes ago                        naughty_lumierec0a95c27382a        ubuntu:18.04        <span class="token string">"/bin/bash"</span>              12 minutes ago      Up 8 minutes                                    musing_margulis1b10a73accd8        ubuntu:18.04        <span class="token string">"/bin/echo 'Hello wo…"</span>   13 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 8 minutes ago                        eager_napier37c02b640650        ubuntu:18.04        <span class="token string">"/bin/echo 'Hello wo…"</span>   13 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 13 minutes ago                       confident_leavitt</code></pre><p>处于终止状态的容器，可以通过 docker container start 命令来重新启动。</p><p>此外，docker container restart 命令会将一个运行态的容器终止，然后再重新启动它。</p><h3 id="5-进入容器"><a href="#5-进入容器" class="headerlink" title="5. 进入容器"></a>5. 进入容器</h3><p>在使用 -d 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令，原因会在下面说明。</p><h4 id="5-1-attach-命令"><a href="#5-1-attach-命令" class="headerlink" title="5.1 attach 命令"></a>5.1 attach 命令</h4><p>下面示例如何使用 docker attach 命令。</p><pre class=" language-bash"><code class="language-bash">➜ docker run -dit ubuntudd8d472bb3b30ba6ab4a230d5734a97c61d0205d8d09ac080c88d3ace0a2fffd~ via ⬢ v12.16.3➜ docker container <span class="token function">ls</span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESdd8d472bb3b3        ubuntu              <span class="token string">"/bin/bash"</span>         7 seconds ago       Up 6 seconds                            optimistic_pasteur~ via ⬢ v12.16.3➜ docker attach dd8d472bb3b3root@dd8d472bb3b3:/<span class="token comment" spellcheck="true">#</span></code></pre><p>注意： 如果从这个 stdin 中 exit，会导致容器的停止。</p><h4 id="5-2-exec-命令"><a href="#5-2-exec-命令" class="headerlink" title="5.2 exec 命令"></a>5.2 exec 命令</h4><p>docker exec 后边可以跟多个参数，这里主要说明 -i -t 参数。</p><p>只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><pre class=" language-bash"><code class="language-bash">➜ docker run -dit ubuntuc9ca08210d46abaee7228c4541f164908063cbd681c4aa541fe4e060da532d45~ via ⬢ v12.16.3➜ docker container <span class="token function">ls</span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESc9ca08210d46        ubuntu              <span class="token string">"/bin/bash"</span>         6 seconds ago       Up 6 seconds                            pedantic_albattani~ via ⬢ v12.16.3➜ docker <span class="token function">exec</span> -i c9ca <span class="token function">bash</span><span class="token function">ls</span>binbootdevetchomeliblib32lib64libx32mediamntoptprocrootrunsbinsrvsystmpusrvar^C~ via ⬢ v12.16.3 took 41s➜ docker <span class="token function">exec</span> -it c9ca <span class="token function">bash</span>root@c9ca08210d46:/<span class="token comment" spellcheck="true">#</span></code></pre><p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 docker exec 的原因。</p><h3 id="6-容器的导出和导入"><a href="#6-容器的导出和导入" class="headerlink" title="6. 容器的导出和导入"></a>6. 容器的导出和导入</h3><h4 id="6-1-导出容器"><a href="#6-1-导出容器" class="headerlink" title="6.1 导出容器"></a>6.1 导出容器</h4><p>如果要导出本地某个容器，可以使用 docker export 命令。</p><pre class=" language-bash"><code class="language-bash">➜ docker <span class="token function">ps</span> -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                       PORTS               NAMESc9ca08210d46        ubuntu              <span class="token string">"/bin/bash"</span>              5 minutes ago       Up 5 minutes                                     pedantic_albattanidd8d472bb3b3        ubuntu              <span class="token string">"/bin/bash"</span>              8 minutes ago       Exited <span class="token punctuation">(</span>127<span class="token punctuation">)</span> 6 minutes ago                       optimistic_pasteur208d3180e5ca        ubuntu:18.04        <span class="token string">"/bin/sh -c 'while t…"</span>   17 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 17 minutes ago                        hardcore_dubinskyb0f1a106dcdf        ubuntu:18.04        <span class="token string">"/bin/bash"</span>              19 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 17 minutes ago                        naughty_lumiere1b10a73accd8        ubuntu:18.04        <span class="token string">"/bin/echo 'Hello wo…"</span>   26 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 20 minutes ago                        eager_napier37c02b640650        ubuntu:18.04        <span class="token string">"/bin/echo 'Hello wo…"</span>   26 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 26 minutes ago                        confident_leavitt~ via ⬢ v12.16.3➜ docker <span class="token function">export</span> 37c02b640650 <span class="token operator">></span> ubuntu.tar</code></pre><p>这样将导出容器快照到本地文件。</p><h4 id="6-1-导入容器"><a href="#6-1-导入容器" class="headerlink" title="6.1 导入容器"></a>6.1 导入容器</h4><p>可以使用 docker import 从容器快照文件中再导入为镜像，例如</p><pre class=" language-bash"><code class="language-bash">➜ <span class="token function">cat</span> ubuntu.tar <span class="token operator">|</span> docker <span class="token function">import</span> - test/ubuntu:v1.0sha256:d21f5263937d78928f78d3c76268783e930a989255fbc5db09453deabd45c537~ via ⬢ v12.16.3 took 2s➜ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEtest/ubuntu         v1.0                d21f5263937d        9 seconds ago       64.2MBubuntu              latest              1d622ef86b13        2 weeks ago         73.9MBubuntu              18.04               c3c304cb4f22        2 weeks ago         64.2MBhello-world         latest              bf756fb1ae65        4 months ago        13.3kB</code></pre><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><pre class=" language-bash"><code class="language-bash">docker <span class="token function">import</span> http://example.com/exampleimage.tgz example/imagerepo</code></pre><p>注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p><h3 id="6-删除容器"><a href="#6-删除容器" class="headerlink" title="6. 删除容器"></a>6. 删除容器</h3><h4 id="6-1-删除容器"><a href="#6-1-删除容器" class="headerlink" title="6.1 删除容器"></a>6.1 删除容器</h4><p>可以使用 docker container rm 来删除一个处于终止状态的容器。例如</p><pre class=" language-bash"><code class="language-bash">➜ docker <span class="token function">ps</span> -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                        PORTS               NAMESc9ca08210d46        ubuntu              <span class="token string">"/bin/bash"</span>              10 minutes ago      Up 10 minutes                                     pedantic_albattanidd8d472bb3b3        ubuntu              <span class="token string">"/bin/bash"</span>              12 minutes ago      Exited <span class="token punctuation">(</span>127<span class="token punctuation">)</span> 10 minutes ago                       optimistic_pasteur208d3180e5ca        ubuntu:18.04        <span class="token string">"/bin/sh -c 'while t…"</span>   22 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 21 minutes ago                         hardcore_dubinskyb0f1a106dcdf        ubuntu:18.04        <span class="token string">"/bin/bash"</span>              24 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 22 minutes ago                         naughty_lumiere1b10a73accd8        ubuntu:18.04        <span class="token string">"/bin/echo 'Hello wo…"</span>   30 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 24 minutes ago                         eager_napier37c02b640650        ubuntu:18.04        <span class="token string">"/bin/echo 'Hello wo…"</span>   30 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 30 minutes ago                         confident_leavitt~ via ⬢ v12.16.3➜ docker container <span class="token function">rm</span> 37c02b64065037c02b640650</code></pre><p>如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</p><h4 id="6-2-清理所有处于终止状态的容器"><a href="#6-2-清理所有处于终止状态的容器" class="headerlink" title="6.2 清理所有处于终止状态的容器"></a>6.2 清理所有处于终止状态的容器</h4><p>用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p><pre class=" language-bash"><code class="language-bash">➜ docker <span class="token function">ps</span> -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                        PORTS               NAMESc9ca08210d46        ubuntu              <span class="token string">"/bin/bash"</span>              12 minutes ago      Up 12 minutes                                     pedantic_albattanidd8d472bb3b3        ubuntu              <span class="token string">"/bin/bash"</span>              14 minutes ago      Exited <span class="token punctuation">(</span>127<span class="token punctuation">)</span> 12 minutes ago                       optimistic_pasteur208d3180e5ca        ubuntu:18.04        <span class="token string">"/bin/sh -c 'while t…"</span>   23 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 23 minutes ago                         hardcore_dubinskyb0f1a106dcdf        ubuntu:18.04        <span class="token string">"/bin/bash"</span>              25 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 23 minutes ago                         naughty_lumiere1b10a73accd8        ubuntu:18.04        <span class="token string">"/bin/echo 'Hello wo…"</span>   32 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 26 minutes ago                         eager_napier~ via ⬢ v12.16.3➜ docker container pruneWARNING<span class="token operator">!</span> This will remove all stopped containers.Are you sure you want to continue? <span class="token punctuation">[</span>y/N<span class="token punctuation">]</span> yDeleted Containers:dd8d472bb3b30ba6ab4a230d5734a97c61d0205d8d09ac080c88d3ace0a2fffd208d3180e5cac70cff44d499951138c968f15921d6e1fcdf1756f8d3c74e890fb0f1a106dcdf1773985fb601f2292683ed825d483675e695eb2cebd9c26b6e4e1b10a73accd84fc078433165ce7fa7527509bd3d2c1c2a33172bc64b98b41944Total reclaimed space: 74B~ via ⬢ v12.16.3 took 3s➜ docker <span class="token function">ps</span> -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESc9ca08210d46        ubuntu              <span class="token string">"/bin/bash"</span>         12 minutes ago      Up 12 minutes                           pedantic_albattani</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 入门系列 1. Docker 简介</title>
      <link href="/2020/05/12/docker-ru-men-xi-lie-1-docker-jian-jie/"/>
      <url>/2020/05/12/docker-ru-men-xi-lie-1-docker-jian-jie/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;本系列笔记是作为一个新手小白，从了解 Docker 是什么、Docker 技术包含哪些概念到上手使用、安装以及发布 Docker 镜像的整个过程。小白在学习过程中遵循简介、入门、上手到深入的顺序，根据个人学习实践过程进行书写与记录。</p><h2 id="一、-Docker-简介"><a href="#一、-Docker-简介" class="headerlink" title="一、 Docker 简介"></a>一、 Docker 简介</h2><p>&emsp;&emsp;Docker是DotCloud开源的、可以将任何应用包装在Linux container中运行的工具。Docker是供开发人员和系统管理员：使用容器构建，运行和共享应用程序的平台。使用容器来部署应用程序称为容器化。容器不是新的技术，但用于轻松部署应用程序的Docker却是新的未来。</p><h3 id="1-容器的概念"><a href="#1-容器的概念" class="headerlink" title="1. 容器的概念"></a>1. 容器的概念</h3><p>&emsp;&emsp;<strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。而 Linux 容器是 Linux 发展出了另一种虚拟化技术，简单来讲， Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离，相当于是在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p><p>&emsp;&emsp;<strong><code>Docker</code> 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个<code>虚拟容器</code>里运行，就好像在真实的物理机上运行一样。有了 <code>Docker</code> ，就不用担心环境问题。</strong></p><p>&emsp;&emsp;<code>Docker</code> 利用 Linux 核心中的资源分脱机制，例如 <code>cgroups</code>，以及 Linux 核心名字空间（name space），来创建独立的软件容器（<code>containers</code>），属于<strong>操作系统层面的虚拟化</strong>技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。<code>Docker</code> 在容器的基础上进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护，使得其比虚拟机技术更为轻便、快捷。<code>Docker</code> 可以在单一 Linux 实体下运作，避免因为创建一个虚拟机而造成的额外负担。</p><p>容器化越来越受欢迎，因为容器具有一下有点:</p><blockquote><ul><li>灵活：即使最复杂的也可以容器化。</li><li>轻量级：容器利用并共享主机内核，在系统资源方面比虚拟机效率更高。</li><li>可移植性：您可以在本地构建，部署到云并在任何地方运行。</li><li>松散耦合：容器是高度自给自足并封装的容器，使您可以在不破坏其他容器的情况下更换或升级它们。</li><li>可扩展：您可以在数据中心内增加并自动分布容器副本。</li><li>安全：容器将积极的约束和隔离应用于流程，而无需用户方面的任何配置。</li></ul></blockquote><h3 id="2-容器和虚拟机"><a href="#2-容器和虚拟机" class="headerlink" title="2. 容器和虚拟机"></a>2. 容器和虚拟机</h3><p>容器在Linux上本地运行，并与其他容器共享主机的内核。它运行一个离散进程，不占用任何其他可执行文件更多的内存，从而使其轻巧。由于容器是进程级别的，相比虚拟机有很多优势</p><p>相比之下，虚拟机（VM）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。并通过虚拟机管理程序对主机资源进行虚拟访问。通常，VM会产生大量开销，超出了应用程序逻辑所消耗的开销。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589358055/hexo/Container_kgmlbw.png" alt="容器技术"></td><td><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589358057/hexo/VM_ioupe2.png" alt="虚拟机"></td></tr></tbody></table><h4 id="1-容器技术"><a href="#1-容器技术" class="headerlink" title="1) 容器技术"></a>1) 容器技术</h4><p>容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。容器内没有自己的内核，也没有进行硬件虚拟。</p><h4 id="2-虚拟机"><a href="#2-虚拟机" class="headerlink" title="2) 虚拟机"></a>2) 虚拟机</h4><p>对于虚拟机技术来说，传统虚拟机如 VMware ， VisualBox 之类的需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。</p><blockquote><p>容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。通过使用容器，我们可以轻松打包应用程序的代码、配置和依赖关系，将其变成容易使用的构建块，从而实现环境一致性、运营效率、开发人员生产力和版本控制等诸多目标。容器可以帮助保证应用程序快速、可靠、一致地部署，其间不受部署环境的影响。容器还赋予我们对资源更多的精细化控制能力，让我们的基础设施效率更高。通过上面这幅图我们可以很直观的反映出这两者的区别所在。</p></blockquote><p><strong>具体来说与虚拟机技术对比，Docker 容器存在以下几个特点：</strong></p><p>&emsp;&emsp;<strong>1. 更快的启动速度：</strong> 因为 Docker 直接运行于宿主内核，无需启动完整的操作系统，因此启动速度属于秒级别，而虚拟机通常需要几分钟去启动。</p><p>&emsp;&emsp;<strong>2. 更高效的资源利用率：</strong>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。</p><p>&emsp;&emsp;<strong>3. 更高的系统支持量：</strong>Docker 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境，Docker 运行的镜像数远多于虚拟机数量，对系统的利用率非常高。</p><p>&emsp;&emsp;<strong>4. 持续交付与部署：</strong>对开发和运维人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至进行自动部署。</p><p>&emsp;&emsp;<strong>5. 更轻松的迁移：</strong>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><p>&emsp;&emsp;<strong>6. 更轻松的维护与扩展：</strong>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><p>&emsp;&emsp;<strong>7. 更弱的隔离性：</strong>Docker 属于进程之间的隔离，虚拟机可实现系统级别隔离。</p><p>&emsp;&emsp;<strong>8. 更弱的安全性：</strong>Docker 的租户 root 和宿主机 root 等同，一旦容器内的用户从普通用户权限提升为 root 权限，它就直接具备了宿主机的 root 权限，进而可进行无限制的操作。虚拟机租户 root 权限和宿主机的 root 虚拟机权限是分离的，并且利用硬件隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击。</p><h3 id="3-Docker的用途"><a href="#3-Docker的用途" class="headerlink" title="3. Docker的用途"></a>3. Docker的用途</h3><p>&emsp;&emsp;<code>Docker</code> 的主要用途，目前有三大类。</p><p>&emsp;&emsp;（1）提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p><p>&emsp;&emsp;（2）提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p><p>&emsp;&emsp;（3）组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p><h3 id="4-容器编排"><a href="#4-容器编排" class="headerlink" title="4. 容器编排"></a>4. 容器编排</h3><p><code>Docker</code>平台以及周边生态系统包含很多工具来管理容器的生命周期。<br>&emsp;&emsp;例如，<strong>Docker Command Line Interface(CLI)支持下面的容器活动:</strong></p><p>&emsp;&emsp; - 从注册表中拉取仓库。<br>&emsp;&emsp; - 运行容器并可选的附加一个终端给它。<br>&emsp;&emsp; - 将容器提交新镜像。<br>&emsp;&emsp; - 上传镜像到注册中心。<br>&emsp;&emsp; - 终止运行中的容器。</p><p><strong>Docker Command Line Interface(CLI) 满足在单个主机上管理容器的需求，但是面对部署在多个主机上的容器时就无所适从了。为了超越单个容器管理，我们必须转向编排工具。<code>容器编排工具</code>将生命周期管理能力扩展到部署在大量机器集群上部署的复杂的、多容器工作负载。通过抽象主机基础结构， 编排工具允许用户将整个集群视为单个部署目标。</strong></p><blockquote><p><strong>容器编排工具</strong> 提供调度和集群的技术，提供用于基于容器应用可扩展性的基本机制。这些工具使用容器服务，并编排他们以决定容器之间如何进行交互。此外，编排允许容器可以存在并执行在集群上，这使得他们能够扩展来适应增加的处理负荷。</p></blockquote><p>&emsp;&emsp;典型的容器编排工具有助于虚拟化一组机器并将它们作为单个集群管理。容器编排工具也有助于将机器上的工作负载或容器移动到消费者透明的位置。很多工具目前既支持基于DOCKER的容器，也支持非容器化二进制文件部署，例如独立的Spring Boot应用程序。这些容器编排工具的基本功能是从应用程序中抽象出实际的服务器实例。</p><blockquote><p><strong>容器编排工具</strong> 为开发人员和基础设施团队提供了一个抽象层来处理大规模的容器化部署。<code>容器编排工具</code>提供的特征在众多提供者之间有所不同，然而常见的公共特征包含准备、发现、资源管理、监视和部署。</p></blockquote><p><strong>容器编排工具的一些关键能力概括如下：</strong></p><ul><li><strong>集群管理：</strong>将虚拟机和物理机器的集群管理为一台大型机器。这些机器在资源能力方面可能有些差异，但大体上都是以Linux作为操作系统的机器。这些虚拟集群可以建立在云上、本地或两者的混合。</li><li><strong>部署：</strong>能处理有大量机器的应用程序和容器的自动部署。支持多个版本的应用程序容器，并且还支持跨越大量集群机器的滚动升级。这些工具还能够处理故障回滚。</li><li><strong>可伸缩性：</strong>支持应用实例的自动和手动伸缩，以性能优化为主要目标。</li><li><strong>健康：</strong>它管理集群、节点和应用程序的健康。可以从集群中移除异常的机器和应用程序实例。</li><li><strong>基础结构抽象化：</strong>开发人员不必担心机器、容量等问题。完全是容器编排工具来决定如何调度和运行应用程序。这些工具也抽象化机器的细节、能力、使用和位置。对于应用程序所有者来说，它们相当于一个容量几乎无限的大型机器。</li><li><strong>资源优化：</strong>这些工具以有效的方式在一组可用机器上分配容器工作负载，从而降低成本，通过从简单的到复杂的算法可有效地提高利用率。</li><li><strong>资源分配：</strong>基于应用程序开发人员设置的资源可用性和约束来分配服务器。资源分配将基于约束、规则、端口要求、应用依赖性、健康等等。</li><li><strong>服务可用性：</strong>确保服务在集群中正常运行。在机器故障的情况下，容器编排会自动通过在集群中的其他机器上重新启动这些服务来处理故障。</li><li><strong>敏捷性：</strong>敏捷性工具能够快速分配工作负载到可用资源，或者在资源需求发生变化时跨机器移动工作量。此外，可以根据业务临界性、业务优先级等来设置约束重新调整资源。</li><li><strong>隔离：</strong>一些工具提供了资源隔离。因此，即使应用程序不是容器化的，也可以实现资源隔离。</li></ul><h3 id="5-编排工具"><a href="#5-编排工具" class="headerlink" title="5. 编排工具"></a>5. 编排工具</h3><h4 id="1-Kubernetes"><a href="#1-Kubernetes" class="headerlink" title="1) Kubernetes"></a>1) Kubernetes</h4><p>&emsp;&emsp;Kubernetes是一个开源的，开箱即用的容器集群管理器和业务流程。它具有出色的构建 调度器 和资源管理器，用于以更有效和高度可用的方式部署容器。Kubernetes已成为许多组织事实上的容器编排工具。kubernetes项目由google与世界各地的贡献者维护。它提供了本机Docker工具不提供的许多功能。而且，使用kubernetes很容易上手。</p><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589374109/hexo/kubernetes_yxk3g7.jpg" alt="Kubernetes"></p><h4 id="2-OpenShift"><a href="#2-OpenShift" class="headerlink" title="2) OpenShift"></a>2) OpenShift</h4><p>&emsp;&emsp;Openshift建立在kubernetes之上。Openshift项目由Redhat维护。它同时具有开源（openshift orgin）和企业版（openshift容器平台）。连同核心的Kubernetes功能，它提供了用于容器管理和编排的开箱即用组件。<br><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589374123/hexo/OpenShift_rfa8hh.jpg" alt="OpenShift"></p><h4 id="3-Docker-Swarm"><a href="#3-Docker-Swarm" class="headerlink" title="3) Docker Swarm"></a>3) Docker Swarm</h4><p>&emsp;&emsp;Docker生态系统包括从开发到生产部署框架的工具。在该列表中，docker swarm适用于集群管理。可以使用docker-compose，swarm，overlay网络和良好的服务发现工具（例如etcd或consul）的组合来管理Docker容器集群。</p><p>与其他开源容器集群管理工具相比，Docker swarm在功能方面仍日趋成熟。考虑到庞大的Docker贡献者，Docker swarm拥有其他工具拥有的所有最佳功能不会太久。Docker记录了在生产中使用docker swarm 的良好生产计划。</p><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589374125/hexo/Swarm_fbtool.jpg" alt="Docker Swarm"></p><h4 id="4-Mesos"><a href="#4-Mesos" class="headerlink" title="4) Mesos"></a>4) Mesos</h4><p>&emsp;&emsp;Mesos是另一个可以非常有效地管理容器编排的群集管理工具。它是由Twitter为其基础架构创建的，然后获得了开源。它已被eBay，Airbnb等公司使用。Mesos并不是用于容器的专用工具，</p><p>Mesos不是用于容器的专用工具，相反，您可以将其用于VM或物理机群集，以运行容器以外的工作负载（大数据等）。它具有一个称为Marathon的有效框架，用于在Mesos群集上部署和管理容器。<br><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589374127/hexo/Mesos_xjlyvv.jpg" alt="Mesos"></p><h3 id="6-服务网格"><a href="#6-服务网格" class="headerlink" title="6. 服务网格"></a>6. 服务网格</h3><p>&emsp;&emsp;容器和容器编排技术的兴起使得新的基础架构成为了可能，使我们能够摆脱服务发现/负载平衡/断路器框架的束缚。 这个新的基础设施就是“服务网格”，那服务网格是什么呢？</p><blockquote><p><strong>服务网格</strong> 是一个<code>基础架构层</code> - 主要是一个代理集合，每个逻辑服务都有一个代理 - 与Docker Swarm或Kubernetes等容器编排解决方案集成，并提供服务发现，负载平衡，断路器，故障注入，安全，监控，跟踪以及更多以非侵入性的方式提供的开箱即用功能。</p></blockquote><p>由于服务网格在容器级别运行，它并不关心使用什么技术或编程语言来编写微服务。 你可以将微服务使用Java，C ++，Rust，Go，NodeJS来编写简单HTTP服务器，这些都已不再重要。</p><p>可以将服务网格有效地视为分布式容器化应用基础架构级的面向切面编程。 服务网格中的代理就像AOP中的一个切面。 它们包裹了一个容器化的微服务，就像AspectJ切面可以包裹和测试java方法一样，通过分离横切关注点来简化系统。</p><p>在服务网格中，请求将通过所在基础架构层中的代理在微服务之间路由。正因如此，构成服务网格的各个代理有时也被称为“sidecar”（边车），这是因为它们与每个服务并行运行，而非在内部运行。总之，这些“sidecar”代理（与每项服务分离）构成了网格式网络。</p><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589376166/hexo/sidecar_ce6pve.png" alt="sidecar"></p><p>服务网格是如何实现的呢？它通常会为每个服务实例提供一个称为边车（sidecar）的代理实例。这些边车会处理服务间的通信，监控和安全相关的问题， 以及任何可以从各个服务中抽象出来的东西。这样，开发人员就可以专注于服务中应用程序代码的开发，支持和维护，而运维团队可以负责维护服务网格以及运行应用程序。</p><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589376932/hexo/contrl_plane_kuexpi.png" alt="contrl plane"></p><p>服务网格应用中管理实例之间的网络流量的的部分称为数据平面。另外有一个独立的控制平面负责生成和部署数据平面的配置（这个配置可以控制数据平面的行为）。控制平面通常包含（或被设计为连接到）一个API，命令行界面和用于管理App的图形用户界面。</p><p><strong>Sidecar 设计模式已经越来越受欢迎，并在社区内得到更广泛的采用。构建具有高度可扩展性、弹性、安全性和可观察性的微服务架构具有挑战性。Service Mesh 架构的发展已经改变了游戏规则。它降低了与微服务架构相关的复杂性，并提供了许多功能，如负载平衡、服务发现、流量管理、熔断、遥测、故障注入等。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 容器服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Docker 中运行 OpenWrt 旁路网关</title>
      <link href="/2020/05/09/zai-docker-zhong-yun-xing-openwrt-pang-lu-wang-guan/"/>
      <url>/2020/05/09/zai-docker-zhong-yun-xing-openwrt-pang-lu-wang-guan/</url>
      
        <content type="html"><![CDATA[<p>在接下来的文章中，我们将在 <code>Docker</code> 容器中运行 <code>OpenWrt</code>，并通过设置，让 <code>Docker</code> 容器中的 <code>OpenWrt</code> 网关接管路由器自身的网关，减轻路由器的负担，同时，由于网关被 <code>OpenWrt</code> 接管，所以 <code>OpenWrt</code> 中的大部分应用都是可用的，比如酸酸乳，V2ray，去广告等。做个不恰当的比喻， <code>OpenWrt</code> 网关接管路由器自身的网关后，你可以理解为路由器是 <code>OpenWrt</code> 的一块外置网卡。</p><h2 id="一、概念介绍"><a href="#一、概念介绍" class="headerlink" title="一、概念介绍"></a>一、概念介绍</h2><h3 id="1-OpenWrt"><a href="#1-OpenWrt" class="headerlink" title="1. OpenWrt"></a>1. OpenWrt</h3><blockquote><p><strong>OpenWrt</strong>：是一个高度模块化、高度自动化的嵌入式的Linux发行版，她拥有强大的网络组件和扩展性，常常被用于工控设备、智能家居、路由器等设备中。它还提供了上百个已编译好的软件，而且数量还在不断增加。</p></blockquote><p><code>OpenWrt</code>使用框架来构建应用程序，不需要构建一个完整的固件，对于用户来说，将会拥有完全定制的玩法。OpenWRT支持各种处理器架构，无论是对ARM，X86，PowerPC或者MIPS都有很好的支持。</p><h3 id="2-旁路网关"><a href="#2-旁路网关" class="headerlink" title="2. 旁路网关"></a>2. 旁路网关</h3><p>那么，什么是旁路网关(旁路由)呢？</p><blockquote><p><strong>所谓的旁路网关</strong>：就是在路由器之外的其他硬件设备上搭建一个网关环境，把路由器肩负的网关重任交给其他更适合的设备来做，同时，旁路网关处理完的结果会返回给主路由器，由主路由器继续进行转发处理。</p></blockquote><p>普通的路由器往往集无线信号转发、网关、DNS 服务等角色为一身，其中的“网关”角色负责路由器内部数据与外部网络的交换处理。但因为一般家用的路由器硬件性能很有限，在运行一些比较吃资源的应用（如酸酸乳、去广告等）时，几乎会占满所有硬件资源，导致路由器网络/系统不稳定等诸多问题。<br/><br>既然路由器的硬件性能有限，那可不可以把网关的重任交给硬件性能更好的设备去做，让路由器安安心心地做好数据交换的工作哪？<br/><br>当然可以了，我们可以增加一个<code>旁路网关</code>，让它预先处理数据，将复杂的功能完成后，再交给主路由进行转发和后续的工作。</p><p>这样，每个角色各司其职，路由器肩上的任务轻了，即使是油管 4K 也能轻松跑满网速了，而<code>旁路网关</code>也能提供更多的功能。由此资源的充分利用，一举两得。</p><h3 id="3-Docker"><a href="#3-Docker" class="headerlink" title="3. Docker"></a>3. Docker</h3><blockquote><p><strong>Docker</strong> 是一个开源，轻量级的应用容器引擎，基于GO语言开发，用于创建、管理和编排容器。与VMware 虚拟机相比，Docker 使用容器承载应用程序，而不使用操作系统，所以它的开销很少，性能很高。</p></blockquote><h2 id="二、Docker-安装"><a href="#二、Docker-安装" class="headerlink" title="二、Docker 安装"></a>二、Docker 安装</h2><h3 id="1-获取自动安装脚本"><a href="#1-获取自动安装脚本" class="headerlink" title="1. 获取自动安装脚本"></a>1. 获取自动安装脚本</h3><blockquote><p>以 <code>阿里云镜像</code>安装脚本内容</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 安装命令</span>curl -fsSL https://get.docker.com -o get-docker.shsh get-docker.sh --mirror Aliyun</code></pre><p>安装过程如下</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Executing docker install script, commit: 1b02882d63b9cfc484ad6b0180171c679cfe0f3a</span>+ sh -c <span class="token function">apt-get</span> update -qq <span class="token operator">></span>/dev/null+ sh -c DEBIAN_FRONTEND<span class="token operator">=</span>noninteractive <span class="token function">apt-get</span> <span class="token function">install</span> -y -qq apt-transport-https ca-certificates curl <span class="token operator">></span>/dev/null+ sh -c curl -fsSL <span class="token string">"https://download.docker.com/linux/debian/gpg"</span> <span class="token operator">|</span> apt-key add -qq - <span class="token operator">></span>/dev/nullWarning: apt-key output should not be parsed <span class="token punctuation">(</span>stdout is not a terminal<span class="token punctuation">)</span>+ sh -c <span class="token keyword">echo</span> <span class="token string">"deb [arch=arm64] https://download.docker.com/linux/debian stretch stable"</span> <span class="token operator">></span> /etc/apt/sources.list.d/docker.list+ sh -c <span class="token function">apt-get</span> update -qq <span class="token operator">></span>/dev/null+ <span class="token punctuation">[</span> -n  <span class="token punctuation">]</span>+ sh -c <span class="token function">apt-get</span> <span class="token function">install</span> -y -qq --no-install-recommends docker-ce <span class="token operator">></span>/dev/null+ sh -c docker versionClient: Docker Engine - Community Version:           19.03.8 API version:       1.40 Go version:        go1.12.17 Git commit:        afacb8b Built:             Wed Mar 11 01:27:00 2020 OS/Arch:           linux/arm64 Experimental:      <span class="token boolean">false</span>Server: Docker Engine - Community Engine:  Version:          19.03.8  API version:      1.40 <span class="token punctuation">(</span>minimum version 1.12<span class="token punctuation">)</span>  Go version:       go1.12.17  Git commit:       afacb8b  Built:            Wed Mar 11 01:25:31 2020  OS/Arch:          linux/arm64  Experimental:     <span class="token boolean">false</span> containerd:  Version:          1.2.13  GitCommit:        7ad184331fa3e55e52b890ea95e65ba581ae3429 runc:  Version:          1.0.0-rc10  GitCommit:        dc9208a3303feef5b3839f4323d9beb36df0a9dd docker-init:  Version:          0.18.0  GitCommit:        fec3683If you would like to use Docker as a non-root user, you should now consideradding your user to the <span class="token string">"docker"</span> group with something like:  <span class="token function">sudo</span> <span class="token function">usermod</span> -aG docker your-userRemember that you will have to log out and back <span class="token keyword">in</span> <span class="token keyword">for</span> this to take effect<span class="token operator">!</span>WARNING: Adding a user to the <span class="token string">"docker"</span> group will grant the ability to run         containers <span class="token function">which</span> can be used to obtain root privileges on the         docker host.         Refer to https://docs.docker.com/engine/security/security/<span class="token comment" spellcheck="true">#docker-daemon-attack-surface</span>         <span class="token keyword">for</span> <span class="token function">more</span> information.</code></pre><h3 id="2-开启网卡的混杂模式"><a href="#2-开启网卡的混杂模式" class="headerlink" title="2. 开启网卡的混杂模式"></a>2. 开启网卡的混杂模式</h3><blockquote><p>开启网卡的混杂模式（这样是为了目前这个阶段能正常安装并配置，要永久开启需修改配置文件，稍后详述）</p></blockquote><pre class=" language-bash"><code class="language-bash">ip <span class="token function">link</span> <span class="token keyword">set</span> eth0 promisc on</code></pre><h3 id="3-下载-OpenWrt-镜像"><a href="#3-下载-OpenWrt-镜像" class="headerlink" title="3. 下载 OpenWrt 镜像"></a>3. 下载 OpenWrt 镜像</h3><blockquote><p>在终端界面执行以下命令，下载OpenWrt的docker 镜像文件</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 镜像下载命令</span>docker pull buddyfly/openwrt-aarch64</code></pre><p>镜像下载过程如下</p><pre class=" language-bash"><code class="language-bash">Using default tag: latestlatest: Pulling from buddyfly/openwrt-aarch64aef47d0acf8a: Pull completeDigest: sha256:d3a3f4f9aaac4169d3b16c1f796b5d379c6234b997cb440daee80ef3ad1aba05Status: Downloaded newer image <span class="token keyword">for</span> buddyfly/openwrt-aarch64:latestdocker.io/buddyfly/openwrt-aarch64:latest</code></pre><h3 id="4-创建-Docker-虚拟网络"><a href="#4-创建-Docker-虚拟网络" class="headerlink" title="4. 创建 Docker 虚拟网络"></a>4. 创建 Docker 虚拟网络</h3><blockquote><p>虚拟网络名称为<code>macnet</code>，驱动为<code>macvlan</code>模式，将 <code>subnet 10.10.10.0</code>修改为你自己主路由的网段，<code>geteway 10.10.10.1</code>修改为你自己的主路由网关】</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建虚拟网络</span>docker network create -d macvlan --subnet<span class="token operator">=</span>10.10.10.0/24 --gateway<span class="token operator">=</span>10.10.10.1 -o parent<span class="token operator">=</span>eth0 macnet</code></pre><h3 id="5-启动-OpenWrt-容器"><a href="#5-启动-OpenWrt-容器" class="headerlink" title="5. 启动 OpenWrt 容器"></a>5. 启动 OpenWrt 容器</h3><blockquote><p>启动 OpenWrt 容器</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 开启容器</span>docker run --restart always -d --network macnet --privileged buddyfly/openwrt-aarch64:latest</code></pre><h3 id="6-查看运行中的-OpenWrt-容器"><a href="#6-查看运行中的-OpenWrt-容器" class="headerlink" title="6. 查看运行中的 OpenWrt 容器"></a>6. 查看运行中的 OpenWrt 容器</h3><blockquote><p>查看运行中的容器</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看运行中的容器</span>docker <span class="token function">ps</span> -a</code></pre><p>运行结果如下</p><pre><code>root@aml4:~# docker ps -aCONTAINER ID        IMAGE                             COMMAND             CREATED             STATUS              PORTS               NAMESf76303c1b9f0        buddyfly/openwrt-aarch64:latest   &quot;/sbin/init&quot;        43 seconds ago      Up 40 seconds                           affectionate_liskovroot@aml4:~#</code></pre><h3 id="7-修改OpenWrt容器的IP地址"><a href="#7-修改OpenWrt容器的IP地址" class="headerlink" title="7. 修改OpenWrt容器的IP地址"></a>7. 修改OpenWrt容器的IP地址</h3><blockquote><p>进入openwrt容器修改network设置</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 进入容器命令行</span>docker <span class="token function">exec</span> -it f76303c1b9f0 /bin/bash</code></pre><p>进入容器命令行结果如下</p><pre><code>root@aml4:~# docker exec -it f763 /bin/bashbash-4.4#</code></pre><blockquote><p>编辑网络配置文件</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 修改网络配置</span><span class="token function">vi</span> /etc/config/network</code></pre><p>修改文件如下 将<code>option ipaddr 192.168.1.1</code> 改为你想作为旁路网关的空闲地址。我的网段为<code>10.10.10.X</code>,共享地址为<code>10.10.10.254</code></p><pre><code>config interface &#39;loopback&#39;        option ifname &#39;lo&#39;        option proto &#39;static&#39;        option ipaddr &#39;127.0.0.1&#39;        option netmask &#39;255.0.0.0&#39;config globals &#39;globals&#39;        option ula_prefix &#39;fd00:6e95:e381::/48&#39;config interface &#39;lan&#39;        option type &#39;bridge&#39;        option ifname &#39;eth0&#39;        option proto &#39;static&#39;        option ipaddr &#39;10.10.10.254&#39;        option netmask &#39;255.255.255.0&#39;        option ip6assign &#39;60&#39;</code></pre><blockquote><p>重启网络服务</p></blockquote><pre class=" language-bash"><code class="language-bash">/etc/init.d/network restart</code></pre><h3 id="8-永久开启网卡混杂模式"><a href="#8-永久开启网卡混杂模式" class="headerlink" title="8. 永久开启网卡混杂模式"></a>8. 永久开启网卡混杂模式</h3><blockquote><p>重启网卡混杂模式会失效，需设为永久开启 修改/etc/network/interfaces文件：</p><p>谨慎操作，可能导致无法访问网络</p><p>添加 <code>up ip link set eth0 promisc on</code></p></blockquote><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589043064/hexo/promisc_tx2nev.png" alt="修改网卡接口配置"></p><h2 id="三、旁路网关配置"><a href="#三、旁路网关配置" class="headerlink" title="三、旁路网关配置"></a>三、旁路网关配置</h2><h3 id="1-登录旁路网关系统"><a href="#1-登录旁路网关系统" class="headerlink" title="1. 登录旁路网关系统"></a>1. 登录旁路网关系统</h3><blockquote><p>用户名 <code>root</code> 密码 <code>password</code></p></blockquote><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589041433/hexo/login_zgy4vg.png" alt="登录界面"></p><h3 id="2-更改系统主题"><a href="#2-更改系统主题" class="headerlink" title="2. 更改系统主题"></a>2. 更改系统主题</h3><blockquote><p>更改系统主题为<code>Argon-Dark</code></p></blockquote><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589043524/hexo/theme_es9ekm.png" alt="更改主题"></p><h3 id="3-更改上级路由"><a href="#3-更改上级路由" class="headerlink" title="3. 更改上级路由"></a>3. 更改上级路由</h3><blockquote><p>点击网络&gt;接口&gt;修改</p></blockquote><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589043893/hexo/lan_smvrcr.png" alt="进入LAN配置"></p><blockquote><p>修改IPv4网关为<code>10.10.10.1</code>,DHCP服务器 勾选 <code>忽略此接口</code></p></blockquote><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589044105/hexo/DHCP_bwtwdk.png" alt="修改上级路由"></p><h3 id="4-网络加速设置"><a href="#4-网络加速设置" class="headerlink" title="4. 网络加速设置"></a>4. 网络加速设置</h3><blockquote><p>开启DNS加速</p></blockquote><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589044491/hexo/ACC_s1tx1m.png" alt="更改主题"></p><h3 id="5-科学上网"><a href="#5-科学上网" class="headerlink" title="5. 科学上网"></a>5. 科学上网</h3><blockquote><p>开启科学上网</p></blockquote><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589044757/hexo/node_moj3rj.png" alt="添加节点"></p><blockquote><p>全局设置</p></blockquote><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589044938/hexo/passwall_gquzdn.png" alt="参数设置"></p><h3 id="6-配置旁路网关"><a href="#6-配置旁路网关" class="headerlink" title="6. 配置旁路网关"></a>6. 配置旁路网关</h3><blockquote><p>局域网中需要科学上网的机器配置旁路网关</p></blockquote><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589045268/hexo/IP_slznx9.png" alt="网关设置"></p><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589045677/hexo/youtube_lpmeny.png" alt="油管测速"></p>]]></content>
      
      
      <categories>
          
          <category> 科学上网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> openwrt </tag>
            
            <tag> 旁路由 </tag>
            
            <tag> 透明网关 </tag>
            
            <tag> 科学上网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/08/hello-world/"/>
      <url>/2020/05/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
