<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker入门系列  4. Docker 容器网络的概念及网络配置 网桥网络</title>
      <link href="/posts/27457.html"/>
      <url>/posts/27457.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-网络概述"><a href="#1-网络概述" class="headerlink" title="1. 网络概述"></a>1. 网络概述</h2><p>  Docker容器和服务如此强大的原因之一是你可以将它们连接在一起，或将它们连接到非Docker工作负载。Docker容器和服务甚至不需要知道它们已部署在Docker上，也不必知道它们的对等对象是否也是Docker工作负载。无论您的Docker主机运行Linux，Windows还是两者结合，您都可以使用Docker以与平台无关的方式管理它们。</p><p>本主题定义了一些基本的Docker网络概念，并使你准备设计和部署应用程序以充分利用这些功能。</p><p>这些内容大部分都适用于所有Docker安装。但是， 一些高级功能仅适用于Docker 企业版客户。</p><h3 id="1-1-网络驱动"><a href="#1-1-网络驱动" class="headerlink" title="1.1 网络驱动"></a>1.1 网络驱动</h3><p>Docker的网络子系统可使用驱动程序插拔式接入。默认情况下，有几个驱动程序，它们提供核心联网功能：</p><ul><li><p><code>bridge</code>：默认的网络驱动程序。如果未指定驱动程序，则这是您正在创建的网络类型。当您的应用程序在需要通信的独立容器中运行时，通常会使用<code>网桥网络</code>。请参阅 网桥网络。</p></li><li><p><code>host</code>：对于独立容器，请删除容器与Docker主机之间的网络隔离，然后直接使用主机的网络。host 仅可用于Docker 17.06及更高版本上的集群服务。请参阅 使用<code>主机网络</code>。</p></li><li><p><code>overlay</code>：<code>叠加网络</code>将多个Docker守护程序连接在一起，并使群集服务能够相互通信。您还可以使用覆盖网络来促进群集服务和独立容器之间或不同Docker守护程序上的两个独立容器之间的通信。这种策略消除了在这些容器之间进行操作系统级路由的需要。请参阅<code>叠加网络</code>。</p></li><li><p><code>macvlan</code>：<code>Macvlan网络</code>允许您将MAC地址分配给容器，使其在网络上显示为物理设备。Docker守护程序通过其MAC地址将流量路由到容器。macvlan 在处理希望直接连接到物理网络而不是通过Docker主机的网络堆栈进行路由的旧应用程序时，使用驱动程序有时是最佳选择。请参阅 <code>Macvlan网络</code>。</p></li><li><p><code>none</code>：对于此容器，请禁用所有联网。通常与自定义网络驱动程序一起使用。none不适用于群体服务。请参阅 禁用容器联网。</p></li><li><p><code>网络插件</code>：您可以在Docker上安装和使用第三方网络插件。这些插件可从 Docker Hub 或第三方供应商处获得。有关安装和使用给定网络插件的信息，请参阅供应商的文档。</p></li></ul><h4 id="网络驱动程序摘要"><a href="#网络驱动程序摘要" class="headerlink" title="网络驱动程序摘要"></a>网络驱动程序摘要</h4><ul><li>当您需要多个容器在同一Docker主机上进行通信时，最好使用用户定义的<code>网桥网络</code>。</li><li>当网络堆栈不应与Docker主机隔离时，但您希望容器的其他方面隔离时，<code>主机网络</code>是最佳选择。</li><li>当您需要在不同Docker主机上运行的容器进行通信时，或者当多个应用程序使用集群服务一起工作时，<code>覆盖网络</code>是最好的。</li><li>从VM设置迁移或需要容器看起来像网络上的物理主机（每个主机都有唯一的MAC地址）时，<code>Macvlan网络</code>是最好的。</li><li>第三方网络插件使您可以将Docker与专用网络堆栈集成。</li></ul><h3 id="1-2-Docker-EE网络功能"><a href="#1-2-Docker-EE网络功能" class="headerlink" title="1.2 Docker EE网络功能"></a>1.2 Docker EE网络功能</h3><p>以下两个功能仅在使用Docker 企业版和使用通用控制平面（UCP）管理Docker服务时才可用：</p><ul><li><p><code>HTTP路由网格</code> 可以让你分享多个服务之间的相同的网络IP地址和端口。根据客户端的请求，UCP使用主机名和端口的组合将流量路由到适当的服务。</p></li><li><p><code>会话粘性</code> 使您可以在HTTP标头中指定UCP用于需要状态会话的应用程序将后续请求路由到同一服务任务的信息。</p></li></ul><h2 id="2-使用网桥网络"><a href="#2-使用网桥网络" class="headerlink" title="2. 使用网桥网络"></a>2. 使用网桥网络</h2><p>就网络而言，桥接网络是在网段之间转发流量的链路层设备。桥可以是在主机内核中运行的硬件设备或软件设备。</p><p>就Docker而言，网桥网络使用软件网桥，该软件网桥允许连接到同一网桥网络的容器进行通信，同时与未连接到该网桥网络的容器隔离。Docker网桥驱动程序会自动在主机中安装规则，以使不同网桥网络上的容器无法直接相互通信。</p><p>桥接网络适用于在同一 Docker守护程序主机上运行的容器。为了在不同Docker守护程序主机上运行的容器之间进行通信，您可以在OS级别管理路由，也可以使用<code>覆盖网络</code>。</p><p>启动Docker时，会自动创建一个<code>默认的桥接网络</code>（也称为<code>bridge</code>），除非另有说明，否则新启动的容器将连接到它。您还可以创建用户定义的自定义网桥网络。<strong>用户定义的网桥网络优于默认<code>bridge</code> 网络</strong>。</p><h3 id="2-1-用户定义的网桥和默认网桥之间的区别"><a href="#2-1-用户定义的网桥和默认网桥之间的区别" class="headerlink" title="2.1 用户定义的网桥和默认网桥之间的区别"></a>2.1 用户定义的网桥和默认网桥之间的区别</h3><ul><li><p><strong>用户定义的网桥可在容器化应用程序之间提供更好的隔离和互操作性。</strong></p><p>  连接到同一用户定义的<code>网桥网络</code>的容器会自动将所有端口彼此公开，而不会向外界公开任何端口。这使容器化的应用程序可以轻松地彼此通信，而不会意外打开对外界的访问。</p><p>  想象一个具有Web前端和数据库后端的应用程序。外界需要访问Web前端（也许在端口80上），但是只有后端本身需要访问数据库主机和端口。使用用户定义的网桥，只需打开Web端口，并且数据库应用程序不需要打开任何端口，因为Web前端可以通过用户定义的网桥访问它。</p><blockquote><p>如果在默认网桥网络上运行相同的应用程序堆栈，则需要使用-p或–publish 标志分别打开Web端口和数据库端口。这意味着Docker主机需要通过其他方式阻止对数据库端口的访问。</p></blockquote></li><li><p><strong>用户定义的网桥可在容器之间提供自动DNS解析。</strong></p><p>  缺省桥接网络上的容器只能通过IP地址相互访问，除非您使用被认为是传统的–link选项。在用户定义的网桥网络上，容器可以通过名称或别名相互解析。</p><p>  想象一下与上一点相同的应用程序，它具有一个Web前端和一个数据库后端。如果调用容器web和db，则db无论应用程序堆栈在哪个Docker主机上运行，Web容器都可以在处连接到db容器。</p><blockquote><p>如果在默认网桥网络上运行相同的应用程序堆栈，则需要在容器之间手动创建链接（使用旧式–link 标志）。这些链接需要双向创建，因此您可以看到，要进行通信的容器超过两个，这将变得很复杂。另外，您可以操纵/etc/hosts容器中的文件，但这会产生难以调试的问题。</p></blockquote></li><li><p><strong>容器可以随时随地从用户定义的网络连接和分离。</strong></p><blockquote><p>在容器的生命周期内，您可以即时将其与用户定义的网络连接或断开连接。要从默认桥接网络中删除容器，您需要停止容器并使用其他网络选项重新创建它。</p></blockquote></li><li><p><strong>每个用户定义的网络都会创建一个可配置的网桥。</strong></p><p>  如果您的容器使用默认桥接网络，则可以对其进行配置，但是所有容器都使用相同的设置，例如MTU和iptables规则。另外，配置默认桥接网络发生在Docker本身之外，并且需要重新启动Docker。</p><blockquote><p>用户定义的桥接网络是使用创建和配置的 docker network create。如果不同的应用程序组具有不同的网络要求，则可以在创建时分别配置每个用户定义的网桥。</p></blockquote></li><li><p><strong>默认网桥网络上的链接容器共享环境变量。</strong></p><p>  最初，在两个容器之间共享环境变量的唯一方法是使用–linkflag链接它们。用户定义的网络无法进行这种类型的变量共享。但是，存在共享环境变量的高级方法。一些想法：</p><pre><code>- 多个容器可以使用Docker卷挂载包含共享信息的文件或目录。- 使用可以一起启动多个容器docker-compose，并且compose文件可以定义共享变量。- 您可以使用群体服务代替独立容器，并利用共享的机密和 配置。</code></pre></li></ul><p>连接到同一用户定义网桥网络的容器可以有效地将所有端口彼此公开。为了使容器或不同网络上的非Docker主机可以访问该端口，必须使用或 标志发布该端口。-p–publish</p><h3 id="2-2-管理用户定义的网桥"><a href="#2-2-管理用户定义的网桥" class="headerlink" title="2.2 管理用户定义的网桥"></a>2.2 管理用户定义的网桥</h3><p>使用该docker network create命令创建用户定义的网桥网络。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create my-net</span><br></pre></td></tr></tbody></table></figure><p>您可以指定子网，IP地址范围，网关和其他选项。有关详细信息，请参见 docker网络创建 参考或输出docker network create –help。</p><p>使用该docker network rm命令删除用户定义的网桥网络。如果容器当前已连接到网络， 请先断开它们的连接 。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network rm my-net</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>到底发生了什么事？</strong></p><p>当您创建或删除用户定义的网桥或将容器与用户定义的网桥连接或断开连接时，Docker使用特定于操作系统的工具来管理基础网络基础架构（例如iptables在Linux上添加或删除网桥设备或配置规则） ）。这些细节应视为实施细节。让Docker为您管理用户定义的网络。</p></blockquote><h3 id="2-3-将容器连接到用户定义的网桥"><a href="#2-3-将容器连接到用户定义的网桥" class="headerlink" title="2.3 将容器连接到用户定义的网桥"></a>2.3 将容器连接到用户定义的网桥</h3><p>创建新容器时，可以指定一个或多个–network标志。本示例将Nginx容器连接到my-net网络。它还将容器中的端口80发布到Docker主机上的端口8080，以便外部客户端可以访问该端口。连接到my-net 网络的任何其他容器都可以访问该my-nginx容器上的所有端口，反之亦然。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker create --name my-nginx \</span><br><span class="line">  --network my-net \</span><br><span class="line">  --publish 8080:80 \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></tbody></table></figure><p>要将运行中的容器连接到现有的用户定义的网桥，请使用以下 docker network connect命令。以下命令将一个已经在运行的my-nginx容器连接 到一个已经存在的my-net网络：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect my-net my-nginx</span><br></pre></td></tr></tbody></table></figure><h3 id="2-4-断开容器与用户定义的网桥的连接"><a href="#2-4-断开容器与用户定义的网桥的连接" class="headerlink" title="2.4 断开容器与用户定义的网桥的连接"></a>2.4 断开容器与用户定义的网桥的连接</h3><p>要将运行中的容器与用户定义的网桥断开连接，请使用以下docker network disconnect命令。以下命令将my-nginx 容器与my-net网络断开连接。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network disconnect my-net my-nginx</span><br></pre></td></tr></tbody></table></figure><h3 id="2-5-使用IPv6"><a href="#2-5-使用IPv6" class="headerlink" title="2.5 使用IPv6"></a>2.5 使用IPv6</h3><p>如果需要对Docker容器的IPv6支持，则需要 在创建任何IPv6网络或分配容器IPv6地址之前，在Docker守护程序上启用该选项并重新加载其配置。</p><p>创建网络时，可以指定–ipv6标志以启用IPv6。您不能在默认bridge网络上有选择地禁用IPv6支持。</p><h3 id="2-6-启用从Docker容器到外界的转发"><a href="#2-6-启用从Docker容器到外界的转发" class="headerlink" title="2.6 启用从Docker容器到外界的转发"></a>2.6 启用从Docker容器到外界的转发</h3><p>默认情况下，来自连接到默认网桥网络的容器的流量 不会转发到外界。要启用转发，您需要更改两个设置。这些不是Docker命令，它们会影响Docker主机的内核。<br>    1. 配置Linux内核以允许IP转发。</p><pre><code><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.conf.all.forwarding=1</span><br></pre></td></tr></tbody></table></figure>2. 将策略的iptables FORWARD策略从更改DROP为 ACCEPT。<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -P FORWARD ACCEPT</span><br></pre></td></tr></tbody></table></figure></code></pre><p>这些设置不会在重新启动后持续存在，因此您可能需要将它们添加到启动脚本中。</p><h3 id="2-7-使用默认的桥接网络"><a href="#2-7-使用默认的桥接网络" class="headerlink" title="2.7 使用默认的桥接网络"></a>2.7 使用默认的桥接网络</h3><p>默认bridge网络被认为是Docker的遗留细节，不建议用于生产环境。对其进行配置是手动操作，并且存在 技术缺陷。</p><h4 id="将容器连接到默认网桥网络"><a href="#将容器连接到默认网桥网络" class="headerlink" title="将容器连接到默认网桥网络"></a>将容器连接到默认网桥网络</h4><p>如果未使用该–network标志指定网络，而是指定了网络驱动程序，则默认情况下，容器将连接到默认bridge网络。连接到默认bridge网络的容器只能通过IP地址进行通信，除非它们使用legacy –linkflag进行链接 。</p><h4 id="配置默认网桥网络"><a href="#配置默认网桥网络" class="headerlink" title="配置默认网桥网络"></a>配置默认网桥网络</h4><p>要配置默认bridge网络，请在中指定选项daemon.json。这是daemon.json指定了几个选项的示例。仅指定您需要自定义的设置。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"bip"</span>: <span class="string">"192.168.1.5/24"</span>,</span><br><span class="line">  <span class="string">"fixed-cidr"</span>: <span class="string">"192.168.1.5/25"</span>,</span><br><span class="line">  <span class="string">"fixed-cidr-v6"</span>: <span class="string">"2001:db8::/64"</span>,</span><br><span class="line">  <span class="string">"mtu"</span>: 1500,</span><br><span class="line">  <span class="string">"default-gateway"</span>: <span class="string">"10.20.1.1"</span>,</span><br><span class="line">  <span class="string">"default-gateway-v6"</span>: <span class="string">"2001:db8:abcd::89"</span>,</span><br><span class="line">  <span class="string">"dns"</span>: [<span class="string">"10.20.1.2"</span>,<span class="string">"10.20.1.3"</span>]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>重新启动Docker以使更改生效。</p><h4 id="将IPv6与默认桥接网络一起使用"><a href="#将IPv6与默认桥接网络一起使用" class="headerlink" title="将IPv6与默认桥接网络一起使用"></a>将IPv6与默认桥接网络一起使用</h4><p>如果将Docker配置为支持IPv6（请参阅使用IPv6），则还会自动为IPv6配置默认的桥接网络。与用户定义的网桥不同，您不能在默认网桥上有选择地禁用IPv6。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 容器服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门系列  3. Docker 容器的数据管理</title>
      <link href="/posts/38790.html"/>
      <url>/posts/38790.html</url>
      
        <content type="html"><![CDATA[<p>因为容器技术，重新构建并运行应用变得容易且快速，容器化应用基本是无需进一步配置的（已经打包好所有依赖并且已配置），只需PULL，然后Deploy（也许还需要一份docker-compose.yml）就好。我们无需太担心硬件，OS，库以及应用本身的潜在Bug导致应用挂掉，挂掉就挂掉吧，销毁然后重新运行一个新的就好，而且马上就可Ready。我们需要重点关心的是如何保存，备份，恢复应用产生的数据.</p><p>默认情况下，在容器内创建的所有文件都存储在可写容器层上。这意味着：</p><blockquote><ul><li>当该容器不再存在时，数据将不会持久保存，并且如果另一个进程需要它，则可能很难从容器中取出数据。</li><li>容器的可写层与运行容器的主机紧密耦合。您不能轻易地将数据移动到其他地方。</li><li>写入容器的可写层需要 存储驱动程序来管理文件系统。存储驱动程序使用Linux内核提供联合文件系统。与使用直接写入主机文件系统的数据卷相比，这种额外的抽象降低了性能 。</li></ul></blockquote><p><strong>Docker为容器提供了两个选项来将文件存储在主机中，以便即使容器停止后文件也可以持久存储：<code>数据卷</code>和 <code>绑定挂载</code>。如果您在Linux上运行Docker，则还可以使用<code>tmpfs</code>挂载。</strong></p><h2 id="1-Docker-数据挂载类型"><a href="#1-Docker-数据挂载类型" class="headerlink" title="1. Docker 数据挂载类型"></a>1. Docker 数据挂载类型</h2><p>无论您选择使用哪种类型的挂载，容器中的数据看起来都是相同的。它在容器的文件系统中显示为目录或单个文件。</p><p>区分数据卷，绑定挂载和tmpfs 挂载之间差异的一种简单方法就是考虑数据在Docker主机上实际存储的位置。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589544331/hexo/docker/types-of-mounts_i9si3p.png" alt="type of mounts"></p><ul><li><p><strong>数据卷（data volumes）</strong>: 存储在主机文件系统的一部分中，该文件系统由Docker管理（/var/lib/docker/volumes/在Linux上）。非Docker进程不应修改文件系统的这一部分。卷是在Docker中持久保存数据的最佳方法。</p></li><li><p><strong>绑定挂载（bind mounts）</strong>: 可以存储在主机系统上的任何位置。它们甚至可能是重要的系统文件或目录。Docker主机或Docker容器上的非Docker进程可以随时对其进行修改。</p></li><li><p><strong>临时挂载 （<code>tmpfs mounts</code>）</strong> 仅存储在主机系统的内存中，并且永远不会写入主机系统的文件系统中。</p></li></ul><h3 id="1-1-数据卷（data-volumes）"><a href="#1-1-数据卷（data-volumes）" class="headerlink" title="1.1 数据卷（data volumes）"></a>1.1 数据卷（data volumes）</h3><p><strong>数据卷</strong> 由Docker创建和管理。您可以使用<code>docker volume create</code>命令显式创建卷，或者Docker可以在容器或服务创建期间创建卷。</p><p>创建卷时，它存储在Docker主机上的目录中。将卷装入容器时，此目录就是装入容器的目录。这类似于绑定安装的工作方式，除了卷由Docker管理并且与主机的核心功能隔离。</p><p>已创建的数据卷可以同时安装到多个容器中。当没有正在运行的容器使用卷时，该卷仍可用于Docker，并且不会自动删除。您可以使用删除未使用的卷<code>docker volume prune</code>。</p><p>挂载卷时，它可以<strong>命名卷</strong>或<strong>匿名卷</strong>。匿名卷首次安装到容器中时，不会为其指定明确的名称，因此Docker为它们提供一个随机名称，该名称在给定的Docker主机中保证是唯一的。除了名称之外，命名卷和匿名卷的行为也相同。</p><p>卷还支持使用卷驱动程序，该驱动程序使您可以将数据存储在远程主机或云提供商上，以及其他可能性。</p><h4 id="1-1-1-数据卷-应用场景"><a href="#1-1-1-数据卷-应用场景" class="headerlink" title="1.1.1 数据卷 应用场景"></a>1.1.1 数据卷 应用场景</h4><ul><li><p>数据卷是将数据持久保存在Docker容器和服务中的首选方法。卷的一些用例包括：</p></li><li><p>在多个运行中的容器之间共享数据。如果未显式创建卷，则在首次将卷安装到容器中时将创建该卷。当该容器停止或卸下时，该卷仍然存在。多个容器可以同时装载相同的卷（可读写或只读）。仅在显式删除卷时才将它们删除。</p></li><li><p>不保证Docker主机具有给定的目录或文件结构时。卷可帮助您将Docker主机的配置与容器运行时解耦。</p></li><li><p>当您要将容器的数据存储在远程主机或云提供商上时，而不是在本地。</p></li><li><p>当您需要将数据从一个Docker主机备份，还原或迁移到另一个Docker主机时，卷是一个更好的选择。您可以停止使用该卷的容器，然后备份该卷的目录（例如/var/lib/docker/volumes/<volume-name>）。</p></li></ul><h3 id="1-2-绑定挂载（bind-mounts）"><a href="#1-2-绑定挂载（bind-mounts）" class="headerlink" title="1.2 绑定挂载（bind mounts）"></a>1.2 绑定挂载（bind mounts）</h3><p><strong>绑定挂载</strong> 自Docker早期以来可用。与卷相比，绑定安装的功能有限。使用绑定安装时，主机上的文件或目录将安装到容器中。文件或目录由主机上的完整路径引用。该文件或目录不需要在Docker主机上已经存在。如果尚不存在，则按需创建。绑定挂载性能非常好，但是它们依赖于具有特定目录结构的主机文件系统。如果要开发新的Docker应用程序，请考虑使用命名卷。您不能使用Docker CLI命令直接管理绑定安装。</p><blockquote><p><strong><code>绑定安装允许访问敏感文件</code></strong></p><p>使用绑定挂载的好与坏的一个副作用是，您可以通过 <strong>容器中</strong> 运行的进程来更改 <strong>主机</strong> 文件系统 ，包括创建，修改或删除重要的系统文件或目录。这是一项强大的功能，可能会带来安全隐患，包括影响主机系统上的非Docker进程。</p></blockquote><h4 id="1-2-1-绑定挂载-应用场景"><a href="#1-2-1-绑定挂载-应用场景" class="headerlink" title="1.2.1 绑定挂载 应用场景"></a>1.2.1 绑定挂载 应用场景</h4><p>通常情况下，应尽可能使用数据卷。绑定挂载适用于以下类型的应用场景：</p><ul><li><p>将配置文件从主机共享到容器。默认情况下，这就是Docker通过/etc/resolv.conf从主机安装到每个容器的方式为容器提供DNS解析的方式 。</p></li><li><p>在Docker主机上的开发环境和容器之间共享源代码或构建工件。例如，您可以将Maven target/ 目录安装到容器中，并且每次在Docker主机上构建Maven项目时，容器都可以访问重建的工件。<br><br>如果您以这种方式使用Docker进行开发，那么您的生产Dockerfile会将生产就绪的工件直接复制到映像中，而不是依赖于绑定安装。</p></li><li><p>当确保Docker主机的文件或目录结构与容器所需的绑定挂载一致时。</p></li></ul><h3 id="1-3-临时挂载（tmpfs-mounts）"><a href="#1-3-临时挂载（tmpfs-mounts）" class="headerlink" title="1.3 临时挂载（tmpfs mounts）"></a>1.3 临时挂载（<code>tmpfs mounts</code>）</h3><p><strong><code>临时挂载</code></strong> 不会持久化在磁盘上，无论是在Docker主机上还是在容器内。容器在其生存期内可以使用它来存储非持久状态或敏感信息。例如，在内部，群集服务使用<code>tmpfs</code>安装将机密安装到服务的容器中。</p><h4 id="1-3-1-临时挂载-应用场景"><a href="#1-3-1-临时挂载-应用场景" class="headerlink" title="1.3.1 临时挂载 应用场景"></a>1.3.1 临时挂载 应用场景</h4><p>当您不希望数据在主机上或容器内持久存在时，最好使用mount。当您的应用程序需要写入大量非持久状态数据时，这可能是出于安全原因或为了保护容器的性能。</p><hr><p><strong>绑定挂载和数据卷都可以使用<code>-v</code>或 <code>--volume</code>标志挂载到容器中，但是两者的语法略有不同。对于<code>tmpfs</code> 挂载，您可以使用该<code>--tmpfs</code>标志。但是，在Docker 17.06及更高版本中，建议将<code>--mount</code>标志用于容器和服务，用于<code>绑定挂载</code>，<code>数据卷</code>或<code>tmpfs挂载</code>，因为语法更清晰。</strong></p><p><strong>如果使用绑定挂载或数据卷，请牢记以下几点：</strong></p><ul><li><p>如果将空卷装载到存在文件或目录的容器中的目录中，则这些文件或目录将传播（复制）到该卷中。同样，如果启动一个容器并指定一个尚不存在的卷，则会为您创建一个空卷。这是预填充另一个容器所需数据的好方法。</p></li><li><p>如果将绑定挂载或非空卷挂载到存在某些文件或目录的容器中的目录中，则这些文件或目录会被挂载遮盖，就像您将文件保存到Linux主机上的/mnt目，然后再挂载USB驱动器到/mnt。/mnt的内容将由USB驱动器遮盖，直至USB驱动器的内容被卸载。被遮盖的文件不会被删除或更改，但是在挂载绑定挂载或数据卷时将无法访问。</p></li></ul><h2 id="2-使用数据卷"><a href="#2-使用数据卷" class="headerlink" title="2. 使用数据卷"></a>2. 使用数据卷</h2><p>数据卷是用于持久化由Docker容器生成和使用的数据的首选机制。尽管绑定挂载取决于主机的目录结构，但是卷完全由Docker管理。与绑定挂载相比，卷具有几个优点：</p><ul><li>与绑定挂载相比，卷更易于备份或迁移。</li><li>您可以使用Docker CLI命令或Docker API管理卷。</li><li>卷在Linux和Windows容器上均可工作。</li><li>可以在多个容器之间更安全地共享卷。</li><li>卷驱动程序使您可以将卷存储在远程主机或云提供商上，以加密卷内容或添加其他功能。</li><li>新卷的内容可以由容器预先填充。</li></ul><p>此外，与将数据持久保存在容器的可写层中相比，卷通常是更好的选择，因为卷不会增加使用卷的容器的大小，并且卷的内容存在于给定容器的生命周期之外。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589547649/hexo/docker/types-of-mounts-volume_yrodyo.png" alt="type of mounts volume"></p><p>如果您的容器生成非持久状态数据，请考虑使用 <code>tmpfs挂载</code>以避免将数据永久存储在任何地方，并通过避免写入容器的可写层来提高容器的性能。</p><p>卷使用rprivate绑定传播，并且绑定传播无法为卷配置。</p><h3 id="2-1-选择-v-或-–mount-标志"><a href="#2-1-选择-v-或-–mount-标志" class="headerlink" title="2.1 选择 -v 或 –mount 标志"></a>2.1 选择 -v 或 –mount 标志</h3><p>最初，<code>-v</code>or <code>--volume</code>标志用于独立容器，而<code>--mount</code>标志用于集群服务。但是，从Docker 17.06开始，您还可以使用<code>--mount</code>独立容器。总的来说， <code>--mount</code>是更明确和冗长的。最大的区别是该<code>-v</code> 语法将所有选项合并在一个字段中，而<code>--mount</code> 语法将它们分开。这是每个标志的语法比较。</p><blockquote><p>新用户应该尝试<code>--mount</code>比<code>--volume</code>语法更简单的语法。</p></blockquote><p>如果需要指定数据卷驱动程序选项，则必须使用<code>--mount</code>。</p><ul><li><p><code>-v</code>或<code>--volume</code>：由三个字段组成，以冒号（:）分隔。这些字段必须以正确的顺序排列，并且每个字段的含义不是立即显而易见的。</p><ul><li>对于命名卷，第一个字段是卷的名称，在给定的主机上是唯一的。对于匿名卷，将省略第一个字段。</li><li>第二个字段是文件或目录在容器中的挂载路径。</li><li>第三个字段是可选的，并且是逗号分隔的选项列表，例如<code>ro</code>。这些选项将在下面讨论。</li></ul></li><li><p><code>--mount</code>：包含多个键值对，以逗号分隔，每个键值对都由一个<code>&lt;key&gt;=&lt;value&gt;</code>元组组成。该<code>--mount</code>语法比<code>-v</code>或<code>--volume</code>更详细，但关键字的顺序并不重要，并且键值对的值更容易理解。</p><ul><li>该type挂载，其可以是bind，volume，或 tmpfs。本主题讨论卷，因此类型始终为 volume。</li><li>该source的挂载。对于命名卷，这是卷的名称。对于匿名卷，将省略此字段。可以指定为source 或src。</li><li>该destination作为其值，其中的文件或目录被挂载在容器的路径。可以指定为destination，dst或target。</li><li>该readonly选项（如果存在）会使绑定挂载以只读方式安装到容器中。</li><li>该volume-opt选项 可以多次指定的选项，采用键值对，该键值对由选项名称及其值组成。</li></ul></li></ul><blockquote><p><strong>从外部CSV解析器转义值</strong></p><p>如果您的卷驱动程序接受逗号分隔的列表作为选项，则必须从外部CSV解析器中转义该值。要对<code>volume-opt</code>进行转义，请用双引号（<code>&quot;</code>）包围，并用单引号（<code>&#39;</code>）包围整个mount参数。</p><p>例如，<code>local</code>驱动程序接受挂载选项作为<code>o</code>参数中逗号分隔的列表。此示例显示了转义列表的正确方法。</p><pre class=" language-bash"><code class="language-bash">$ docker <span class="token function">service</span> create \     --mount <span class="token string">'type=volume,src=&lt;VOLUME-NAME>,dst=&lt;CONTAINER-PATH>,volume-driver=local,volume-opt=type=nfs,volume-opt=device=&lt;nfs-server>:&lt;nfs-path>,"volume-opt=o=addr=&lt;nfs-address>,vers=4,soft,timeo=180,bg,tcp,rw"'</span>    --name myservice \    <span class="token operator">&lt;</span>IMAGE<span class="token operator">></span></code></pre></blockquote><p>下面的示例在可能的情况下同时显示<code>--mount</code>和<code>-v</code>语法，并 <code>--mount</code>首先展示。</p><p><strong><code>-v</code>和<code>--mount</code>之间的差异</strong></p><blockquote><p>与绑定装载相反，所有数据卷选项都可用于 –mount和-v标志。</p><p>将数据卷与服务一起使用时，仅–mount支持。</p></blockquote><h3 id="2-2-创建和管理卷"><a href="#2-2-创建和管理卷" class="headerlink" title="2.2 创建和管理卷"></a>2.2 创建和管理卷</h3><p>与绑定装载不同，您可以在任何容器范围之外创建和管理卷。</p><h4 id="2-2-1-创建一个卷："><a href="#2-2-1-创建一个卷：" class="headerlink" title="2.2.1 创建一个卷："></a>2.2.1 创建一个卷：</h4><pre class=" language-bash"><code class="language-bash">docker volume create my-vol</code></pre><p>运行结果如下</p><pre class=" language-bash"><code class="language-bash">➜ docker volume create my-volmy-vol</code></pre><h4 id="2-2-2-查询卷："><a href="#2-2-2-查询卷：" class="headerlink" title="2.2.2 查询卷："></a>2.2.2 查询卷：</h4><pre class=" language-bash"><code class="language-bash">docker volume <span class="token function">ls</span></code></pre><p>运行结果如下</p><pre class=" language-bash"><code class="language-bash">➜ docker volume <span class="token function">ls</span>DRIVER              VOLUME NAMElocal               my-vol</code></pre><h4 id="2-2-3-检查卷："><a href="#2-2-3-检查卷：" class="headerlink" title="2.2.3 检查卷："></a>2.2.3 检查卷：</h4><pre class=" language-bash"><code class="language-bash">docker volume inspect my-vol</code></pre><p>运行结果如下</p><pre class=" language-bash"><code class="language-bash">➜ docker volume inspect my-vol<span class="token punctuation">[</span>    <span class="token punctuation">{</span>        <span class="token string">"CreatedAt"</span><span class="token keyword">:</span> <span class="token string">"2020-05-15T14:31:20Z"</span>,        <span class="token string">"Driver"</span><span class="token keyword">:</span> <span class="token string">"local"</span>,        <span class="token string">"Labels"</span><span class="token keyword">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>,        <span class="token string">"Mountpoint"</span><span class="token keyword">:</span> <span class="token string">"/var/lib/docker/volumes/my-vol/_data"</span>,        <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"my-vol"</span>,        <span class="token string">"Options"</span><span class="token keyword">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>,        <span class="token string">"Scope"</span><span class="token keyword">:</span> <span class="token string">"local"</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><h4 id="2-2-4-删除卷："><a href="#2-2-4-删除卷：" class="headerlink" title="2.2.4 删除卷："></a>2.2.4 删除卷：</h4><pre class=" language-bash"><code class="language-bash">docker volume <span class="token function">rm</span> my-vol</code></pre><p>运行结果如下</p><pre class=" language-bash"><code class="language-bash">➜ docker volume <span class="token function">rm</span> my-volmy-vol</code></pre><h3 id="2-3-启动有数据卷的容器"><a href="#2-3-启动有数据卷的容器" class="headerlink" title="2.3 启动有数据卷的容器"></a>2.3 启动有数据卷的容器</h3><p>如果您使用尚不存在的卷启动容器，则Docker将为您创建该卷。以下示例将卷myvol2装入 /app/容器中。</p><p>下面的-v和–mount示例产生相同的结果。您不能同时运行它们，除非在运行第一个devtest容器和myvol2卷之后将其删除。</p><p><strong><code>--mount</code></strong></p><pre class=" language-bash"><code class="language-bash">docker run -d \  --name devtest \  --mount source<span class="token operator">=</span>myvol2,target<span class="token operator">=</span>/app \  nginx:latest</code></pre><p><strong><code>-v</code></strong></p><pre class=" language-bash"><code class="language-bash">docker run -d \  --name devtest \  -v myvol2:/app \  nginx:latest</code></pre><p>使用<code>docker inspect devtest</code>验证创建卷并安装正确。查找<code>Mounts</code>部分：</p><pre class=" language-bash"><code class="language-bash"><span class="token string">"Mounts"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                <span class="token string">"Type"</span><span class="token keyword">:</span> <span class="token string">"volume"</span>,                <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"myvol2"</span>,                <span class="token string">"Source"</span><span class="token keyword">:</span> <span class="token string">"/var/lib/docker/volumes/myvol2/_data"</span>,                <span class="token string">"Destination"</span><span class="token keyword">:</span> <span class="token string">"/app"</span>,                <span class="token string">"Driver"</span><span class="token keyword">:</span> <span class="token string">"local"</span>,                <span class="token string">"Mode"</span><span class="token keyword">:</span> <span class="token string">"z"</span>,                <span class="token string">"RW"</span><span class="token keyword">:</span> true,                <span class="token string">"Propagation"</span><span class="token keyword">:</span> <span class="token string">""</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>,</code></pre><p>这表明安装是一个卷，它显示了正确的源和目标，并且该安装是可读写的。</p><p>停止容器并移除数据卷。数据卷清除是一个单独的步骤。</p><pre class=" language-bash"><code class="language-bash">$ docker container stop devtest$ docker container <span class="token function">rm</span> devtest$ docker volume <span class="token function">rm</span> myvol2</code></pre><h3 id="2-4-启动有数据卷的服务"><a href="#2-4-启动有数据卷的服务" class="headerlink" title="2.4 启动有数据卷的服务"></a>2.4 启动有数据卷的服务</h3><p>启动服务并定义卷时，每个服务容器都使用其自己的本地卷。如果您使用local 卷驱动程序，则没有一个容器可以共享此数据，但是某些卷驱动程序确实支持共享存储。适用于AWS的Docker和适用于Azure的Docker均使用Cloudstor插件支持持久存储。</p><p>以下示例nginx以四个副本启动服务，每个副本使用一个称为的本地卷myvol2。</p><pre class=" language-bash"><code class="language-bash">docker <span class="token function">service</span> create -d \  --replicas<span class="token operator">=</span>4 \  --name devtest-service \  --mount source<span class="token operator">=</span>myvol2,target<span class="token operator">=</span>/app \  nginx:latest</code></pre><p>使用docker service ps devtest-service验证服务正在运行：</p><pre class=" language-bash"><code class="language-bash">➜ docker <span class="token function">service</span> <span class="token function">ps</span> devtest-serviceID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE           ERROR               PORTSwmvbs25isoi9        devtest-service.1   nginx:latest        docker-desktop      Running             Running 6 seconds ago6nai1zccabj2        devtest-service.2   nginx:latest        docker-desktop      Running             Running 6 seconds agoj1czn1oz2uk6        devtest-service.3   nginx:latest        docker-desktop      Running             Running 6 seconds agoullg50sx5g8p        devtest-service.4   nginx:latest        docker-desktop      Running             Running 6 seconds ago</code></pre><p>删除该服务，这将停止其所有任务：</p><pre class=" language-bash"><code class="language-bash">docker <span class="token function">service</span> <span class="token function">rm</span> devtest-service</code></pre><p>删除服务不会删除该服务创建的任何卷。卷删除是一个单独的步骤。</p><p><strong>服务的语法差异</strong></p><p>该docker service create命令不支持<code>-v</code>or <code>--volume</code>标志。将卷装入服务的容器时，必须使用该<code>--mount</code> 标志。</p><h3 id="2-5-使用容器填充数据卷"><a href="#2-5-使用容器填充数据卷" class="headerlink" title="2.5 使用容器填充数据卷"></a>2.5 使用容器填充数据卷</h3><p>如果如上所述启动一个容器来创建新的卷，并且该容器在要挂载的目录（例如/app/上面）中具有文件或目录，则目录的内容将复制到该卷中。然后，该容器将安装并使用该卷，并且使用该卷的其他容器也可以访问预填充的内容。</p><p>为了说明这一点，此示例启动一个nginx容器，并nginx-vol使用容器/usr/share/nginx/html目录的内容填充新卷，Nginx 在该 目录中存储其默认HTML内容。</p><p>在<code>--mount</code>和<code>-v</code>实施例具有相同的最终结果。</p><p><strong><code>--mount</code></strong></p><pre class=" language-bash"><code class="language-bash">docker run -d \  --name<span class="token operator">=</span>nginxtest \  --mount source<span class="token operator">=</span>nginx-vol,destination<span class="token operator">=</span>/usr/share/nginx/html \  nginx:latest</code></pre><p><strong><code>-v</code></strong></p><pre class=" language-bash"><code class="language-bash">docker run -d \  --name<span class="token operator">=</span>nginxtest \  -v nginx-vol:/usr/share/nginx/html \  nginx:latest</code></pre><p>运行这些示例中的任何一个之后，请运行以下命令以清理容器和卷。数据卷清除是一个单独的步骤。</p><pre class=" language-bash"><code class="language-bash">$ docker container stop nginxtest$ docker container <span class="token function">rm</span> nginxtest$ docker volume <span class="token function">rm</span> nginx-vol</code></pre><h3 id="2-6-使用只读数据卷"><a href="#2-6-使用只读数据卷" class="headerlink" title="2.6 使用只读数据卷"></a>2.6 使用只读数据卷</h3><p>对于某些开发应用程序，容器需要写入绑定安装，以便将更改传播回Docker主机。在其他时候，容器仅需要对数据的读取访问权限。请记住，多个容器可以挂载相同的卷，并且可以同时对其中一些容器进行读写安装，而对其他容器则同时进行只读安装。</p><p>此示例修改了上面的示例，但通过ro在容器中的安装点之后添加到（默认为空）选项列表中，将目录作为只读卷安装。如果存在多个选项，请用逗号分隔。</p><p>在<code>--mount</code>和<code>-v</code>实例有同样的结果。</p><p><strong><code>--mount</code></strong></p><pre class=" language-bash"><code class="language-bash">docker run -d \  --name<span class="token operator">=</span>nginxtest \  --mount source<span class="token operator">=</span>nginx-vol,destination<span class="token operator">=</span>/usr/share/nginx/html,readonly \  nginx:latest</code></pre><p><strong><code>-v</code></strong></p><pre class=" language-bash"><code class="language-bash">docker run -d \  --name<span class="token operator">=</span>nginxtest \  -v nginx-vol:/usr/share/nginx/html:ro \  nginx:latest</code></pre><p>使用docker inspect nginxtest验证只读mount正确创建。查找Mounts部分：</p><pre class=" language-bash"><code class="language-bash"><span class="token string">"Mounts"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>        <span class="token string">"Type"</span><span class="token keyword">:</span> <span class="token string">"volume"</span>,        <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"nginx-vol"</span>,        <span class="token string">"Source"</span><span class="token keyword">:</span> <span class="token string">"/var/lib/docker/volumes/nginx-vol/_data"</span>,        <span class="token string">"Destination"</span><span class="token keyword">:</span> <span class="token string">"/usr/share/nginx/html"</span>,        <span class="token string">"Driver"</span><span class="token keyword">:</span> <span class="token string">"local"</span>,        <span class="token string">"Mode"</span><span class="token keyword">:</span> <span class="token string">""</span>,        <span class="token string">"RW"</span><span class="token keyword">:</span> false,        <span class="token string">"Propagation"</span><span class="token keyword">:</span> <span class="token string">""</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span>,</code></pre><p>停止并移除容器，然后移除数据卷。卷删除是一个单独的步骤。</p><pre class=" language-bash"><code class="language-bash">$ docker container stop nginxtest$ docker container <span class="token function">rm</span> nginxtest$ docker volume <span class="token function">rm</span> nginx-vol</code></pre><h3 id="2-7-在机器之间共享数据"><a href="#2-7-在机器之间共享数据" class="headerlink" title="2.7 在机器之间共享数据"></a>2.7 在机器之间共享数据</h3><p>在构建容错应用程序时，您可能需要配置同一服务的多个副本才能访问相同的文件。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589637195/hexo/docker/volumes-shared-storage_vodngr.png" alt="volumes-shared-storage"></p><p>开发应用程序时，有几种方法可以实现此目的。一种是向您的应用程序添加逻辑，以将文件存储在像Amazon S3这样的云对象存储系统上。另一个方法是使用支持将文件写入外部存储系统（例如NFS或Amazon S3）的驱动程序来创建卷。</p><p>卷驱动程序使您可以从应用程序逻辑中抽象底层存储系统。例如，如果您的服务使用带有NFS驱动程序的卷，则可以更新服务以使用其他驱动程序（例如，将数据存储在云中），而无需更改应用程序逻辑。</p><h3 id="2-8-使用数据卷驱动器"><a href="#2-8-使用数据卷驱动器" class="headerlink" title="2.8 使用数据卷驱动器"></a>2.8 使用数据卷驱动器</h3><p>当使用创建卷时<code>docker volume create</code>，或者启动使用尚未创建的卷的容器时，可以指定卷驱动器。以下示例<code>vieux/sshfs</code>首先在创建独立卷时使用卷驱动程序，然后在启动创建新卷的容器时使用卷驱动程序。</p><h4 id="2-8-1-初始化设置"><a href="#2-8-1-初始化设置" class="headerlink" title="2.8.1 初始化设置"></a>2.8.1 初始化设置</h4><p>本示例假定您有两个节点，其中第一个是Docker主机，并且可以使用SSH连接到第二个。</p><p>在Docker主机上，安装vieux/sshfs插件：</p><pre class=" language-bash"><code class="language-bash">docker plugin <span class="token function">install</span> --grant-all-permissions vieux/sshfs</code></pre><h4 id="2-8-2-使用卷驱动程序创建卷"><a href="#2-8-2-使用卷驱动程序创建卷" class="headerlink" title="2.8.2 使用卷驱动程序创建卷"></a>2.8.2 使用卷驱动程序创建卷</h4><p>此示例指定了SSH密码，但是如果两个主机都配置了共享密钥，则可以省略该密码。每个卷驱动程序可能具有零个或多个可配置选项，每个选项都使用一个-o标志指定。</p><pre class=" language-bash"><code class="language-bash">docker volume create --driver vieux/sshfs \  -o sshcmd<span class="token operator">=</span>test@node2:/home/test \  -o password<span class="token operator">=</span>testpassword \  sshvolume</code></pre><h4 id="2-8-3-启动一个使用卷驱动程序创建卷的容器"><a href="#2-8-3-启动一个使用卷驱动程序创建卷的容器" class="headerlink" title="2.8.3 启动一个使用卷驱动程序创建卷的容器"></a>2.8.3 启动一个使用卷驱动程序创建卷的容器</h4><p>此示例指定了SSH密码，但是如果两个主机都配置了共享密钥，则可以省略该密码。每个卷驱动程序可能具有零个或多个可配置选项。<strong>如果卷驱动程序要求您传递选项，则必须使用该–mount标志而不是来安装卷-v</strong>。</p><pre class=" language-bash"><code class="language-bash">docker run -d \  --name sshfs-container \  --volume-driver vieux/sshfs \  --mount src<span class="token operator">=</span>sshvolume,target<span class="token operator">=</span>/app,volume-opt<span class="token operator">=</span>sshcmd<span class="token operator">=</span>test@node2:/home/test,volume-opt<span class="token operator">=</span>password<span class="token operator">=</span>testpassword \  nginx:latest</code></pre><h4 id="2-8-4-创建一个创建NFS卷的服务"><a href="#2-8-4-创建一个创建NFS卷的服务" class="headerlink" title="2.8.4 创建一个创建NFS卷的服务"></a>2.8.4 创建一个创建NFS卷的服务</h4><p>本示例说明了创建服务时如何创建NFS卷。本示例<code>10.0.0.10</code>用作NFS服务器和NFS服务器上<code>/var/docker-nfs</code>的导出目录。请注意，指定的音量驱动程序为<code>local</code>。</p><p><strong>NFSV3</strong></p><pre class=" language-bash"><code class="language-bash">docker <span class="token function">service</span> create -d \  --name nfs-service \  --mount <span class="token string">'type=volume,source=nfsvolume,target=/app,volume-driver=local,volume-opt=type=nfs,volume-opt=device=:/var/docker-nfs,volume-opt=o=addr=10.0.0.10'</span> \  nginx:latest</code></pre><p><strong>NFSV4</strong></p><pre class=" language-bash"><code class="language-bash">docker <span class="token function">service</span> create -d \    --name nfs-service \    --mount <span class="token string">'type=volume,source=nfsvolume,target=/app,volume-driver=local,volume-opt=type=nfs,volume-opt=device=:/,"volume-opt=o=10.0.0.10,rw,nfsvers=4,async"'</span> \    nginx:latest</code></pre><h3 id="2-9-备份，还原或迁移数据卷"><a href="#2-9-备份，还原或迁移数据卷" class="headerlink" title="2.9 备份，还原或迁移数据卷"></a>2.9 备份，还原或迁移数据卷</h3><p>卷对于备份，还原和迁移很有用。使用该 –volumes-from标志创建一个安装该卷的新容器。</p><h4 id="2-9-1-备份容器"><a href="#2-9-1-备份容器" class="headerlink" title="2.9.1 备份容器"></a>2.9.1 备份容器</h4><p>例如，在下一个命令中，我们：</p><ul><li>启动一个新容器并从该dbstore容器装入卷</li><li>将本地主机目录挂载为 /backup</li><li>将命令将dbdata卷的内容放到目录中的backup.tar文件中/backup。</li></ul><pre class=" language-bash"><code class="language-bash">docker run --rm --volumes-from dbstore -v <span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>:/backup ubuntu <span class="token function">tar</span> cvf /backup/backup.tar /dbdata</code></pre><p>当命令完成并且容器停止时，我们将获得<code>dbdata</code>卷的备份。</p><h4 id="2-9-2-从备份还原容器"><a href="#2-9-2-从备份还原容器" class="headerlink" title="2.9.2 从备份还原容器"></a>2.9.2 从备份还原容器</h4><p>使用刚刚创建的备份，您可以将其还原到同一容器或在其他位置创建的另一个容器。</p><p>例如，创建一个名为的新容器dbstore2：</p><pre class=" language-bash"><code class="language-bash">docker run -v /dbdata --name dbstore2 ubuntu /bin/bash</code></pre><p>然后将备份文件解压缩到新容器的数据卷中：</p><pre class=" language-bash"><code class="language-bash">docker run --rm --volumes-from dbstore2 -v <span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>:/backup ubuntu <span class="token function">bash</span> -c <span class="token string">"cd /dbdata &amp;&amp; tar xvf /backup/backup.tar --strip 1"</span></code></pre><p>您可以使用首选工具使用上述技术来自动执行备份，迁移和还原测试。</p><h3 id="2-10-删除卷"><a href="#2-10-删除卷" class="headerlink" title="2.10 删除卷"></a>2.10 删除卷</h3><p>删除容器后，Docker数据卷仍然存在。有两种类型的卷需要考虑：</p><ul><li><strong>命名卷</strong> 具有来自容器外部的特定来源，例如<code>awesome:/bar</code>。</li><li><strong>匿名卷</strong> 没有特定来源，因此在删除容器时，请指示Docker Engine守护程序将其删除。</li></ul><h4 id="2-10-1-删除匿名卷"><a href="#2-10-1-删除匿名卷" class="headerlink" title="2.10.1 删除匿名卷"></a>2.10.1 删除匿名卷</h4><p>要自动删除匿名卷，请使用该<code>--rm</code>选项。例如，此命令创建一个匿名<code>/foo</code>卷。删除容器后，Docker Engine会删除该<code>/foo</code>卷，但不会删除该<code>awesome</code>卷。</p><pre class=" language-bash"><code class="language-bash">docker run --rm -v /foo -v awesome:/bar busybox <span class="token function">top</span></code></pre><h4 id="2-10-2-删除所有卷"><a href="#2-10-2-删除所有卷" class="headerlink" title="2.10.2 删除所有卷"></a>2.10.2 删除所有卷</h4><p>要删除所有未使用的卷并释放空间：</p><pre class=" language-bash"><code class="language-bash">docker volume prune</code></pre><h2 id="3-使用绑定挂载"><a href="#3-使用绑定挂载" class="headerlink" title="3. 使用绑定挂载"></a>3. 使用绑定挂载</h2><p>自Docker诞生以来，绑定挂载就已经存在。与<code>卷</code>相比，绑定安装的功能有限。使用绑定安装时，主机上的文件或目录将安装到容器中。该文件或目录由主机上的完整或相对路径引用。相比之下，当您使用卷时，将在主机上的Docker的存储目录中创建一个新目录，并且Docker管理该目录的内容。</p><p>该文件或目录不需要在Docker主机上已经存在。如果尚不存在，则按需创建。绑定挂载性能非常好，但是它们依赖于具有特定目录结构的主机文件系统。如果要开发新的Docker应用程序，请考虑使用<code>命名卷</code>。您不能使用Docker CLI命令直接管理绑定安装。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589638340/hexo/docker/types-of-mounts-bind_rvrxbl.png" alt="types-of-mounts-bind"></p><h3 id="3-1-选择-v或–mount标志"><a href="#3-1-选择-v或–mount标志" class="headerlink" title="3.1 选择-v或–mount标志"></a>3.1 选择-v或–mount标志</h3><p>最初，-vor –volume标志用于独立容器，而–mount标志用于集群服务。但是，从Docker 17.06开始，您还可以使用–mount独立容器。总的来说， –mount是更明确和冗长的。最大的区别是该-v 语法将所有选项合并在一个字段中，而–mount 语法将它们分开。这是每个标志的语法比较。</p><blockquote><p><strong>提示</strong>：新用户应使用–mount语法。有经验的用户可能更熟悉-v或–volume语法，但建议使用–mount，因为研究表明它更易于使用。</p></blockquote><ul><li>-v或–volume：由三个字段组成，以冒号（:）分隔。这些字段必须以正确的顺序排列，并且每个字段的含义不是立即显而易见的。<ul><li>对于绑定挂载，第一个字段是主机上文件或目录的路径。</li><li>第二个字段是文件或目录在容器中的安装路径。</li><li>第三个字段是可选的，并且是用逗号分隔的选项，诸如列表ro，consistent，delegated，cached，z，和Z。这些选项将在下面讨论。</li></ul></li><li>–mount：包含多个键值对，以逗号分隔，每个键值对都由一个<key>=<value>元组组成。该–mount语法是更详细的比-v或–volume，但按键的顺序并不显著，并且标志的价值更容易理解。<ul><li>该类型挂载，其可以是bind，volume，或tmpfs。本次讨论绑定挂载，因此类型始终为bind。</li><li>该source的挂载。对于绑定挂载，这是Docker守护程序主机上文件或目录的路径。可以指定为source或 src。</li><li>该destination作为其值，其中的文件或目录被挂载在容器的路径。可以指定为destination，dst或target。</li><li>该readonly选项（如果存在）会使绑定安装以只读方式安装到容器中。</li><li>该bind-propagation选项（如果存在）将更改 绑定传播。可以是一个rprivate， private，rshared，shared，rslave，slave。</li><li>的consistency选项，如果存在，可以是一种consistent，delegated或cached。此设置仅适用于Mac的Docker桌面，在所有其他平台上将被忽略。</li><li>该–mount标志不支持z或没有Z用于修改selinux标签的选项。</li></ul></li></ul><p>下面的示例在可能的情况下同时显示–mount和-v语法，并 –mount首先展示。</p><p><strong><code>-v</code>和<code>--mount</code>行为之间的差异</strong></p><p>由于<code>-v</code>and <code>--volume</code>标志已经很长时间成为Docker的一部分，因此它们的行为无法更改。这意味着和之间存在一种不同的行为。-v–mount</p><p>如果您使用<code>-v</code>或<code>--volume</code>绑定安装Docker主机上尚不存在的文件或目录，请-v为您创建端点。<strong>始终将其创建为目录</strong>。</p><p>如果您使用–mount绑定贴装尚不泊坞窗主机上存在的文件或目录，码头工人也不会自动为您创建它，但会产生一个错误。</p><h3 id="3-2-使用绑定挂载启动容器"><a href="#3-2-使用绑定挂载启动容器" class="headerlink" title="3.2 使用绑定挂载启动容器"></a>3.2 使用绑定挂载启动容器</h3><p>考虑以下情况：您有一个目录source，并且在构建源代码时，工件会保存到另一个目录中source/target/。您希望这些工件可用于的容器/app/，并且希望每次在开发主机上构建源代码时，容器都可以访问新的构建。使用以下命令将target/ 目录绑定安装到您的容器中，位于/app/。从source目录中运行命令 。该$(pwd)子命令将扩展到Linux或macOS主机上的当前工作目录。</p><p>下面的–mount和-v示例产生相同的结果。您不能同时运行它们，除非devtest在运行第一个容器后删除容器。</p><p><strong><code>--mount</code></strong></p><pre class=" language-bash"><code class="language-bash">docker run -d \  -it \  --name devtest \  --mount type<span class="token operator">=</span>bind,source<span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target,target<span class="token operator">=</span>/app \  nginx:latest</code></pre><p><strong><code>-v</code></strong></p><pre class=" language-bash"><code class="language-bash">docker run -d \  -it \  --name devtest \  -v <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target:/app \  nginx:latest</code></pre><p>使用<code>docker inspect devtest</code>验证绑定安装正确创建。查找<code>Mounts</code>部分：</p><pre class=" language-bash"><code class="language-bash"><span class="token string">"Mounts"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>        <span class="token string">"Type"</span><span class="token keyword">:</span> <span class="token string">"bind"</span>,        <span class="token string">"Source"</span><span class="token keyword">:</span> <span class="token string">"/tmp/source/target"</span>,        <span class="token string">"Destination"</span><span class="token keyword">:</span> <span class="token string">"/app"</span>,        <span class="token string">"Mode"</span><span class="token keyword">:</span> <span class="token string">""</span>,        <span class="token string">"RW"</span><span class="token keyword">:</span> true,        <span class="token string">"Propagation"</span><span class="token keyword">:</span> <span class="token string">"rprivate"</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span>,</code></pre><p>这表明该坐骑是一个bind坐骑，它显示了正确的源和目标，表明该坐骑是可读写的，并且传播设置为rprivate。</p><p>停止容器：</p><pre class=" language-bash"><code class="language-bash">$ docker container stop devtest$ docker container <span class="token function">rm</span> devtest</code></pre><p><strong>挂载到容器上的非空目录中</strong></p><p>如果将绑定安装到容器上的非空目录中，则该目录的现有内容将被绑定安装遮盖。这可能是有益的，例如，当您要测试应用程序的新版本而不构建新映像时。但是，这也可能令人惊讶，并且此行为不同于docker volume的行为。</p><p>该示例被认为是极端的，但是用主机上的/usr/目录替换了容器目录的内容/tmp/。在大多数情况下，这将导致容器无法正常工作。</p><p>在–mount和-v实施例具有相同的最终结果。</p><p><strong><code>--mount</code></strong></p><pre class=" language-bash"><code class="language-bash">$ docker run -d \  -it \  --name broken-container \  --mount type<span class="token operator">=</span>bind,source<span class="token operator">=</span>/tmp,target<span class="token operator">=</span>/usr \  nginx:latestdocker: Error response from daemon: oci runtime error: container_linux.go:262:starting container process caused <span class="token string">"exec: \"nginx\": executable file not found in <span class="token variable">$PATH</span>"</span><span class="token keyword">.</span></code></pre><p><strong><code>-v</code></strong></p><pre class=" language-bash"><code class="language-bash">$ docker run -d \  -it \  --name broken-container \  -v /tmp:/usr \  nginx:latestdocker: Error response from daemon: oci runtime error: container_linux.go:262:starting container process caused <span class="token string">"exec: \"nginx\": executable file not found in <span class="token variable">$PATH</span>"</span><span class="token keyword">.</span></code></pre><p>容器已创建但未启动。去掉它：</p><pre class=" language-bash"><code class="language-bash">$ docker container <span class="token function">rm</span> broken-container</code></pre><h3 id="3-3-使用只读绑定挂载"><a href="#3-3-使用只读绑定挂载" class="headerlink" title="3.3 使用只读绑定挂载"></a>3.3 使用只读绑定挂载</h3><p>对于某些开发应用程序，容器需要写入绑定安装，因此更改将传播回Docker主机。在其他时间，容器仅需要读取访问权限。</p><p>此示例修改了上面的示例，但ro通过在容器中的安装点之后添加到（默认为空）选项列表中，将目录作为只读绑定安装进行安装。如果存在多个选项，请用逗号分隔。</p><p>在–mount和-v实例有同样的结果。</p><p><strong><code>--mount</code></strong></p><pre class=" language-bash"><code class="language-bash">$ docker run -d \  -it \  --name devtest \  --mount type<span class="token operator">=</span>bind,source<span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target,target<span class="token operator">=</span>/app,readonly \  nginx:latest</code></pre><p><strong><code>-v</code></strong></p><pre class=" language-bash"><code class="language-bash">$ docker run -d \  -it \  --name devtest \  -v <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target:/app:ro \  nginx:latest</code></pre><p>使用docker inspect devtest验证绑定安装正确创建。查找Mounts部分：</p><pre class=" language-bash"><code class="language-bash"><span class="token string">"Mounts"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>        <span class="token string">"Type"</span><span class="token keyword">:</span> <span class="token string">"bind"</span>,        <span class="token string">"Source"</span><span class="token keyword">:</span> <span class="token string">"/tmp/source/target"</span>,        <span class="token string">"Destination"</span><span class="token keyword">:</span> <span class="token string">"/app"</span>,        <span class="token string">"Mode"</span><span class="token keyword">:</span> <span class="token string">"ro"</span>,        <span class="token string">"RW"</span><span class="token keyword">:</span> false,        <span class="token string">"Propagation"</span><span class="token keyword">:</span> <span class="token string">"rprivate"</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span>,</code></pre><p>停止容器：</p><pre class=" language-bash"><code class="language-bash">$ docker container stop devtest$ docker container <span class="token function">rm</span> devtest</code></pre><h3 id="3-4-配置绑定传播"><a href="#3-4-配置绑定传播" class="headerlink" title="3.4 配置绑定传播"></a>3.4 配置绑定传播</h3><p><code>rprivate</code>对于绑定安装和卷，绑定传播默认为。它仅可用于绑定安装，并且只能在Linux主机上配置。绑定传播是一个高级主题，许多用户不需要配置它。</p><p>绑定传播是指是否可以将在给定绑定安装或命名卷中创建的安装传播到该安装的副本。考虑一个安装点<code>/mnt</code>，它也安装在上<code>/tmp</code>。传播设置控制是否<code>/tmp/a</code>可以在上安装底座<code>/mnt/a</code>。每个传播设置都有一个递归对点。在递归的情况下，请考虑将<code>/tmp/a</code>其也安装为<code>/foo</code>。传播设置控制是否<code>/mnt/a</code>和/或<code>/tmp/a</code>将存在。</p><br><table><thead><tr><th align="center">传播设置</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><code>shared</code></td><td align="left">原始安装的子安装暴露于副本安装，副本安装的子安装也传播到原始安装。</td></tr><tr><td align="center"><code>slave</code></td><td align="left">与共享安装类似，但仅在一个方向上。如果原始安装公开了子安装，则副本安装可以看到它。但是，如果副本安装公开了子安装，则原始安装看不到它。</td></tr><tr><td align="center"><code>private</code></td><td align="left">坐骑是私人的。其中的子安装不暴露于副本安装，副本安装的子安装也不暴露于原始安装。</td></tr><tr><td align="center"><code>rshared</code></td><td align="left">与共享相同，但传播也扩展到嵌套在任何原始或副本安装点中的安装点以及从这些安装点扩展。</td></tr><tr><td align="center"><code>rslave</code></td><td align="left">与从属服务器相同，但是传播也扩展到嵌套在任何原始或副本安装点中的安装点以及从这些安装点扩展。</td></tr><tr><td align="center"><code>rprivate</code></td><td align="left">默认值。与专用相同，这意味着原始或副本安装点内的任何安装点都不会向任一方向传播。</td></tr></tbody></table><br><br><p>在可以在安装点上设置绑定传播之前，主机文件系统需要已经支持绑定传播。</p><p>有关绑定传播的更多信息，请参见 Linux内核文档中的共享子树。</p><p>以下示例将target/目录两次安装到容器中，第二次安装同时设置了ro选项和rslave绑定传播选项。</p><p>在–mount和-v实例有同样的结果。</p><p><strong><code>--mount</code></strong></p><pre class=" language-bash"><code class="language-bash">$ docker run -d \  -it \  --name devtest \  --mount type<span class="token operator">=</span>bind,source<span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target,target<span class="token operator">=</span>/app \  --mount type<span class="token operator">=</span>bind,source<span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target,target<span class="token operator">=</span>/app2,readonly,bind-propagation<span class="token operator">=</span>rslave \  nginx:latest</code></pre><p><strong><code>-v</code></strong></p><pre class=" language-bash"><code class="language-bash">$ docker run -d \  -it \  --name devtest \  -v <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target:/app \  -v <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target:/app2:ro,rslave \  nginx:latest</code></pre><p>现在，如果您创建<code>/app/foo/</code>，它<code>/app2/foo/</code>也存在。</p><h3 id="3-5-配置selinux标签"><a href="#3-5-配置selinux标签" class="headerlink" title="3.5 配置selinux标签"></a>3.5 配置selinux标签</h3><p>如果使用selinux，则可以添加z或Z选项来修改要装入容器的主机文件或目录的selinux标签。这会影响主机本身上的文件或目录，并可能导致超出Docker范围的后果。</p><ul><li>该z选项指示绑定安装内容在多个容器之间共享。</li><li>该Z选项指示绑定安装内容是私有的且未共享。</li></ul><p>这些选项请格外小心。绑定安装系统目录（例如/home或/usr带有该Z选项）会使主机无法运行，并且您可能需要手动重新标记主机文件。</p><blockquote><p><strong>重要说明</strong>：将绑定安装与服务一起使用时，selinux标签（<code>:Z</code>和<code>:z</code>）以及将<code>:ro</code>被忽略。有关详细信息，请参见 <a href="https://github.com/moby/moby/issues/32579" target="_blank" rel="noopener"><code>moby / moby＃32579</code></a>。</p></blockquote><p>本示例设置z选项以指定多个容器可以共享绑定安装的内容：</p><p>无法使用该–mount标志修改selinux标签。</p><pre class=" language-bash"><code class="language-bash">$ docker run -d \  -it \  --name devtest \  -v <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target:/app:z \  nginx:latest</code></pre><h3 id="3-6-配置macOS的挂载一致性"><a href="#3-6-配置macOS的挂载一致性" class="headerlink" title="3.6 配置macOS的挂载一致性"></a>3.6 配置macOS的挂载一致性</h3><p>用于Mac的Docker桌面用于osxfs将从macOS共享的目录和文件传播到Linux VM。这种传播使这些目录和文件可用于在Mac上运行Docker Desktop的Docker容器。</p><p>默认情况下，这些共享是完全一致的，这意味着每次在macOS主机上或通过容器中的挂载进行写操作时，所做的更改都会刷新到磁盘上，以便共享中的所有参与者都具有完全一致的视图。在某些情况下，完全一致性可能会严重影响性能。Docker 17.05及更高版本引入了一些选项，可以针对每个容器，每个容器来调整一致性设置。提供以下选项：</p><ul><li><p><code>consistent</code>或<code>default</code>：如上所述，具有完全一致性的默认设置。</p></li><li><p><code>delegated</code>：容器运行时的挂载视图具有权威性。在主机上看到容器中所做的更新之前可能会有所延迟。</p></li><li><p><code>cached</code>：macOS主机的挂载视图具有权威性。在容器中可以看到主机上所做的更新，这可能会有所延迟。</p></li></ul><p>这些选项在除macOS之外的所有主机操作系统上均被完全忽略。</p><p>在–mount和-v实例有同样的结果。</p><p><strong><code>--mount</code></strong></p><pre class=" language-bash"><code class="language-bash">$ docker run -d \  -it \  --name devtest \  --mount type<span class="token operator">=</span>bind,source<span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target,destination<span class="token operator">=</span>/app,consistency<span class="token operator">=</span>cached \  nginx:latest</code></pre><p><strong><code>-v</code></strong></p><pre class=" language-bash"><code class="language-bash">$ docker run -d \  -it \  --name devtest \  -v <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>"</span>/target:/app:cached \  nginx:latest</code></pre><h2 id="3-使用tmpfs-挂载"><a href="#3-使用tmpfs-挂载" class="headerlink" title="3. 使用tmpfs 挂载"></a>3. 使用tmpfs 挂载</h2><p>数据卷和绑定挂载使您可以在主机和容器之间共享文件，以便即使容器停止后也可以保留数据。</p><p>如果您在Linux上运行Docker，则还有第三种选择：tmpfs挂载。当创建带有tmpfs安装架的容器时，该容器可以在该容器的可写层之外创建文件。</p><p>与卷和绑定挂载相反，tmpfs挂载是临时的，并且仅保留在主机内存中。当容器停止时，tmpfs挂载将被删除，并且在其中写入的文件将不会保留。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1590133898/hexo/docker/types-of-mounts-tmpfs_fpwsba.png" alt="types-of-mounts-tmpfs"></p><p>这对于在主机或容器可写层中临时存储您不想持久保存的敏感文件很有用。</p><h3 id="3-1-tmpfs安装的局限性"><a href="#3-1-tmpfs安装的局限性" class="headerlink" title="3.1 tmpfs安装的局限性"></a>3.1 tmpfs安装的局限性</h3><ul><li><p>与卷和绑定安装不同，您不能tmpfs在容器之间共享安装。</p></li><li><p>仅当您在Linux上运行Docker时，此功能才可用。</p></li></ul><h3 id="3-2-选择–tmpfs或–mount标志"><a href="#3-2-选择–tmpfs或–mount标志" class="headerlink" title="3.2 选择–tmpfs或–mount标志"></a>3.2 选择–tmpfs或–mount标志</h3><p>最初，该–tmpfs标志用于独立容器，而该–mount标志用于集群服务。但是，从Docker 17.06开始，您还可以使用–mount独立容器。总的来说， –mount是更明确和冗长的。最大的区别是该 –tmpfs标志不支持任何可配置的选项。</p><ul><li><p>–tmpfs：挂载tmpfs挂载而不允许您指定任何可配置的选项，并且只能与独立容器一起使用。</p></li><li><p>–mount：包含多个键值对，以逗号分隔，每个键值对都由一个<key>=<value>元组组成。该–mount语法比更详细–tmpfs：</p><ul><li>该type安装件，其可以是bind，volume，或 tmpfs。本主题讨论tmpfs，因此类型始终为 tmpfs。</li><li>的destination作为其值，其中的路径tmpfs安装被安装在容器中。可以指定为destination，dst或target。</li><li>在tmpfs-type和tmpfs-mode选项。请参阅 tmpfs选项。</li></ul></li></ul><p>下面的示例在可能的情况下同时显示–mount和–tmpfs语法，并–mount首先展示。</p><h4 id="–tmpfs和–mount行为之间的差异"><a href="#–tmpfs和–mount行为之间的差异" class="headerlink" title="–tmpfs和–mount行为之间的差异"></a>–tmpfs和–mount行为之间的差异</h4><ul><li>该–tmpfs标志不允许您指定任何可配置的选项。</li><li>该–tmpfs标志不能与群集服务一起使用。您必须使用–mount。</li></ul><h3 id="3-3-在容器中使用tmpfs挂载"><a href="#3-3-在容器中使用tmpfs挂载" class="headerlink" title="3.3 在容器中使用tmpfs挂载"></a>3.3 在容器中使用tmpfs挂载</h3><p>要tmpfs在容器中使用安装座，请使用–tmpfs标志，或将 –mount标志与type=tmpfs和destination选项一起使用。没有 source了tmpfs坐骑。以下示例在Nginx容器中的上创建一个tmpfs安装 /app。第一个示例使用–mount标志，第二个示例使用–tmpfs标志。</p><p><strong>–mount</strong></p><pre class=" language-bash"><code class="language-bash">$ docker run -d \  -it \  --name tmptest \  --mount type<span class="token operator">=</span>tmpfs,destination<span class="token operator">=</span>/app \  nginx:latest</code></pre><p><strong>–tmpfs</strong></p><pre class=" language-bash"><code class="language-bash">$ docker run -d \  -it \  --name tmptest \  --tmpfs /app \  nginx:latest</code></pre><p>tmpfs通过运行docker container inspect tmptest并查找以下Mounts部分来验证安装是否为安装：</p><pre class=" language-bash"><code class="language-bash"><span class="token string">"Tmpfs"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>    <span class="token string">"/app"</span><span class="token keyword">:</span> <span class="token string">""</span><span class="token punctuation">}</span>,</code></pre><p>卸下容器：</p><pre class=" language-bash"><code class="language-bash">$ docker container stop tmptest$ docker container <span class="token function">rm</span> tmptest</code></pre><h4 id="指定tmpfs选项"><a href="#指定tmpfs选项" class="headerlink" title="指定tmpfs选项"></a>指定tmpfs选项</h4><p>tmpfs安装允许两个配置选项，都不是必需的。如果需要指定这些选项，则必须使用该–mount标志，因为该–tmpfs标志不支持它们。<br><br></p><table><thead><tr><th align="center">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">tmpfs-size</td><td align="left">tmpfs安装的大小（以字节为单位）。默认情况下不受限制。</td></tr><tr><td align="center">tmpfs-mode</td><td align="left">tmpfs的文件模式（八进制）。例如700或0770。默认为1777或世界可写。</td></tr></tbody></table><br><p>以下示例将设置tmpfs-mode为1770，以使其在容器内不被世界范围内读取。</p><pre class=" language-bash"><code class="language-bash">docker run -d \  -it \  --name tmptest \  --mount type<span class="token operator">=</span>tmpfs,destination<span class="token operator">=</span>/app,tmpfs-mode<span class="token operator">=</span>1770 \  nginx:latest</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 入门系列  2. Docker 核心概念和安装使用</title>
      <link href="/posts/17098.html"/>
      <url>/posts/17098.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、-核心概念：镜像、容器与仓库"><a href="#一、-核心概念：镜像、容器与仓库" class="headerlink" title="一、 核心概念：镜像、容器与仓库"></a>一、 核心概念：镜像、容器与仓库</h2><p>Docker 主要包含三个核心概念，分别是镜像、容器和仓库，理解了这三个概念，就理解了 Docker 的整个生命周期。</p><ul><li><p><strong>镜像：</strong> Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p></li><li><p><strong>容器：</strong> 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间容器可以被。创建、启动、停止、删除和暂停等等，说到镜像与容器之间的关系，可以类比面向对象程序设计中的类和实例。</p></li><li><p><strong>仓库：</strong> 镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。一个 Docker Registry 中可以包含多个仓库；每个仓库可以包含多个标签；每个标签对应一个镜像，其中标签可以理解为镜像的版本号。</p></li></ul><h3 id="1-镜像（Image）-一个特殊的文件系统"><a href="#1-镜像（Image）-一个特殊的文件系统" class="headerlink" title="1. 镜像（Image）- 一个特殊的文件系统"></a>1. 镜像（Image）- 一个特殊的文件系统</h3><p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。</p><p><strong>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</strong> 镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589436136/hexo/docker/docker-filesystems-debian_l2gohi.png" alt="rootfs"></p><p>因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589436395/hexo/docker/docker-filesystems-multilayer_ug4ouk.png" alt="multilayer"></p><blockquote><p>Docker 设计时，就充分利用 Union FS的技术，将其设计为 分层存储的架构 。 镜像实际是由多层文件系统联合组成。</p></blockquote><p><strong>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</strong>比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p><strong>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</strong></p><p><strong>总的来说，你最需要记住这点：</strong></p><blockquote><p>在 Dockerfile 中， 每一条指令都会创建一个镜像层，继而会增加整体镜像的大小。</p></blockquote><p><code>镜像作为 Docker 最突出的创新之一，它变革了软件交付标准。理解镜像，对理解整个 Docker 的生命周期非常重要。</code></p><h3 id="2-容器（Container-镜像运行时的实体"><a href="#2-容器（Container-镜像运行时的实体" class="headerlink" title="2. 容器（Container) - 镜像运行时的实体"></a>2. 容器（Container) - 镜像运行时的实体</h3><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，<strong>容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等</strong> 。</p><p>Docker容器将应用程序和运行所需的所有内容封装到一个黑色沙箱中。这包括操作系统，应用程序代码，运行时，系统工具，系统库等.Docker容器是基于Docker镜像构建的。由于镜像是只读的，因此Docker在镜像的只读文件系统上添加了一个读写文件系统来创建容器。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589438151/hexo/docker/container_run_oaqnl8.png" alt="container"></p><p><strong>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</strong></p><blockquote><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p></blockquote><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据 ，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， 使用数据卷后，容器可以随意删除、重新 run ，数据却不会丢失。</p><h3 id="3-仓库（Repository）-集中存放镜像文件的地方"><a href="#3-仓库（Repository）-集中存放镜像文件的地方" class="headerlink" title="3. 仓库（Repository）- 集中存放镜像文件的地方"></a>3. 仓库（Repository）- 集中存放镜像文件的地方</h3><p><strong>Docker 仓库</strong> 是集中存放镜像文件的场所。镜像构建完成后，可以很容易的在当前宿主上运行，但是， <strong>如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务</strong>。</p><p>一个 <code>Docker Registry</code> 中可以包含多个 <strong>仓库（Repository）</strong>；每个仓库可以包含多个 <strong>标签（Tag）</strong>；每个标签对应一个镜像。所以说：<strong>镜像仓库是Docker用来集中存放镜像文件的地方类似于我们之前常用的代码仓库</strong>。</p><p>通常，<strong>一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本</strong> 。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p><p>仓库又可以分为两种形式：</p><ul><li><strong>public(公有仓库)</strong></li><li><strong>private(私有仓库)</strong></li></ul><h4 id="1-公有仓库"><a href="#1-公有仓库" class="headerlink" title="1) 公有仓库"></a>1) 公有仓库</h4><p><strong>Docker Registry 公开服务</strong> 是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公有仓库是官方的 <strong>Docker Hub</strong> ，这也是默认的 Registry，并拥有大量的高质量的官方镜像，网址为：<a href="https://hub.docker.com" target="_blank" rel="noopener">hub.docker.com</a> 。在国内访问Docker Hub 可能会比较慢国内也有一些云服务商提供类似于 <strong>Docker Hub</strong> 的公开服务。比如 <a href="https://www.163yun.com/product/repo" target="_blank" rel="noopener">网易云镜像服务</a>、<a href="https://www.daocloud.io" target="_blank" rel="noopener">DaoCloud 镜像市场</a>、<a href="https://cr.console.aliyun.com" target="_blank" rel="noopener">阿里云镜像库</a>等。</p><h4 id="2-私有仓库"><a href="#2-私有仓库" class="headerlink" title="2) 私有仓库"></a>2) 私有仓库</h4><p>除了使用公有仓库外，用户还可以在本地搭建<strong>私有仓库 Docker Registry</strong>。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/" target="_blank" rel="noopener">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。</p><p>开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 Docker Trusted Registry 中，提供了这些高级功能。</p><p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，Harbor 和 Sonatype Nexus。</p><h2 id="二、Docker-安装"><a href="#二、Docker-安装" class="headerlink" title="二、Docker 安装"></a>二、Docker 安装</h2><h3 id="1-在macOS系统安装"><a href="#1-在macOS系统安装" class="headerlink" title="1. 在macOS系统安装"></a>1. 在macOS系统安装</h3><h4 id="1-1-使用-Homebrew-安装"><a href="#1-1-使用-Homebrew-安装" class="headerlink" title="1.1 使用 Homebrew 安装"></a>1.1 使用 Homebrew 安装</h4><p>Homebrew 的 Cask 已经支持 Docker Desktop for Mac，因此可以很方便的使用 Homebrew Cask 来进行安装：</p><blockquote><p>安装 <strong>HomeBrew</strong></p></blockquote><pre class=" language-bash"><code class="language-bash">/bin/bash -c <span class="token string">"<span class="token variable"><span class="token variable">$(</span>curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh<span class="token variable">)</span></span>"</span></code></pre><blockquote><p>安装 <strong>Docker</strong></p></blockquote><pre class=" language-bash"><code class="language-bash">brew cask <span class="token function">install</span> docker</code></pre><h4 id="1-2-手动下载安装Docker"><a href="#1-2-手动下载安装Docker" class="headerlink" title="1.2 手动下载安装Docker"></a>1.2 手动下载安装Docker</h4><p>如果需要手动下载，请点击以下链接下载 <a href="https://download.docker.com/mac/stable/Docker.dmg" target="_blank" rel="noopener">Stable</a> 或 <a href="https://download.docker.com/mac/edge/Docker.dmg" target="_blank" rel="noopener">Edge</a> 版本的 Docker Desktop for Mac。</p><p>如同 macOS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将那只叫 Moby 的鲸鱼图标拖拽到 Application 文件夹即可（其间需要输入用户密码）。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589441197/hexo/docker/install-mac-dmg_fqqfsl.png" alt="docker dmg"></p><h4 id="1-3-运行Docker桌面服务"><a href="#1-3-运行Docker桌面服务" class="headerlink" title="1.3 运行Docker桌面服务"></a>1.3 运行Docker桌面服务</h4><p>从应用中找到 Docker 图标并点击运行。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589441564/hexo/docker/docker_re2pia.png" alt="docker run"></p><p>运行之后，会在右上角菜单栏看到多了一个鲸鱼图标，这个图标表明了 Docker 的运行状态。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589441905/hexo/docker/dock_tray_oqtgo9.png" alt="docker tray"></p><p>点击鲸鱼图标会弹出操作菜单</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589442071/hexo/docker/docker_menu_vj0sul.png" alt="docker menu"></p><p>启动终端后，通过命令可以检查安装后的 Docker 版本。</p><pre class=" language-bash"><code class="language-bash">➜ docker --versionDocker version 19.03.8, build afacb8b~ via ⬢ v12.16.3➜ docker-compose --versiondocker-compose version 1.25.5, build 8a1c60f6~ via ⬢ v12.16.3➜ kubectl versionClient Version: version.Info<span class="token punctuation">{</span>Major:<span class="token string">"1"</span>, Minor:<span class="token string">"16+"</span>, GitVersion:<span class="token string">"v1.16.6-beta.0"</span>, GitCommit:<span class="token string">"e7f962ba86f4ce7033828210ca3556393c377bcc"</span>, GitTreeState:<span class="token string">"clean"</span>, BuildDate:<span class="token string">"2020-01-15T08:26:26Z"</span>, GoVersion:<span class="token string">"go1.13.5"</span>, Compiler:<span class="token string">"gc"</span>, Platform:<span class="token string">"darwin/amd64"</span><span class="token punctuation">}</span>The connection to the server localhost:8080 was refused - did you specify the right host or port?</code></pre><p>通过鲸鱼图标弹出菜单的 About Docker Desktop </p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589442398/hexo/docker/version_etpeqx.png" alt="docker version"></p><h4 id="1-4-镜像加速"><a href="#1-4-镜像加速" class="headerlink" title="1.4 镜像加速"></a>1.4 镜像加速</h4><p>当然了，由于某些原因，国内从 Docker Hub 上拉取内容会非常缓慢，这个时候就可以配置一个镜像加速器环境。详情说明可以移步Docker 中国官方镜像加速，对于 macOS 用户，在任务栏点击应用图标 -&gt; Perferences… -&gt; Docker Engine -&gt; configuration file，在文件中填写加速器地址 <a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a> 即可。修改完成之后，点击 Apply &amp; Restart 即可。</p><p>国内很多云服务商都提供了国内加速器服务，例如：</p><ul><li>网易云加速器 <a href="https://hub-mirror.c.163.com" target="_blank" rel="noopener">https://hub-mirror.c.163.com</a></li><li>百度云加速器 <a href="https://mirror.baidubce.com" target="_blank" rel="noopener">https://mirror.baidubce.com</a></li><li>阿里云加速器 <a href="https://kfwkfulq.mirror.aliyuncs.com" target="_blank" rel="noopener">https://kfwkfulq.mirror.aliyuncs.com</a></li></ul><pre class=" language-bash"><code class="language-bash"><span class="token string">"registry-mirrors"</span><span class="token keyword">:</span> <span class="token punctuation">[</span><span class="token string">"https://registry.docker-cn.com"</span><span class="token punctuation">]</span></code></pre><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589449037/hexo/docker/mirrors_umiscp.png" alt="mirrors"></p><h2 id="三、-镜像使用"><a href="#三、-镜像使用" class="headerlink" title="三、 镜像使用"></a>三、 镜像使用</h2><p>Docker 使用 C/S 结构，即客户端/服务器体系结构。 Docker 客户端与 Docker 服务器进行交互，Docker服务端负责构建、运行和分发 Docker 镜像。 Docker 客户端和服务端可以运行在一台机器上，也可以通过 RESTful 、 stock 或网络接口与远程 Docker 服务端进行通信。</p><blockquote><p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p></blockquote><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589457087/hexo/docker/Docker-service_dqbfjj.jpg" alt="docker"></p><p><strong>这张图展示了 Docker 客户端、服务端和 Docker 仓库（即 Docker Hub 和 Docker Cloud ），默认情况下Docker 会在 Docker 中央仓库寻找镜像文件，这种利用仓库管理镜像的设计理念类似于 Git ，当然这个仓库是可以通过修改配置来指定的，甚至我们可以创建我们自己的私有仓库。</strong></p><h3 id="1-Docker的简单运用—ubuntu-18-04"><a href="#1-Docker的简单运用—ubuntu-18-04" class="headerlink" title="1. Docker的简单运用—ubuntu:18.04"></a>1. Docker的简单运用—ubuntu:18.04</h3><h4 id="1-获取镜像"><a href="#1-获取镜像" class="headerlink" title="1) 获取镜像"></a>1) 获取镜像</h4><p>之前提到过，Docker Hub 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p><p>从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为：</p><pre class=" language-bash"><code class="language-bash">docker pull <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>Docker Registry 地址<span class="token punctuation">[</span>:端口号<span class="token punctuation">]</span>/<span class="token punctuation">]</span>仓库名<span class="token punctuation">[</span>:标签<span class="token punctuation">]</span></code></pre><p>具体的选项可以通过 docker pull –help 命令看到，这里我们说一下镜像名称的格式。</p><ul><li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub。</li><li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li></ul><p>直接运行下面的命令，将名为 <code>ubuntu:18.04</code> 的 image 文件从仓库抓取到本地</p><pre class=" language-bash"><code class="language-bash">docker pull ubuntu:18.04</code></pre><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。</p><blockquote><p>运行结果如下</p></blockquote><pre class=" language-bash"><code class="language-bash">➜ docker pull ubuntu:18.0418.04: Pulling from library/ubuntu23884877105a: Pull completebc38caa0f5b9: Pull complete2910811b6c42: Pull complete36505266dcc6: Pull completeDigest: sha256:3235326357dfb65f1781dbc4df3b834546d8bf914e82cce58e6e6b676e23ce8fStatus: Downloaded newer image <span class="token keyword">for</span> ubuntu:18.04docker.io/library/ubuntu:18.04</code></pre><p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 sha256 的摘要，以确保下载一致性。</p><h4 id="2-列出镜像"><a href="#2-列出镜像" class="headerlink" title="2) 列出镜像"></a>2) 列出镜像</h4><p>要想列出已经下载下来的镜像，可以使用 docker image ls 命令。</p><pre class=" language-bash"><code class="language-bash">docker image <span class="token function">ls</span></code></pre><blockquote><p>运行结果如下</p></blockquote><pre class=" language-bash"><code class="language-bash">➜ docker image <span class="token function">ls</span> -aREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               c3c304cb4f22        2 weeks ago         64.2MBhello-world         latest              bf756fb1ae65        4 months ago        13.3kB</code></pre><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p><p>其中仓库名、标签在之前的基础概念章节已经介绍过了。<strong><code>镜像 ID</code></strong> 则是镜像的唯一标识，一个镜像可以对应多个 标签。因此，在上面的例子中，我们可以看到 ubuntu:18.04 和 ubuntu:latest 拥有相同的 ID，因为它们对应的是同一个镜像。</p><h4 id="3-运行镜像"><a href="#3-运行镜像" class="headerlink" title="3) 运行镜像"></a>3) 运行镜像</h4><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 ubuntu:18.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。</p><p>执行以下命令 运行镜像</p><pre class=" language-bash"><code class="language-bash">docker run -it --rm ubuntu:18.04 <span class="token function">bash</span></code></pre><blockquote><p>运行结果如下</p></blockquote><pre class=" language-bash"><code class="language-bash">➜ docker run -it --rm ubuntu:18.04 <span class="token function">bash</span>root@3a5e608746e1:/<span class="token comment" spellcheck="true"># cat /etc/os-release</span>NAME<span class="token operator">=</span><span class="token string">"Ubuntu"</span>VERSION<span class="token operator">=</span><span class="token string">"18.04.4 LTS (Bionic Beaver)"</span>ID<span class="token operator">=</span>ubuntuID_LIKE<span class="token operator">=</span>debianPRETTY_NAME<span class="token operator">=</span><span class="token string">"Ubuntu 18.04.4 LTS"</span>VERSION_ID<span class="token operator">=</span><span class="token string">"18.04"</span>HOME_URL<span class="token operator">=</span><span class="token string">"https://www.ubuntu.com/"</span>SUPPORT_URL<span class="token operator">=</span><span class="token string">"https://help.ubuntu.com/"</span>BUG_REPORT_URL<span class="token operator">=</span><span class="token string">"https://bugs.launchpad.net/ubuntu/"</span>PRIVACY_POLICY_URL<span class="token operator">=</span><span class="token string">"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"</span>VERSION_CODENAME<span class="token operator">=</span>bionicUBUNTU_CODENAME<span class="token operator">=</span>bionicroot@3a5e608746e1:/<span class="token comment" spellcheck="true">#</span></code></pre><p><code>docker run</code> 就是运行容器的命令，我们这里简要的说明一下上面用到的参数。</p><ul><li>-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li>–rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。</li><li>ubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。</li><li>bash：放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash。</li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <strong>Ubuntu 18.04.1 LTS</strong> 系统。</p><p>最后我们通过 exit 退出了这个容器。</p><h4 id="4-删除本地镜像"><a href="#4-删除本地镜像" class="headerlink" title="4) 删除本地镜像"></a>4) 删除本地镜像</h4><p>如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为：</p><pre class=" language-bash"><code class="language-bash">docker image <span class="token function">rm</span> <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token operator">&lt;</span>镜像1<span class="token operator">></span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>镜像2<span class="token operator">></span> <span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre><p>用 ID、镜像名、摘要删除镜像</p><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p><p>比如我们有下列镜像：</p><pre class=" language-bash"><code class="language-bash">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               c3c304cb4f22        2 weeks ago         64.2MBhello-world         latest              bf756fb1ae65        4 months ago        13.3kB</code></pre><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用<code>长 ID</code>，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除 ubuntu 镜像，可以执行：</p><pre class=" language-bash"><code class="language-bash">➜ docker image <span class="token function">rm</span> c3c304cb4f22Untagged: ubuntu:18.04Untagged: ubuntu@sha256:3235326357dfb65f1781dbc4df3b834546d8bf914e82cce58e6e6b676e23ce8fDeleted: sha256:c3c304cb4f22ceb8a6fcc29a0cd6d3e4383ba9eb9b5fb552f87de7c0ba99edacDeleted: sha256:82751c4dcc36265daceeee0abd938806b591eb66700863186377348c96e8aeadDeleted: sha256:24b16cac34768092d57cdb429a12de6c9ee870a3724d70098a189ae0ac344c42Deleted: sha256:b1daff3b271fede2bec31812c398e28952f792935f608e467271cdfaccab7de2Deleted: sha256:b7f7d2967507ba709dbd1dd0426a5b0cdbe1ff936c131f8958c8d0f910eea19e</code></pre><p>我们也可以用镜像名，也就是 &lt;仓库名&gt;:&lt;标签&gt;，来删除镜像。</p><pre class=" language-bash"><code class="language-bash">➜ docker image <span class="token function">rm</span> ubuntu:18.04Untagged: ubuntu:18.04Untagged: ubuntu@sha256:3235326357dfb65f1781dbc4df3b834546d8bf914e82cce58e6e6b676e23ce8fDeleted: sha256:c3c304cb4f22ceb8a6fcc29a0cd6d3e4383ba9eb9b5fb552f87de7c0ba99edacDeleted: sha256:82751c4dcc36265daceeee0abd938806b591eb66700863186377348c96e8aeadDeleted: sha256:24b16cac34768092d57cdb429a12de6c9ee870a3724d70098a189ae0ac344c42Deleted: sha256:b1daff3b271fede2bec31812c398e28952f792935f608e467271cdfaccab7de2Deleted: sha256:b7f7d2967507ba709dbd1dd0426a5b0cdbe1ff936c131f8958c8d0f910eea19e</code></pre><p>当然，更精确的是使用 镜像摘要 删除镜像。</p><pre class=" language-bash"><code class="language-bash">➜ docker image <span class="token function">ls</span> --digestsREPOSITORY          TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZEhello-world         latest              sha256:6a65f928fb91fcfbc963f7aa6d57c8eeb426ad9a20c7ee045538ef34847f44f1   bf756fb1ae65        4 months ago        13.3kB➜ docker image <span class="token function">rm</span> hello-world:latest@sha256:6a65f928fb91fcfbc963f7aa6d57c8eeb426ad9a20c7ee045538ef34847f44f1Untagged: hello-world:latest@sha256:6a65f928fb91fcfbc963f7aa6d57c8eeb426ad9a20c7ee045538ef34847f44f1</code></pre><h2 id="四、操作容器"><a href="#四、操作容器" class="headerlink" title="四、操作容器"></a>四、操作容器</h2><h3 id="1-查看容器"><a href="#1-查看容器" class="headerlink" title="1. 查看容器"></a>1. 查看容器</h3><p>我们要想知道当前有哪些容器在运行，我们可以用如下命令：<br><strong>docker ps -a</strong> <code>-a</code> 是查看当前所有正在运行的容器</p><pre class=" language-bash"><code class="language-bash">docker <span class="token function">ps</span> -a</code></pre><blockquote><p>运行结果如下</p></blockquote><pre class=" language-bash"><code class="language-bash">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES45448b240593        hello-world         <span class="token string">"/hello"</span>            9 minutes ago       Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 9 minutes ago                       keen_pasteur</code></pre><h3 id="2-启动容器"><a href="#2-启动容器" class="headerlink" title="2. 启动容器"></a>2. 启动容器</h3><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p><h4 id="2-1-新建并启动"><a href="#2-1-新建并启动" class="headerlink" title="2.1 新建并启动"></a>2.1 新建并启动</h4><p>所需要的命令主要为 docker run。</p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><pre class=" language-bash"><code class="language-bash">➜ docker run ubuntu:18.04 /bin/echo <span class="token string">'Hello world'</span>Hello world</code></pre><p>这跟在本地直接执行 /bin/echo ‘hello world’ 几乎感觉不出任何区别。</p><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><pre class=" language-bash"><code class="language-bash">➜ docker run -t -i ubuntu:18.04 /bin/bashroot@c0a95c27382a:/<span class="token comment" spellcheck="true">#</span></code></pre><p>其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。<br>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><pre class=" language-bash"><code class="language-bash">➜ docker run -t -i ubuntu:18.04 /bin/bashroot@c0a95c27382a:/<span class="token comment" spellcheck="true"># pwd</span>/root@c0a95c27382a:/<span class="token comment" spellcheck="true"># ls</span>bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  varroot@c0a95c27382a:/<span class="token comment" spellcheck="true">#</span></code></pre><p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h4 id="2-2-启动已终止容器"><a href="#2-2-启动已终止容器" class="headerlink" title="2.2 启动已终止容器"></a>2.2 启动已终止容器</h4><p>可以利用 docker container start 命令，直接将一个已经终止的容器启动运行。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 ps 或 top 来查看进程信息。</p><pre class=" language-bash"><code class="language-bash">root@b0f1a106dcdf:/<span class="token comment" spellcheck="true"># ps</span>  PID TTY          TIME CMD    1 pts/0    00:00:00 <span class="token function">bash</span>   11 pts/0    00:00:00 <span class="token function">ps</span>root@b0f1a106dcdf:/<span class="token comment" spellcheck="true">#</span></code></pre><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><h3 id="3-守护态运行"><a href="#3-守护态运行" class="headerlink" title="3. 守护态运行"></a>3. 守护态运行</h3><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。</p><pre class=" language-bash"><code class="language-bash">➜ docker run ubuntu:18.04 /bin/sh -c <span class="token string">"while true; do echo hello world; sleep 1; done"</span>hello worldhello worldhello worldhello world</code></pre><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p><p>如果使用了 -d 参数运行容器。</p><pre class=" language-bash"><code class="language-bash">➜ docker run -d ubuntu:18.04 /bin/sh -c <span class="token string">"while true; do echo hello world; sleep 1; done"</span>f8849adf1f3ce58981c95142abc65729da41b3b5a4e89edb2d0a8c5ac967f171~ via ⬢ v12.16.3➜</code></pre><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 docker logs 查看)。</p><p><strong>注： 容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。</strong></p><p>使用 -d 参数启动后会返回一个唯一的 id，也可以通过 docker container ls 命令来查看容器信息。</p><pre class=" language-bash"><code class="language-bash">➜ docker container <span class="token function">ls</span>CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS               NAMESf8849adf1f3c        ubuntu:18.04        <span class="token string">"/bin/sh -c 'while t…"</span>   About a minute ago   Up About a minute                       funny_matsumotoc0a95c27382a        ubuntu:18.04        <span class="token string">"/bin/bash"</span>              9 minutes ago        Up 4 minutes                            musing_margulis</code></pre><p>要获取容器的输出信息，可以通过 docker container logs 命令。</p><pre class=" language-bash"><code class="language-bash">➜ docker container logs f8849adf1f3chello worldhello worldhello worldhello worldhello worldhello world<span class="token punctuation">..</span>.</code></pre><h3 id="4-终止容器"><a href="#4-终止容器" class="headerlink" title="4. 终止容器"></a>4. 终止容器</h3><p>可以使用 docker container stop 来终止一个运行中的容器。</p><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p><p>例如对于上一章节中只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。</p><p>终止状态的容器可以用 docker container ls -a 命令看到。例如</p><pre class=" language-bash"><code class="language-bash">➜ docker container <span class="token function">ls</span> -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMESf8849adf1f3c        ubuntu:18.04        <span class="token string">"/bin/sh -c 'while t…"</span>   4 minutes ago       Up 4 minutes                                    funny_matsumoto208d3180e5ca        ubuntu:18.04        <span class="token string">"/bin/sh -c 'while t…"</span>   5 minutes ago       Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 5 minutes ago                        hardcore_dubinskyb0f1a106dcdf        ubuntu:18.04        <span class="token string">"/bin/bash"</span>              7 minutes ago       Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 5 minutes ago                        naughty_lumierec0a95c27382a        ubuntu:18.04        <span class="token string">"/bin/bash"</span>              12 minutes ago      Up 8 minutes                                    musing_margulis1b10a73accd8        ubuntu:18.04        <span class="token string">"/bin/echo 'Hello wo…"</span>   13 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 8 minutes ago                        eager_napier37c02b640650        ubuntu:18.04        <span class="token string">"/bin/echo 'Hello wo…"</span>   13 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 13 minutes ago                       confident_leavitt</code></pre><p>处于终止状态的容器，可以通过 docker container start 命令来重新启动。</p><p>此外，docker container restart 命令会将一个运行态的容器终止，然后再重新启动它。</p><h3 id="5-进入容器"><a href="#5-进入容器" class="headerlink" title="5. 进入容器"></a>5. 进入容器</h3><p>在使用 -d 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令，原因会在下面说明。</p><h4 id="5-1-attach-命令"><a href="#5-1-attach-命令" class="headerlink" title="5.1 attach 命令"></a>5.1 attach 命令</h4><p>下面示例如何使用 docker attach 命令。</p><pre class=" language-bash"><code class="language-bash">➜ docker run -dit ubuntudd8d472bb3b30ba6ab4a230d5734a97c61d0205d8d09ac080c88d3ace0a2fffd~ via ⬢ v12.16.3➜ docker container <span class="token function">ls</span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESdd8d472bb3b3        ubuntu              <span class="token string">"/bin/bash"</span>         7 seconds ago       Up 6 seconds                            optimistic_pasteur~ via ⬢ v12.16.3➜ docker attach dd8d472bb3b3root@dd8d472bb3b3:/<span class="token comment" spellcheck="true">#</span></code></pre><p>注意： 如果从这个 stdin 中 exit，会导致容器的停止。</p><h4 id="5-2-exec-命令"><a href="#5-2-exec-命令" class="headerlink" title="5.2 exec 命令"></a>5.2 exec 命令</h4><p>docker exec 后边可以跟多个参数，这里主要说明 -i -t 参数。</p><p>只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><pre class=" language-bash"><code class="language-bash">➜ docker run -dit ubuntuc9ca08210d46abaee7228c4541f164908063cbd681c4aa541fe4e060da532d45~ via ⬢ v12.16.3➜ docker container <span class="token function">ls</span>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESc9ca08210d46        ubuntu              <span class="token string">"/bin/bash"</span>         6 seconds ago       Up 6 seconds                            pedantic_albattani~ via ⬢ v12.16.3➜ docker <span class="token function">exec</span> -i c9ca <span class="token function">bash</span><span class="token function">ls</span>binbootdevetchomeliblib32lib64libx32mediamntoptprocrootrunsbinsrvsystmpusrvar^C~ via ⬢ v12.16.3 took 41s➜ docker <span class="token function">exec</span> -it c9ca <span class="token function">bash</span>root@c9ca08210d46:/<span class="token comment" spellcheck="true">#</span></code></pre><p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 docker exec 的原因。</p><h3 id="6-容器的导出和导入"><a href="#6-容器的导出和导入" class="headerlink" title="6. 容器的导出和导入"></a>6. 容器的导出和导入</h3><h4 id="6-1-导出容器"><a href="#6-1-导出容器" class="headerlink" title="6.1 导出容器"></a>6.1 导出容器</h4><p>如果要导出本地某个容器，可以使用 docker export 命令。</p><pre class=" language-bash"><code class="language-bash">➜ docker <span class="token function">ps</span> -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                       PORTS               NAMESc9ca08210d46        ubuntu              <span class="token string">"/bin/bash"</span>              5 minutes ago       Up 5 minutes                                     pedantic_albattanidd8d472bb3b3        ubuntu              <span class="token string">"/bin/bash"</span>              8 minutes ago       Exited <span class="token punctuation">(</span>127<span class="token punctuation">)</span> 6 minutes ago                       optimistic_pasteur208d3180e5ca        ubuntu:18.04        <span class="token string">"/bin/sh -c 'while t…"</span>   17 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 17 minutes ago                        hardcore_dubinskyb0f1a106dcdf        ubuntu:18.04        <span class="token string">"/bin/bash"</span>              19 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 17 minutes ago                        naughty_lumiere1b10a73accd8        ubuntu:18.04        <span class="token string">"/bin/echo 'Hello wo…"</span>   26 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 20 minutes ago                        eager_napier37c02b640650        ubuntu:18.04        <span class="token string">"/bin/echo 'Hello wo…"</span>   26 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 26 minutes ago                        confident_leavitt~ via ⬢ v12.16.3➜ docker <span class="token function">export</span> 37c02b640650 <span class="token operator">></span> ubuntu.tar</code></pre><p>这样将导出容器快照到本地文件。</p><h4 id="6-1-导入容器"><a href="#6-1-导入容器" class="headerlink" title="6.1 导入容器"></a>6.1 导入容器</h4><p>可以使用 docker import 从容器快照文件中再导入为镜像，例如</p><pre class=" language-bash"><code class="language-bash">➜ <span class="token function">cat</span> ubuntu.tar <span class="token operator">|</span> docker <span class="token function">import</span> - test/ubuntu:v1.0sha256:d21f5263937d78928f78d3c76268783e930a989255fbc5db09453deabd45c537~ via ⬢ v12.16.3 took 2s➜ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEtest/ubuntu         v1.0                d21f5263937d        9 seconds ago       64.2MBubuntu              latest              1d622ef86b13        2 weeks ago         73.9MBubuntu              18.04               c3c304cb4f22        2 weeks ago         64.2MBhello-world         latest              bf756fb1ae65        4 months ago        13.3kB</code></pre><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><pre class=" language-bash"><code class="language-bash">docker <span class="token function">import</span> http://example.com/exampleimage.tgz example/imagerepo</code></pre><p>注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p><h3 id="6-删除容器"><a href="#6-删除容器" class="headerlink" title="6. 删除容器"></a>6. 删除容器</h3><h4 id="6-1-删除容器"><a href="#6-1-删除容器" class="headerlink" title="6.1 删除容器"></a>6.1 删除容器</h4><p>可以使用 docker container rm 来删除一个处于终止状态的容器。例如</p><pre class=" language-bash"><code class="language-bash">➜ docker <span class="token function">ps</span> -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                        PORTS               NAMESc9ca08210d46        ubuntu              <span class="token string">"/bin/bash"</span>              10 minutes ago      Up 10 minutes                                     pedantic_albattanidd8d472bb3b3        ubuntu              <span class="token string">"/bin/bash"</span>              12 minutes ago      Exited <span class="token punctuation">(</span>127<span class="token punctuation">)</span> 10 minutes ago                       optimistic_pasteur208d3180e5ca        ubuntu:18.04        <span class="token string">"/bin/sh -c 'while t…"</span>   22 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 21 minutes ago                         hardcore_dubinskyb0f1a106dcdf        ubuntu:18.04        <span class="token string">"/bin/bash"</span>              24 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 22 minutes ago                         naughty_lumiere1b10a73accd8        ubuntu:18.04        <span class="token string">"/bin/echo 'Hello wo…"</span>   30 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 24 minutes ago                         eager_napier37c02b640650        ubuntu:18.04        <span class="token string">"/bin/echo 'Hello wo…"</span>   30 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 30 minutes ago                         confident_leavitt~ via ⬢ v12.16.3➜ docker container <span class="token function">rm</span> 37c02b64065037c02b640650</code></pre><p>如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</p><h4 id="6-2-清理所有处于终止状态的容器"><a href="#6-2-清理所有处于终止状态的容器" class="headerlink" title="6.2 清理所有处于终止状态的容器"></a>6.2 清理所有处于终止状态的容器</h4><p>用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p><pre class=" language-bash"><code class="language-bash">➜ docker <span class="token function">ps</span> -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                        PORTS               NAMESc9ca08210d46        ubuntu              <span class="token string">"/bin/bash"</span>              12 minutes ago      Up 12 minutes                                     pedantic_albattanidd8d472bb3b3        ubuntu              <span class="token string">"/bin/bash"</span>              14 minutes ago      Exited <span class="token punctuation">(</span>127<span class="token punctuation">)</span> 12 minutes ago                       optimistic_pasteur208d3180e5ca        ubuntu:18.04        <span class="token string">"/bin/sh -c 'while t…"</span>   23 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 23 minutes ago                         hardcore_dubinskyb0f1a106dcdf        ubuntu:18.04        <span class="token string">"/bin/bash"</span>              25 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 23 minutes ago                         naughty_lumiere1b10a73accd8        ubuntu:18.04        <span class="token string">"/bin/echo 'Hello wo…"</span>   32 minutes ago      Exited <span class="token punctuation">(</span>0<span class="token punctuation">)</span> 26 minutes ago                         eager_napier~ via ⬢ v12.16.3➜ docker container pruneWARNING<span class="token operator">!</span> This will remove all stopped containers.Are you sure you want to continue? <span class="token punctuation">[</span>y/N<span class="token punctuation">]</span> yDeleted Containers:dd8d472bb3b30ba6ab4a230d5734a97c61d0205d8d09ac080c88d3ace0a2fffd208d3180e5cac70cff44d499951138c968f15921d6e1fcdf1756f8d3c74e890fb0f1a106dcdf1773985fb601f2292683ed825d483675e695eb2cebd9c26b6e4e1b10a73accd84fc078433165ce7fa7527509bd3d2c1c2a33172bc64b98b41944Total reclaimed space: 74B~ via ⬢ v12.16.3 took 3s➜ docker <span class="token function">ps</span> -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESc9ca08210d46        ubuntu              <span class="token string">"/bin/bash"</span>         12 minutes ago      Up 12 minutes                           pedantic_albattani</code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 入门系列 1. Docker 简介</title>
      <link href="/posts/26481.html"/>
      <url>/posts/26481.html</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;本系列笔记是作为一个新手小白，从了解 Docker 是什么、Docker 技术包含哪些概念到上手使用、安装以及发布 Docker 镜像的整个过程。小白在学习过程中遵循简介、入门、上手到深入的顺序，根据个人学习实践过程进行书写与记录。</p><h2 id="一、-Docker-简介"><a href="#一、-Docker-简介" class="headerlink" title="一、 Docker 简介"></a>一、 Docker 简介</h2><p>&emsp;&emsp;Docker是DotCloud开源的、可以将任何应用包装在Linux container中运行的工具。Docker是供开发人员和系统管理员：使用容器构建，运行和共享应用程序的平台。使用容器来部署应用程序称为容器化。容器不是新的技术，但用于轻松部署应用程序的Docker却是新的未来。</p><h3 id="1-容器的概念"><a href="#1-容器的概念" class="headerlink" title="1. 容器的概念"></a>1. 容器的概念</h3><p>&emsp;&emsp;<strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。而 Linux 容器是 Linux 发展出了另一种虚拟化技术，简单来讲， Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离，相当于是在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p><p>&emsp;&emsp;<strong><code>Docker</code> 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个<code>虚拟容器</code>里运行，就好像在真实的物理机上运行一样。有了 <code>Docker</code> ，就不用担心环境问题。</strong></p><p>&emsp;&emsp;<code>Docker</code> 利用 Linux 核心中的资源分脱机制，例如 <code>cgroups</code>，以及 Linux 核心名字空间（name space），来创建独立的软件容器（<code>containers</code>），属于<strong>操作系统层面的虚拟化</strong>技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。<code>Docker</code> 在容器的基础上进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护，使得其比虚拟机技术更为轻便、快捷。<code>Docker</code> 可以在单一 Linux 实体下运作，避免因为创建一个虚拟机而造成的额外负担。</p><p>容器化越来越受欢迎，因为容器具有一下有点:</p><blockquote><ul><li>灵活：即使最复杂的也可以容器化。</li><li>轻量级：容器利用并共享主机内核，在系统资源方面比虚拟机效率更高。</li><li>可移植性：您可以在本地构建，部署到云并在任何地方运行。</li><li>松散耦合：容器是高度自给自足并封装的容器，使您可以在不破坏其他容器的情况下更换或升级它们。</li><li>可扩展：您可以在数据中心内增加并自动分布容器副本。</li><li>安全：容器将积极的约束和隔离应用于流程，而无需用户方面的任何配置。</li></ul></blockquote><h3 id="2-容器和虚拟机"><a href="#2-容器和虚拟机" class="headerlink" title="2. 容器和虚拟机"></a>2. 容器和虚拟机</h3><p>容器在Linux上本地运行，并与其他容器共享主机的内核。它运行一个离散进程，不占用任何其他可执行文件更多的内存，从而使其轻巧。由于容器是进程级别的，相比虚拟机有很多优势</p><p>相比之下，虚拟机（VM）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。并通过虚拟机管理程序对主机资源进行虚拟访问。通常，VM会产生大量开销，超出了应用程序逻辑所消耗的开销。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589358055/hexo/Container_kgmlbw.png" alt="容器技术"></td><td><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589358057/hexo/VM_ioupe2.png" alt="虚拟机"></td></tr></tbody></table><h4 id="1-容器技术"><a href="#1-容器技术" class="headerlink" title="1) 容器技术"></a>1) 容器技术</h4><p>容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。容器内没有自己的内核，也没有进行硬件虚拟。</p><h4 id="2-虚拟机"><a href="#2-虚拟机" class="headerlink" title="2) 虚拟机"></a>2) 虚拟机</h4><p>对于虚拟机技术来说，传统虚拟机如 VMware ， VisualBox 之类的需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。</p><blockquote><p>容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。通过使用容器，我们可以轻松打包应用程序的代码、配置和依赖关系，将其变成容易使用的构建块，从而实现环境一致性、运营效率、开发人员生产力和版本控制等诸多目标。容器可以帮助保证应用程序快速、可靠、一致地部署，其间不受部署环境的影响。容器还赋予我们对资源更多的精细化控制能力，让我们的基础设施效率更高。通过上面这幅图我们可以很直观的反映出这两者的区别所在。</p></blockquote><p><strong>具体来说与虚拟机技术对比，Docker 容器存在以下几个特点：</strong></p><p>&emsp;&emsp;<strong>1. 更快的启动速度：</strong> 因为 Docker 直接运行于宿主内核，无需启动完整的操作系统，因此启动速度属于秒级别，而虚拟机通常需要几分钟去启动。</p><p>&emsp;&emsp;<strong>2. 更高效的资源利用率：</strong>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。</p><p>&emsp;&emsp;<strong>3. 更高的系统支持量：</strong>Docker 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境，Docker 运行的镜像数远多于虚拟机数量，对系统的利用率非常高。</p><p>&emsp;&emsp;<strong>4. 持续交付与部署：</strong>对开发和运维人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至进行自动部署。</p><p>&emsp;&emsp;<strong>5. 更轻松的迁移：</strong>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><p>&emsp;&emsp;<strong>6. 更轻松的维护与扩展：</strong>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><p>&emsp;&emsp;<strong>7. 更弱的隔离性：</strong>Docker 属于进程之间的隔离，虚拟机可实现系统级别隔离。</p><p>&emsp;&emsp;<strong>8. 更弱的安全性：</strong>Docker 的租户 root 和宿主机 root 等同，一旦容器内的用户从普通用户权限提升为 root 权限，它就直接具备了宿主机的 root 权限，进而可进行无限制的操作。虚拟机租户 root 权限和宿主机的 root 虚拟机权限是分离的，并且利用硬件隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击。</p><h3 id="3-Docker的用途"><a href="#3-Docker的用途" class="headerlink" title="3. Docker的用途"></a>3. Docker的用途</h3><p>&emsp;&emsp;<code>Docker</code> 的主要用途，目前有三大类。</p><p>&emsp;&emsp;（1）提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p><p>&emsp;&emsp;（2）提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p><p>&emsp;&emsp;（3）组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p><h3 id="4-容器编排"><a href="#4-容器编排" class="headerlink" title="4. 容器编排"></a>4. 容器编排</h3><p><code>Docker</code>平台以及周边生态系统包含很多工具来管理容器的生命周期。<br>&emsp;&emsp;例如，<strong>Docker Command Line Interface(CLI)支持下面的容器活动:</strong></p><p>&emsp;&emsp; - 从注册表中拉取仓库。<br>&emsp;&emsp; - 运行容器并可选的附加一个终端给它。<br>&emsp;&emsp; - 将容器提交新镜像。<br>&emsp;&emsp; - 上传镜像到注册中心。<br>&emsp;&emsp; - 终止运行中的容器。</p><p><strong>Docker Command Line Interface(CLI) 满足在单个主机上管理容器的需求，但是面对部署在多个主机上的容器时就无所适从了。为了超越单个容器管理，我们必须转向编排工具。<code>容器编排工具</code>将生命周期管理能力扩展到部署在大量机器集群上部署的复杂的、多容器工作负载。通过抽象主机基础结构， 编排工具允许用户将整个集群视为单个部署目标。</strong></p><blockquote><p><strong>容器编排工具</strong> 提供调度和集群的技术，提供用于基于容器应用可扩展性的基本机制。这些工具使用容器服务，并编排他们以决定容器之间如何进行交互。此外，编排允许容器可以存在并执行在集群上，这使得他们能够扩展来适应增加的处理负荷。</p></blockquote><p>&emsp;&emsp;典型的容器编排工具有助于虚拟化一组机器并将它们作为单个集群管理。容器编排工具也有助于将机器上的工作负载或容器移动到消费者透明的位置。很多工具目前既支持基于DOCKER的容器，也支持非容器化二进制文件部署，例如独立的Spring Boot应用程序。这些容器编排工具的基本功能是从应用程序中抽象出实际的服务器实例。</p><blockquote><p><strong>容器编排工具</strong> 为开发人员和基础设施团队提供了一个抽象层来处理大规模的容器化部署。<code>容器编排工具</code>提供的特征在众多提供者之间有所不同，然而常见的公共特征包含准备、发现、资源管理、监视和部署。</p></blockquote><p><strong>容器编排工具的一些关键能力概括如下：</strong></p><ul><li><strong>集群管理：</strong>将虚拟机和物理机器的集群管理为一台大型机器。这些机器在资源能力方面可能有些差异，但大体上都是以Linux作为操作系统的机器。这些虚拟集群可以建立在云上、本地或两者的混合。</li><li><strong>部署：</strong>能处理有大量机器的应用程序和容器的自动部署。支持多个版本的应用程序容器，并且还支持跨越大量集群机器的滚动升级。这些工具还能够处理故障回滚。</li><li><strong>可伸缩性：</strong>支持应用实例的自动和手动伸缩，以性能优化为主要目标。</li><li><strong>健康：</strong>它管理集群、节点和应用程序的健康。可以从集群中移除异常的机器和应用程序实例。</li><li><strong>基础结构抽象化：</strong>开发人员不必担心机器、容量等问题。完全是容器编排工具来决定如何调度和运行应用程序。这些工具也抽象化机器的细节、能力、使用和位置。对于应用程序所有者来说，它们相当于一个容量几乎无限的大型机器。</li><li><strong>资源优化：</strong>这些工具以有效的方式在一组可用机器上分配容器工作负载，从而降低成本，通过从简单的到复杂的算法可有效地提高利用率。</li><li><strong>资源分配：</strong>基于应用程序开发人员设置的资源可用性和约束来分配服务器。资源分配将基于约束、规则、端口要求、应用依赖性、健康等等。</li><li><strong>服务可用性：</strong>确保服务在集群中正常运行。在机器故障的情况下，容器编排会自动通过在集群中的其他机器上重新启动这些服务来处理故障。</li><li><strong>敏捷性：</strong>敏捷性工具能够快速分配工作负载到可用资源，或者在资源需求发生变化时跨机器移动工作量。此外，可以根据业务临界性、业务优先级等来设置约束重新调整资源。</li><li><strong>隔离：</strong>一些工具提供了资源隔离。因此，即使应用程序不是容器化的，也可以实现资源隔离。</li></ul><h3 id="5-编排工具"><a href="#5-编排工具" class="headerlink" title="5. 编排工具"></a>5. 编排工具</h3><h4 id="1-Kubernetes"><a href="#1-Kubernetes" class="headerlink" title="1) Kubernetes"></a>1) Kubernetes</h4><p>&emsp;&emsp;Kubernetes是一个开源的，开箱即用的容器集群管理器和业务流程。它具有出色的构建 调度器 和资源管理器，用于以更有效和高度可用的方式部署容器。Kubernetes已成为许多组织事实上的容器编排工具。kubernetes项目由google与世界各地的贡献者维护。它提供了本机Docker工具不提供的许多功能。而且，使用kubernetes很容易上手。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589374109/hexo/kubernetes_yxk3g7.jpg" alt="Kubernetes"></p><h4 id="2-OpenShift"><a href="#2-OpenShift" class="headerlink" title="2) OpenShift"></a>2) OpenShift</h4><p>&emsp;&emsp;Openshift建立在kubernetes之上。Openshift项目由Redhat维护。它同时具有开源（openshift orgin）和企业版（openshift容器平台）。连同核心的Kubernetes功能，它提供了用于容器管理和编排的开箱即用组件。<br><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589374123/hexo/OpenShift_rfa8hh.jpg" alt="OpenShift"></p><h4 id="3-Docker-Swarm"><a href="#3-Docker-Swarm" class="headerlink" title="3) Docker Swarm"></a>3) Docker Swarm</h4><p>&emsp;&emsp;Docker生态系统包括从开发到生产部署框架的工具。在该列表中，docker swarm适用于集群管理。可以使用docker-compose，swarm，overlay网络和良好的服务发现工具（例如etcd或consul）的组合来管理Docker容器集群。</p><p>与其他开源容器集群管理工具相比，Docker swarm在功能方面仍日趋成熟。考虑到庞大的Docker贡献者，Docker swarm拥有其他工具拥有的所有最佳功能不会太久。Docker记录了在生产中使用docker swarm 的良好生产计划。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589374125/hexo/Swarm_fbtool.jpg" alt="Docker Swarm"></p><h4 id="4-Mesos"><a href="#4-Mesos" class="headerlink" title="4) Mesos"></a>4) Mesos</h4><p>&emsp;&emsp;Mesos是另一个可以非常有效地管理容器编排的群集管理工具。它是由Twitter为其基础架构创建的，然后获得了开源。它已被eBay，Airbnb等公司使用。Mesos并不是用于容器的专用工具，</p><p>Mesos不是用于容器的专用工具，相反，您可以将其用于VM或物理机群集，以运行容器以外的工作负载（大数据等）。它具有一个称为Marathon的有效框架，用于在Mesos群集上部署和管理容器。<br><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589374127/hexo/Mesos_xjlyvv.jpg" alt="Mesos"></p><h3 id="6-服务网格"><a href="#6-服务网格" class="headerlink" title="6. 服务网格"></a>6. 服务网格</h3><p>&emsp;&emsp;容器和容器编排技术的兴起使得新的基础架构成为了可能，使我们能够摆脱服务发现/负载平衡/断路器框架的束缚。 这个新的基础设施就是“服务网格”，那服务网格是什么呢？</p><blockquote><p><strong>服务网格</strong> 是一个<code>基础架构层</code> - 主要是一个代理集合，每个逻辑服务都有一个代理 - 与Docker Swarm或Kubernetes等容器编排解决方案集成，并提供服务发现，负载平衡，断路器，故障注入，安全，监控，跟踪以及更多以非侵入性的方式提供的开箱即用功能。</p></blockquote><p>由于服务网格在容器级别运行，它并不关心使用什么技术或编程语言来编写微服务。 你可以将微服务使用Java，C ++，Rust，Go，NodeJS来编写简单HTTP服务器，这些都已不再重要。</p><p>可以将服务网格有效地视为分布式容器化应用基础架构级的面向切面编程。 服务网格中的代理就像AOP中的一个切面。 它们包裹了一个容器化的微服务，就像AspectJ切面可以包裹和测试java方法一样，通过分离横切关注点来简化系统。</p><p>在服务网格中，请求将通过所在基础架构层中的代理在微服务之间路由。正因如此，构成服务网格的各个代理有时也被称为“sidecar”（边车），这是因为它们与每个服务并行运行，而非在内部运行。总之，这些“sidecar”代理（与每项服务分离）构成了网格式网络。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589376166/hexo/sidecar_ce6pve.png" alt="sidecar"></p><p>服务网格是如何实现的呢？它通常会为每个服务实例提供一个称为边车（sidecar）的代理实例。这些边车会处理服务间的通信，监控和安全相关的问题， 以及任何可以从各个服务中抽象出来的东西。这样，开发人员就可以专注于服务中应用程序代码的开发，支持和维护，而运维团队可以负责维护服务网格以及运行应用程序。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589376932/hexo/contrl_plane_kuexpi.png" alt="contrl plane"></p><p>服务网格应用中管理实例之间的网络流量的的部分称为数据平面。另外有一个独立的控制平面负责生成和部署数据平面的配置（这个配置可以控制数据平面的行为）。控制平面通常包含（或被设计为连接到）一个API，命令行界面和用于管理App的图形用户界面。</p><p><strong>Sidecar 设计模式已经越来越受欢迎，并在社区内得到更广泛的采用。构建具有高度可扩展性、弹性、安全性和可观察性的微服务架构具有挑战性。Service Mesh 架构的发展已经改变了游戏规则。它降低了与微服务架构相关的复杂性，并提供了许多功能，如负载平衡、服务发现、流量管理、熔断、遥测、故障注入等。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 容器服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Docker 中运行 OpenWrt 旁路网关</title>
      <link href="/posts/53042.html"/>
      <url>/posts/53042.html</url>
      
        <content type="html"><![CDATA[<p>在接下来的文章中，我们将在 <code>Docker</code> 容器中运行 <code>OpenWrt</code>，并通过设置，让 <code>Docker</code> 容器中的 <code>OpenWrt</code> 网关接管路由器自身的网关，减轻路由器的负担，同时，由于网关被 <code>OpenWrt</code> 接管，所以 <code>OpenWrt</code> 中的大部分应用都是可用的，比如酸酸乳，V2ray，去广告等。做个不恰当的比喻， <code>OpenWrt</code> 网关接管路由器自身的网关后，你可以理解为路由器是 <code>OpenWrt</code> 的一块外置网卡。</p><h2 id="一、概念介绍"><a href="#一、概念介绍" class="headerlink" title="一、概念介绍"></a>一、概念介绍</h2><h3 id="1-OpenWrt"><a href="#1-OpenWrt" class="headerlink" title="1. OpenWrt"></a>1. OpenWrt</h3><blockquote><p><strong>OpenWrt</strong>：是一个高度模块化、高度自动化的嵌入式的Linux发行版，她拥有强大的网络组件和扩展性，常常被用于工控设备、智能家居、路由器等设备中。它还提供了上百个已编译好的软件，而且数量还在不断增加。</p></blockquote><p><code>OpenWrt</code>使用框架来构建应用程序，不需要构建一个完整的固件，对于用户来说，将会拥有完全定制的玩法。OpenWRT支持各种处理器架构，无论是对ARM，X86，PowerPC或者MIPS都有很好的支持。</p><h3 id="2-旁路网关"><a href="#2-旁路网关" class="headerlink" title="2. 旁路网关"></a>2. 旁路网关</h3><p>那么，什么是旁路网关(旁路由)呢？</p><blockquote><p><strong>所谓的旁路网关</strong>：就是在路由器之外的其他硬件设备上搭建一个网关环境，把路由器肩负的网关重任交给其他更适合的设备来做，同时，旁路网关处理完的结果会返回给主路由器，由主路由器继续进行转发处理。</p></blockquote><p>普通的路由器往往集无线信号转发、网关、DNS 服务等角色为一身，其中的“网关”角色负责路由器内部数据与外部网络的交换处理。但因为一般家用的路由器硬件性能很有限，在运行一些比较吃资源的应用（如酸酸乳、去广告等）时，几乎会占满所有硬件资源，导致路由器网络/系统不稳定等诸多问题。<br/><br>既然路由器的硬件性能有限，那可不可以把网关的重任交给硬件性能更好的设备去做，让路由器安安心心地做好数据交换的工作哪？<br/><br>当然可以了，我们可以增加一个<code>旁路网关</code>，让它预先处理数据，将复杂的功能完成后，再交给主路由进行转发和后续的工作。</p><p>这样，每个角色各司其职，路由器肩上的任务轻了，即使是油管 4K 也能轻松跑满网速了，而<code>旁路网关</code>也能提供更多的功能。由此资源的充分利用，一举两得。</p><h3 id="3-Docker"><a href="#3-Docker" class="headerlink" title="3. Docker"></a>3. Docker</h3><blockquote><p><strong>Docker</strong> 是一个开源，轻量级的应用容器引擎，基于GO语言开发，用于创建、管理和编排容器。与VMware 虚拟机相比，Docker 使用容器承载应用程序，而不使用操作系统，所以它的开销很少，性能很高。</p></blockquote><h2 id="二、Docker-安装"><a href="#二、Docker-安装" class="headerlink" title="二、Docker 安装"></a>二、Docker 安装</h2><h3 id="1-获取自动安装脚本"><a href="#1-获取自动安装脚本" class="headerlink" title="1. 获取自动安装脚本"></a>1. 获取自动安装脚本</h3><blockquote><p>以 <code>阿里云镜像</code>安装脚本内容</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 安装命令</span>curl -fsSL https://get.docker.com -o get-docker.shsh get-docker.sh --mirror Aliyun</code></pre><p>安装过程如下</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Executing docker install script, commit: 1b02882d63b9cfc484ad6b0180171c679cfe0f3a</span>+ sh -c <span class="token function">apt-get</span> update -qq <span class="token operator">></span>/dev/null+ sh -c DEBIAN_FRONTEND<span class="token operator">=</span>noninteractive <span class="token function">apt-get</span> <span class="token function">install</span> -y -qq apt-transport-https ca-certificates curl <span class="token operator">></span>/dev/null+ sh -c curl -fsSL <span class="token string">"https://download.docker.com/linux/debian/gpg"</span> <span class="token operator">|</span> apt-key add -qq - <span class="token operator">></span>/dev/nullWarning: apt-key output should not be parsed <span class="token punctuation">(</span>stdout is not a terminal<span class="token punctuation">)</span>+ sh -c <span class="token keyword">echo</span> <span class="token string">"deb [arch=arm64] https://download.docker.com/linux/debian stretch stable"</span> <span class="token operator">></span> /etc/apt/sources.list.d/docker.list+ sh -c <span class="token function">apt-get</span> update -qq <span class="token operator">></span>/dev/null+ <span class="token punctuation">[</span> -n  <span class="token punctuation">]</span>+ sh -c <span class="token function">apt-get</span> <span class="token function">install</span> -y -qq --no-install-recommends docker-ce <span class="token operator">></span>/dev/null+ sh -c docker versionClient: Docker Engine - Community Version:           19.03.8 API version:       1.40 Go version:        go1.12.17 Git commit:        afacb8b Built:             Wed Mar 11 01:27:00 2020 OS/Arch:           linux/arm64 Experimental:      <span class="token boolean">false</span>Server: Docker Engine - Community Engine:  Version:          19.03.8  API version:      1.40 <span class="token punctuation">(</span>minimum version 1.12<span class="token punctuation">)</span>  Go version:       go1.12.17  Git commit:       afacb8b  Built:            Wed Mar 11 01:25:31 2020  OS/Arch:          linux/arm64  Experimental:     <span class="token boolean">false</span> containerd:  Version:          1.2.13  GitCommit:        7ad184331fa3e55e52b890ea95e65ba581ae3429 runc:  Version:          1.0.0-rc10  GitCommit:        dc9208a3303feef5b3839f4323d9beb36df0a9dd docker-init:  Version:          0.18.0  GitCommit:        fec3683If you would like to use Docker as a non-root user, you should now consideradding your user to the <span class="token string">"docker"</span> group with something like:  <span class="token function">sudo</span> <span class="token function">usermod</span> -aG docker your-userRemember that you will have to log out and back <span class="token keyword">in</span> <span class="token keyword">for</span> this to take effect<span class="token operator">!</span>WARNING: Adding a user to the <span class="token string">"docker"</span> group will grant the ability to run         containers <span class="token function">which</span> can be used to obtain root privileges on the         docker host.         Refer to https://docs.docker.com/engine/security/security/<span class="token comment" spellcheck="true">#docker-daemon-attack-surface</span>         <span class="token keyword">for</span> <span class="token function">more</span> information.</code></pre><h3 id="2-开启网卡的混杂模式"><a href="#2-开启网卡的混杂模式" class="headerlink" title="2. 开启网卡的混杂模式"></a>2. 开启网卡的混杂模式</h3><blockquote><p>开启网卡的混杂模式（这样是为了目前这个阶段能正常安装并配置，要永久开启需修改配置文件，稍后详述）</p></blockquote><pre class=" language-bash"><code class="language-bash">ip <span class="token function">link</span> <span class="token keyword">set</span> eth0 promisc on</code></pre><h3 id="3-下载-OpenWrt-镜像"><a href="#3-下载-OpenWrt-镜像" class="headerlink" title="3. 下载 OpenWrt 镜像"></a>3. 下载 OpenWrt 镜像</h3><blockquote><p>在终端界面执行以下命令，下载OpenWrt的docker 镜像文件</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 镜像下载命令</span>docker pull buddyfly/openwrt-aarch64</code></pre><p>镜像下载过程如下</p><pre class=" language-bash"><code class="language-bash">Using default tag: latestlatest: Pulling from buddyfly/openwrt-aarch64aef47d0acf8a: Pull completeDigest: sha256:d3a3f4f9aaac4169d3b16c1f796b5d379c6234b997cb440daee80ef3ad1aba05Status: Downloaded newer image <span class="token keyword">for</span> buddyfly/openwrt-aarch64:latestdocker.io/buddyfly/openwrt-aarch64:latest</code></pre><h3 id="4-创建-Docker-虚拟网络"><a href="#4-创建-Docker-虚拟网络" class="headerlink" title="4. 创建 Docker 虚拟网络"></a>4. 创建 Docker 虚拟网络</h3><blockquote><p>虚拟网络名称为<code>macnet</code>，驱动为<code>macvlan</code>模式，将 <code>subnet 10.10.10.0</code>修改为你自己主路由的网段，<code>geteway 10.10.10.1</code>修改为你自己的主路由网关】</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建虚拟网络</span>docker network create -d macvlan --subnet<span class="token operator">=</span>10.10.10.0/24 --gateway<span class="token operator">=</span>10.10.10.1 -o parent<span class="token operator">=</span>eth0 macnet</code></pre><h3 id="5-启动-OpenWrt-容器"><a href="#5-启动-OpenWrt-容器" class="headerlink" title="5. 启动 OpenWrt 容器"></a>5. 启动 OpenWrt 容器</h3><blockquote><p>启动 OpenWrt 容器</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 开启容器</span>docker run --restart always -d --network macnet --privileged buddyfly/openwrt-aarch64:latest</code></pre><h3 id="6-查看运行中的-OpenWrt-容器"><a href="#6-查看运行中的-OpenWrt-容器" class="headerlink" title="6. 查看运行中的 OpenWrt 容器"></a>6. 查看运行中的 OpenWrt 容器</h3><blockquote><p>查看运行中的容器</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看运行中的容器</span>docker <span class="token function">ps</span> -a</code></pre><p>运行结果如下</p><pre><code>root@aml4:~# docker ps -aCONTAINER ID        IMAGE                             COMMAND             CREATED             STATUS              PORTS               NAMESf76303c1b9f0        buddyfly/openwrt-aarch64:latest   &quot;/sbin/init&quot;        43 seconds ago      Up 40 seconds                           affectionate_liskovroot@aml4:~#</code></pre><h3 id="7-修改OpenWrt容器的IP地址"><a href="#7-修改OpenWrt容器的IP地址" class="headerlink" title="7. 修改OpenWrt容器的IP地址"></a>7. 修改OpenWrt容器的IP地址</h3><blockquote><p>进入openwrt容器修改network设置</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 进入容器命令行</span>docker <span class="token function">exec</span> -it f76303c1b9f0 /bin/bash</code></pre><p>进入容器命令行结果如下</p><pre><code>root@aml4:~# docker exec -it f763 /bin/bashbash-4.4#</code></pre><blockquote><p>编辑网络配置文件</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 修改网络配置</span><span class="token function">vi</span> /etc/config/network</code></pre><p>修改文件如下 将<code>option ipaddr 192.168.1.1</code> 改为你想作为旁路网关的空闲地址。我的网段为<code>10.10.10.X</code>,共享地址为<code>10.10.10.254</code></p><pre><code>config interface &#39;loopback&#39;        option ifname &#39;lo&#39;        option proto &#39;static&#39;        option ipaddr &#39;127.0.0.1&#39;        option netmask &#39;255.0.0.0&#39;config globals &#39;globals&#39;        option ula_prefix &#39;fd00:6e95:e381::/48&#39;config interface &#39;lan&#39;        option type &#39;bridge&#39;        option ifname &#39;eth0&#39;        option proto &#39;static&#39;        option ipaddr &#39;10.10.10.254&#39;        option netmask &#39;255.255.255.0&#39;        option ip6assign &#39;60&#39;</code></pre><blockquote><p>重启网络服务</p></blockquote><pre class=" language-bash"><code class="language-bash">/etc/init.d/network restart</code></pre><h3 id="8-永久开启网卡混杂模式"><a href="#8-永久开启网卡混杂模式" class="headerlink" title="8. 永久开启网卡混杂模式"></a>8. 永久开启网卡混杂模式</h3><blockquote><p>重启网卡混杂模式会失效，需设为永久开启 修改/etc/network/interfaces文件：</p><p>谨慎操作，可能导致无法访问网络</p><p>添加 <code>up ip link set eth0 promisc on</code></p></blockquote><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589043064/hexo/promisc_tx2nev.png" alt="修改网卡接口配置"></p><h2 id="三、旁路网关配置"><a href="#三、旁路网关配置" class="headerlink" title="三、旁路网关配置"></a>三、旁路网关配置</h2><h3 id="1-登录旁路网关系统"><a href="#1-登录旁路网关系统" class="headerlink" title="1. 登录旁路网关系统"></a>1. 登录旁路网关系统</h3><blockquote><p>用户名 <code>root</code> 密码 <code>password</code></p></blockquote><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589041433/hexo/login_zgy4vg.png" alt="登录界面"></p><h3 id="2-更改系统主题"><a href="#2-更改系统主题" class="headerlink" title="2. 更改系统主题"></a>2. 更改系统主题</h3><blockquote><p>更改系统主题为<code>Argon-Dark</code></p></blockquote><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589043524/hexo/theme_es9ekm.png" alt="更改主题"></p><h3 id="3-更改上级路由"><a href="#3-更改上级路由" class="headerlink" title="3. 更改上级路由"></a>3. 更改上级路由</h3><blockquote><p>点击网络&gt;接口&gt;修改</p></blockquote><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589043893/hexo/lan_smvrcr.png" alt="进入LAN配置"></p><blockquote><p>修改IPv4网关为<code>10.10.10.1</code>,DHCP服务器 勾选 <code>忽略此接口</code></p></blockquote><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589044105/hexo/DHCP_bwtwdk.png" alt="修改上级路由"></p><h3 id="4-网络加速设置"><a href="#4-网络加速设置" class="headerlink" title="4. 网络加速设置"></a>4. 网络加速设置</h3><blockquote><p>开启DNS加速</p></blockquote><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589044491/hexo/ACC_s1tx1m.png" alt="更改主题"></p><h3 id="5-科学上网"><a href="#5-科学上网" class="headerlink" title="5. 科学上网"></a>5. 科学上网</h3><blockquote><p>开启科学上网</p></blockquote><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589044757/hexo/node_moj3rj.png" alt="添加节点"></p><blockquote><p>全局设置</p></blockquote><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589044938/hexo/passwall_gquzdn.png" alt="参数设置"></p><h3 id="6-配置旁路网关"><a href="#6-配置旁路网关" class="headerlink" title="6. 配置旁路网关"></a>6. 配置旁路网关</h3><blockquote><p>局域网中需要科学上网的机器配置旁路网关</p></blockquote><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589045268/hexo/IP_slznx9.png" alt="网关设置"></p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589045677/hexo/youtube_lpmeny.png" alt="油管测速"></p>]]></content>
      
      
      <categories>
          
          <category> 科学上网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> openwrt </tag>
            
            <tag> 旁路由 </tag>
            
            <tag> 透明网关 </tag>
            
            <tag> 科学上网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
