<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker入门系列 1. Docker简介</title>
      <link href="/2020/05/12/docker-ru-men-xi-lie-1-docker-jian-jie/"/>
      <url>/2020/05/12/docker-ru-men-xi-lie-1-docker-jian-jie/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;本系列笔记是作为一个新手小白，从了解 Docker 是什么、Docker 技术包含哪些概念到上手使用、安装以及发布 Docker 镜像的整个过程。小白在学习过程中遵循简介、入门、上手到深入的顺序，根据个人学习实践过程进行书写与记录。</p><h2 id="一、-Docker-简介"><a href="#一、-Docker-简介" class="headerlink" title="一、 Docker 简介"></a>一、 Docker 简介</h2><p>&emsp;&emsp;Docker是DotCloud开源的、可以将任何应用包装在Linux container中运行的工具。Docker是供开发人员和系统管理员：使用容器构建，运行和共享应用程序的平台。使用容器来部署应用程序称为容器化。容器不是新的技术，但用于轻松部署应用程序的Docker却是新的未来。</p><h3 id="1-容器的概念"><a href="#1-容器的概念" class="headerlink" title="1. 容器的概念"></a>1. 容器的概念</h3><p>&emsp;&emsp;<strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。而 Linux 容器是 Linux 发展出了另一种虚拟化技术，简单来讲， Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离，相当于是在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p><p>&emsp;&emsp;<strong><code>Docker</code> 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个<code>虚拟容器</code>里运行，就好像在真实的物理机上运行一样。有了 <code>Docker</code> ，就不用担心环境问题。</strong></p><p>&emsp;&emsp;<code>Docker</code> 利用 Linux 核心中的资源分脱机制，例如 <code>cgroups</code>，以及 Linux 核心名字空间（name space），来创建独立的软件容器（<code>containers</code>），属于<strong>操作系统层面的虚拟化</strong>技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。<code>Docker</code> 在容器的基础上进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护，使得其比虚拟机技术更为轻便、快捷。<code>Docker</code> 可以在单一 Linux 实体下运作，避免因为创建一个虚拟机而造成的额外负担。</p><p>容器化越来越受欢迎，因为容器具有一下有点:</p><blockquote><ul><li>灵活：即使最复杂的也可以容器化。</li><li>轻量级：容器利用并共享主机内核，在系统资源方面比虚拟机效率更高。</li><li>可移植性：您可以在本地构建，部署到云并在任何地方运行。</li><li>松散耦合：容器是高度自给自足并封装的容器，使您可以在不破坏其他容器的情况下更换或升级它们。</li><li>可扩展：您可以在数据中心内增加并自动分布容器副本。</li><li>安全：容器将积极的约束和隔离应用于流程，而无需用户方面的任何配置。</li></ul></blockquote><h3 id="2-容器和虚拟机"><a href="#2-容器和虚拟机" class="headerlink" title="2. 容器和虚拟机"></a>2. 容器和虚拟机</h3><p>容器在Linux上本地运行，并与其他容器共享主机的内核。它运行一个离散进程，不占用任何其他可执行文件更多的内存，从而使其轻巧。由于容器是进程级别的，相比虚拟机有很多优势</p><p>相比之下，虚拟机（VM）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。并通过虚拟机管理程序对主机资源进行虚拟访问。通常，VM会产生大量开销，超出了应用程序逻辑所消耗的开销。</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589358055/hexo/Container_kgmlbw.png" alt="容器技术"></td><td><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589358057/hexo/VM_ioupe2.png" alt="虚拟机"></td></tr></tbody></table><h4 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h4><p>容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。容器内没有自己的内核，也没有进行硬件虚拟。</p><h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><p>对于虚拟机技术来说，传统虚拟机如 VMware ， VisualBox 之类的需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。</p><blockquote><p>容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。通过使用容器，我们可以轻松打包应用程序的代码、配置和依赖关系，将其变成容易使用的构建块，从而实现环境一致性、运营效率、开发人员生产力和版本控制等诸多目标。容器可以帮助保证应用程序快速、可靠、一致地部署，其间不受部署环境的影响。容器还赋予我们对资源更多的精细化控制能力，让我们的基础设施效率更高。通过上面这幅图我们可以很直观的反映出这两者的区别所在。</p></blockquote><p><strong>具体来说与虚拟机技术对比，Docker 容器存在以下几个特点：</strong></p><p>&emsp;&emsp;<strong>1. 更快的启动速度：</strong> 因为 Docker 直接运行于宿主内核，无需启动完整的操作系统，因此启动速度属于秒级别，而虚拟机通常需要几分钟去启动。</p><p>&emsp;&emsp;<strong>2. 更高效的资源利用率：</strong>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。</p><p>&emsp;&emsp;<strong>3. 更高的系统支持量：</strong>Docker 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境，Docker 运行的镜像数远多于虚拟机数量，对系统的利用率非常高。</p><p>&emsp;&emsp;<strong>4. 持续交付与部署：</strong>对开发和运维人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至进行自动部署。</p><p>&emsp;&emsp;<strong>5. 更轻松的迁移：</strong>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><p>&emsp;&emsp;<strong>6. 更轻松的维护与扩展：</strong>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><p>&emsp;&emsp;<strong>7. 更弱的隔离性：</strong>Docker 属于进程之间的隔离，虚拟机可实现系统级别隔离。</p><p>&emsp;&emsp;<strong>8. 更弱的安全性：</strong>Docker 的租户 root 和宿主机 root 等同，一旦容器内的用户从普通用户权限提升为 root 权限，它就直接具备了宿主机的 root 权限，进而可进行无限制的操作。虚拟机租户 root 权限和宿主机的 root 虚拟机权限是分离的，并且利用硬件隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击。</p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>Docker 的主要用途，目前有三大类。</p><p>（1）提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p><p>（2）提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p><p>（3）组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p>]]></content>
      
      
      <categories>
          
          <category> 容器服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Docker 中运行 OpenWrt 旁路网关</title>
      <link href="/2020/05/09/zai-docker-zhong-yun-xing-openwrt-pang-lu-wang-guan/"/>
      <url>/2020/05/09/zai-docker-zhong-yun-xing-openwrt-pang-lu-wang-guan/</url>
      
        <content type="html"><![CDATA[<p>在接下来的文章中，我们将在 <code>Docker</code> 容器中运行 <code>OpenWrt</code>，并通过设置，让 <code>Docker</code> 容器中的 <code>OpenWrt</code> 网关接管路由器自身的网关，减轻路由器的负担，同时，由于网关被 <code>OpenWrt</code> 接管，所以 <code>OpenWrt</code> 中的大部分应用都是可用的，比如酸酸乳，V2ray，去广告等。做个不恰当的比喻， <code>OpenWrt</code> 网关接管路由器自身的网关后，你可以理解为路由器是 <code>OpenWrt</code> 的一块外置网卡。</p><h2 id="一、概念介绍"><a href="#一、概念介绍" class="headerlink" title="一、概念介绍"></a>一、概念介绍</h2><h3 id="1-OpenWrt"><a href="#1-OpenWrt" class="headerlink" title="1. OpenWrt"></a>1. OpenWrt</h3><blockquote><p><strong>OpenWrt</strong>：是一个高度模块化、高度自动化的嵌入式的Linux发行版，她拥有强大的网络组件和扩展性，常常被用于工控设备、智能家居、路由器等设备中。它还提供了上百个已编译好的软件，而且数量还在不断增加。</p></blockquote><p><code>OpenWrt</code>使用框架来构建应用程序，不需要构建一个完整的固件，对于用户来说，将会拥有完全定制的玩法。OpenWRT支持各种处理器架构，无论是对ARM，X86，PowerPC或者MIPS都有很好的支持。</p><h3 id="2-旁路网关"><a href="#2-旁路网关" class="headerlink" title="2. 旁路网关"></a>2. 旁路网关</h3><p>那么，什么是旁路网关(旁路由)呢？</p><blockquote><p><strong>所谓的旁路网关</strong>：就是在路由器之外的其他硬件设备上搭建一个网关环境，把路由器肩负的网关重任交给其他更适合的设备来做，同时，旁路网关处理完的结果会返回给主路由器，由主路由器继续进行转发处理。</p></blockquote><p>普通的路由器往往集无线信号转发、网关、DNS 服务等角色为一身，其中的“网关”角色负责路由器内部数据与外部网络的交换处理。但因为一般家用的路由器硬件性能很有限，在运行一些比较吃资源的应用（如酸酸乳、去广告等）时，几乎会占满所有硬件资源，导致路由器网络/系统不稳定等诸多问题。<br/><br>既然路由器的硬件性能有限，那可不可以把网关的重任交给硬件性能更好的设备去做，让路由器安安心心地做好数据交换的工作哪？<br/><br>当然可以了，我们可以增加一个<code>旁路网关</code>，让它预先处理数据，将复杂的功能完成后，再交给主路由进行转发和后续的工作。</p><p>这样，每个角色各司其职，路由器肩上的任务轻了，即使是油管 4K 也能轻松跑满网速了，而<code>旁路网关</code>也能提供更多的功能。由此资源的充分利用，一举两得。</p><h3 id="3-Docker"><a href="#3-Docker" class="headerlink" title="3. Docker"></a>3. Docker</h3><blockquote><p><strong>Docker</strong> 是一个开源，轻量级的应用容器引擎，基于GO语言开发，用于创建、管理和编排容器。与VMware 虚拟机相比，Docker 使用容器承载应用程序，而不使用操作系统，所以它的开销很少，性能很高。</p></blockquote><h2 id="二、Docker-安装"><a href="#二、Docker-安装" class="headerlink" title="二、Docker 安装"></a>二、Docker 安装</h2><h3 id="1-获取自动安装脚本"><a href="#1-获取自动安装脚本" class="headerlink" title="1. 获取自动安装脚本"></a>1. 获取自动安装脚本</h3><blockquote><p>以 <code>阿里云镜像</code>安装脚本内容</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 安装命令</span>curl -fsSL https://get.docker.com -o get-docker.shsh get-docker.sh --mirror Aliyun</code></pre><p>安装过程如下</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Executing docker install script, commit: 1b02882d63b9cfc484ad6b0180171c679cfe0f3a</span>+ sh -c <span class="token function">apt-get</span> update -qq <span class="token operator">></span>/dev/null+ sh -c DEBIAN_FRONTEND<span class="token operator">=</span>noninteractive <span class="token function">apt-get</span> <span class="token function">install</span> -y -qq apt-transport-https ca-certificates curl <span class="token operator">></span>/dev/null+ sh -c curl -fsSL <span class="token string">"https://download.docker.com/linux/debian/gpg"</span> <span class="token operator">|</span> apt-key add -qq - <span class="token operator">></span>/dev/nullWarning: apt-key output should not be parsed <span class="token punctuation">(</span>stdout is not a terminal<span class="token punctuation">)</span>+ sh -c <span class="token keyword">echo</span> <span class="token string">"deb [arch=arm64] https://download.docker.com/linux/debian stretch stable"</span> <span class="token operator">></span> /etc/apt/sources.list.d/docker.list+ sh -c <span class="token function">apt-get</span> update -qq <span class="token operator">></span>/dev/null+ <span class="token punctuation">[</span> -n  <span class="token punctuation">]</span>+ sh -c <span class="token function">apt-get</span> <span class="token function">install</span> -y -qq --no-install-recommends docker-ce <span class="token operator">></span>/dev/null+ sh -c docker versionClient: Docker Engine - Community Version:           19.03.8 API version:       1.40 Go version:        go1.12.17 Git commit:        afacb8b Built:             Wed Mar 11 01:27:00 2020 OS/Arch:           linux/arm64 Experimental:      <span class="token boolean">false</span>Server: Docker Engine - Community Engine:  Version:          19.03.8  API version:      1.40 <span class="token punctuation">(</span>minimum version 1.12<span class="token punctuation">)</span>  Go version:       go1.12.17  Git commit:       afacb8b  Built:            Wed Mar 11 01:25:31 2020  OS/Arch:          linux/arm64  Experimental:     <span class="token boolean">false</span> containerd:  Version:          1.2.13  GitCommit:        7ad184331fa3e55e52b890ea95e65ba581ae3429 runc:  Version:          1.0.0-rc10  GitCommit:        dc9208a3303feef5b3839f4323d9beb36df0a9dd docker-init:  Version:          0.18.0  GitCommit:        fec3683If you would like to use Docker as a non-root user, you should now consideradding your user to the <span class="token string">"docker"</span> group with something like:  <span class="token function">sudo</span> <span class="token function">usermod</span> -aG docker your-userRemember that you will have to log out and back <span class="token keyword">in</span> <span class="token keyword">for</span> this to take effect<span class="token operator">!</span>WARNING: Adding a user to the <span class="token string">"docker"</span> group will grant the ability to run         containers <span class="token function">which</span> can be used to obtain root privileges on the         docker host.         Refer to https://docs.docker.com/engine/security/security/<span class="token comment" spellcheck="true">#docker-daemon-attack-surface</span>         <span class="token keyword">for</span> <span class="token function">more</span> information.</code></pre><h3 id="2-开启网卡的混杂模式"><a href="#2-开启网卡的混杂模式" class="headerlink" title="2. 开启网卡的混杂模式"></a>2. 开启网卡的混杂模式</h3><blockquote><p>开启网卡的混杂模式（这样是为了目前这个阶段能正常安装并配置，要永久开启需修改配置文件，稍后详述）</p></blockquote><pre class=" language-bash"><code class="language-bash">ip <span class="token function">link</span> <span class="token keyword">set</span> eth0 promisc on</code></pre><h3 id="3-下载-OpenWrt-镜像"><a href="#3-下载-OpenWrt-镜像" class="headerlink" title="3. 下载 OpenWrt 镜像"></a>3. 下载 OpenWrt 镜像</h3><blockquote><p>在终端界面执行以下命令，下载OpenWrt的docker 镜像文件</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 镜像下载命令</span>docker pull buddyfly/openwrt-aarch64</code></pre><p>镜像下载过程如下</p><pre class=" language-bash"><code class="language-bash">Using default tag: latestlatest: Pulling from buddyfly/openwrt-aarch64aef47d0acf8a: Pull completeDigest: sha256:d3a3f4f9aaac4169d3b16c1f796b5d379c6234b997cb440daee80ef3ad1aba05Status: Downloaded newer image <span class="token keyword">for</span> buddyfly/openwrt-aarch64:latestdocker.io/buddyfly/openwrt-aarch64:latest</code></pre><h3 id="4-创建-Docker-虚拟网络"><a href="#4-创建-Docker-虚拟网络" class="headerlink" title="4. 创建 Docker 虚拟网络"></a>4. 创建 Docker 虚拟网络</h3><blockquote><p>虚拟网络名称为<code>macnet</code>，驱动为<code>macvlan</code>模式，将 <code>subnet 10.10.10.0</code>修改为你自己主路由的网段，<code>geteway 10.10.10.1</code>修改为你自己的主路由网关】</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建虚拟网络</span>docker network create -d macvlan --subnet<span class="token operator">=</span>10.10.10.0/24 --gateway<span class="token operator">=</span>10.10.10.1 -o parent<span class="token operator">=</span>eth0 macnet</code></pre><h3 id="5-启动-OpenWrt-容器"><a href="#5-启动-OpenWrt-容器" class="headerlink" title="5. 启动 OpenWrt 容器"></a>5. 启动 OpenWrt 容器</h3><blockquote><p>启动 OpenWrt 容器</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 开启容器</span>docker run --restart always -d --network macnet --privileged buddyfly/openwrt-aarch64:latest</code></pre><h3 id="6-查看运行中的-OpenWrt-容器"><a href="#6-查看运行中的-OpenWrt-容器" class="headerlink" title="6. 查看运行中的 OpenWrt 容器"></a>6. 查看运行中的 OpenWrt 容器</h3><blockquote><p>查看运行中的容器</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看运行中的容器</span>docker <span class="token function">ps</span> -a</code></pre><p>运行结果如下</p><pre><code>root@aml4:~# docker ps -aCONTAINER ID        IMAGE                             COMMAND             CREATED             STATUS              PORTS               NAMESf76303c1b9f0        buddyfly/openwrt-aarch64:latest   &quot;/sbin/init&quot;        43 seconds ago      Up 40 seconds                           affectionate_liskovroot@aml4:~#</code></pre><h3 id="7-修改OpenWrt容器的IP地址"><a href="#7-修改OpenWrt容器的IP地址" class="headerlink" title="7. 修改OpenWrt容器的IP地址"></a>7. 修改OpenWrt容器的IP地址</h3><blockquote><p>进入openwrt容器修改network设置</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 进入容器命令行</span>docker <span class="token function">exec</span> -it f76303c1b9f0 /bin/bash</code></pre><p>进入容器命令行结果如下</p><pre><code>root@aml4:~# docker exec -it f763 /bin/bashbash-4.4#</code></pre><blockquote><p>编辑网络配置文件</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 修改网络配置</span><span class="token function">vi</span> /etc/config/network</code></pre><p>修改文件如下 将<code>option ipaddr 192.168.1.1</code> 改为你想作为旁路网关的空闲地址。我的网段为<code>10.10.10.X</code>,共享地址为<code>10.10.10.254</code></p><pre><code>config interface &#39;loopback&#39;        option ifname &#39;lo&#39;        option proto &#39;static&#39;        option ipaddr &#39;127.0.0.1&#39;        option netmask &#39;255.0.0.0&#39;config globals &#39;globals&#39;        option ula_prefix &#39;fd00:6e95:e381::/48&#39;config interface &#39;lan&#39;        option type &#39;bridge&#39;        option ifname &#39;eth0&#39;        option proto &#39;static&#39;        option ipaddr &#39;10.10.10.254&#39;        option netmask &#39;255.255.255.0&#39;        option ip6assign &#39;60&#39;</code></pre><blockquote><p>重启网络服务</p></blockquote><pre class=" language-bash"><code class="language-bash">/etc/init.d/network restart</code></pre><h3 id="8-永久开启网卡混杂模式"><a href="#8-永久开启网卡混杂模式" class="headerlink" title="8. 永久开启网卡混杂模式"></a>8. 永久开启网卡混杂模式</h3><blockquote><p>重启网卡混杂模式会失效，需设为永久开启 修改/etc/network/interfaces文件：</p><p>谨慎操作，可能导致无法访问网络</p><p>添加 <code>up ip link set eth0 promisc on</code></p></blockquote><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589043064/hexo/promisc_tx2nev.png" alt="修改网卡接口配置"></p><h2 id="三、旁路网关配置"><a href="#三、旁路网关配置" class="headerlink" title="三、旁路网关配置"></a>三、旁路网关配置</h2><h3 id="1-登录旁路网关系统"><a href="#1-登录旁路网关系统" class="headerlink" title="1. 登录旁路网关系统"></a>1. 登录旁路网关系统</h3><blockquote><p>用户名 <code>root</code> 密码 <code>password</code></p></blockquote><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589041433/hexo/login_zgy4vg.png" alt="登录界面"></p><h3 id="2-更改系统主题"><a href="#2-更改系统主题" class="headerlink" title="2. 更改系统主题"></a>2. 更改系统主题</h3><blockquote><p>更改系统主题为<code>Argon-Dark</code></p></blockquote><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589043524/hexo/theme_es9ekm.png" alt="更改主题"></p><h3 id="3-更改上级路由"><a href="#3-更改上级路由" class="headerlink" title="3. 更改上级路由"></a>3. 更改上级路由</h3><blockquote><p>点击网络&gt;接口&gt;修改</p></blockquote><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589043893/hexo/lan_smvrcr.png" alt="进入LAN配置"></p><blockquote><p>修改IPv4网关为<code>10.10.10.1</code>,DHCP服务器 勾选 <code>忽略此接口</code></p></blockquote><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589044105/hexo/DHCP_bwtwdk.png" alt="修改上级路由"></p><h3 id="4-网络加速设置"><a href="#4-网络加速设置" class="headerlink" title="4. 网络加速设置"></a>4. 网络加速设置</h3><blockquote><p>开启DNS加速</p></blockquote><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589044491/hexo/ACC_s1tx1m.png" alt="更改主题"></p><h3 id="5-科学上网"><a href="#5-科学上网" class="headerlink" title="5. 科学上网"></a>5. 科学上网</h3><blockquote><p>开启科学上网</p></blockquote><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589044757/hexo/node_moj3rj.png" alt="添加节点"></p><blockquote><p>全局设置</p></blockquote><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589044938/hexo/passwall_gquzdn.png" alt="参数设置"></p><h3 id="6-配置旁路网关"><a href="#6-配置旁路网关" class="headerlink" title="6. 配置旁路网关"></a>6. 配置旁路网关</h3><blockquote><p>局域网中需要科学上网的机器配置旁路网关</p></blockquote><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589045268/hexo/IP_slznx9.png" alt="网关设置"></p><p><img src="https://res.cloudinary.com/baymax-tips/image/upload/v1589045677/hexo/youtube_lpmeny.png" alt="油管测速"></p>]]></content>
      
      
      <categories>
          
          <category> 科学上网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> openwrt </tag>
            
            <tag> 旁路由 </tag>
            
            <tag> 透明网关 </tag>
            
            <tag> 科学上网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/08/hello-world/"/>
      <url>/2020/05/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
