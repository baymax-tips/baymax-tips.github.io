<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="Docker入门系列  10. Docker 镜像的制作 优化 精简"><meta name="description" content=""><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-167468047-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-167468047-1")</script><title>Docker入门系列 10. Docker 镜像的制作 优化 精简 | 小白笔记</title><link rel="icon" type="image/png" href="/favicon.png"><link rel="stylesheet" href="/libs/awesome/css/all.css"><link rel="stylesheet" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" href="/libs/aos/aos.css"><link rel="stylesheet" href="/libs/animate/animate.min.css"><link rel="stylesheet" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" href="/css/matery.css"><link rel="stylesheet" href="/css/my.css"><script src="/libs/jquery/jquery.min.js"></script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="小白笔记" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css"><link rel="stylesheet" href="/css/prism-line-numbers.css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><div><img src="/medias/loading.gif" data-original="/medias/logo.png" class="logo-img" alt="LOGO"> <span class="logo-span">小白笔记</span></div></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fas fa-tags" style="zoom:.6"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fas fa-bookmark" style="zoom:.6"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fas fa-archive" style="zoom:.6"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fas fa-user-circle" style="zoom:.6"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fas fa-comments" style="zoom:.6"></i> <span>留言板</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fas fa-address-book" style="zoom:.6"></i> <span>友情链接</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/loading.gif" data-original="/medias/logo.png" class="logo-img circle responsive-img"><div class="logo-name">小白笔记</div><div class="logo-desc">Never really desperate, only the lost of the soul.</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa-fw fas fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa-fw fas fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa-fw fas fa-comments"></i> 留言板</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa-fw fas fa-address-book"></i> 友情链接</a></li><li><div class="divider"></div></li><li><a href="https://github.com/baymax-tips" class="waves-effect waves-light" target="_blank"><i class="fab fa-github-square fa-fw"></i> Fork Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#0f9d58;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/baymax-tips" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/5.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">Docker入门系列 10. Docker 镜像的制作 优化 精简</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/Docker/"><span class="chip bg-color">Docker</span></a> <a href="/tags/%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1/"><span class="chip bg-color">容器服务</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1/" class="post-category">容器服务</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i> 发布日期:&nbsp;&nbsp; 2020-05-26</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i> 文章字数:&nbsp;&nbsp; 6.3k</div><div class="info-break-policy"><i class="far fa-clock fa-fw"></i> 阅读时长:&nbsp;&nbsp; 25 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="far fa-eye fa-fw"></i> 阅读次数:&nbsp;&nbsp;<span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h2 id="1-Docker镜像制作"><a href="#1-Docker镜像制作" class="headerlink" title="1. Docker镜像制作"></a>1. Docker镜像制作</h2><p>前面几篇文章已经给大家介绍了 Docker 的基本概念，相信大家也会使用 Docker 运行自己想要的容器了。但是只有学会制作镜像，才能将 Docker 应用到我们的项目中去。</p><p><img src="/medias/loading.gif" data-original="https://res.cloudinary.com/baymax-tips/image/upload/v1589436395/hexo/docker/docker-filesystems-multilayer_ug4ouk.png" alt="multilayer"></p><p>docker镜像是除了docker的核心技术之外，也是应用发布的标准格式。一个完整的docker镜像可以支撑一个docker容器的运行，在docker的整个使用过程中，进入一个已经定型的容器之后，就可以在容器中进行操作，最常见的操作就是在容器中安装应用服务，如果要把已经安装的服务进行迁移，就需要把环境及搭建的服务生成新的镜像。</p><p>创建镜像的方法有三种，分别是基于已有镜像创建、基于本地模板创建及基于dockerfile创建。接下来会将这几种方法依次写下来。</p><h3 id="1-1-镜像制作-基于已有镜像创建"><a href="#1-1-镜像制作-基于已有镜像创建" class="headerlink" title="1.1 镜像制作 - 基于已有镜像创建"></a>1.1 镜像制作 - 基于已有镜像创建</h3><p>基于已有镜像创建主要是使用docker commit命令，本质上就是把一个容器里面运行的程序及该程序的运行环境打包起来生成新的镜像。</p><p><strong>命令格式如下：</strong></p><pre><code>docker  commit  [选项]  容器ID/名称  仓库名称:[标签]</code></pre><blockquote><p>常用选项如下：</p><ul><li>-m：说明信息；</li><li>-a：作者信息；</li><li>-p：生成过程中停止容器的运行</li></ul></blockquote><h4 id="基于已有镜像创建新的镜像举例："><a href="#基于已有镜像创建新的镜像举例：" class="headerlink" title="基于已有镜像创建新的镜像举例："></a>基于已有镜像创建新的镜像举例：</h4><p>启动一个镜像，在容器里做修改，然后将修改后的容器提交为新的镜像，需要记住该容器的ID号，如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker ps -a                #查看当前运行的容器</span>
CONTAINER ID        IMAGE                      COMMAND                  CREATED             STATUS              PORTS                       NAMES
c037e7a5734b        docker.io/sameersbn/bind   <span class="token string">"/sbin/entrypoint...."</span>   19 seconds ago      Up 7 seconds        53/tcp, 10000/tcp, 53/udp   hopeful_clarke
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker exec -it c037e7a5734b /bin/bash            #进入该容器</span>
root@c037e7a5734b:/<span class="token comment" spellcheck="true"># echo 11111111111 > /etc/a.txt               #随便写入一个文件</span>
root@c037e7a5734b:/<span class="token comment" spellcheck="true"># exit                      #退出该容器</span>
<span class="token keyword">exit</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker commit -m "newnamed" -a "ljz" c037e7a5734b docker:mynamed</span>
<span class="token comment" spellcheck="true">#使用docker commit命令创建一个新的镜像</span>
sha256:e178f320e4821642bed66d0e61e8a85eedd841cb8a3a84db3d38e7d92d844eae
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker images | grep mynamed          #查看新创建的镜像</span>
docker                        mynamed             e178f320e482        11 seconds ago      323 MB
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker create -it docker:mynamed /bin/bash       #基于新创建的镜像创建一个容器</span>
dc37cf2d6ef754200aea067d7a15c83713f2488dac0913013373809633266f07
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker ps -a               #获取刚刚创建的容器ID号，下面标红的就是</span>
CONTAINER ID        IMAGE                      COMMAND                  CREATED             STATUS              PORTS                       NAMES
<span class="token string">'dc37cf2d6ef7'</span>        docker:mynamed             /sbin/entrypoint<span class="token punctuation">..</span><span class="token punctuation">..</span>   11 seconds ago      Created                                         pensive_williams
c037e7a5734b        docker.io/sameersbn/bind   /sbin/entrypoint<span class="token punctuation">..</span><span class="token punctuation">..</span>   6 minutes ago       Up 5 minutes        53/tcp, 10000/tcp, 53/udp   hopeful_clarke
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker start dc37cf2d6ef7            #启动刚创建的容器</span>
dc37cf2d6ef7
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker exec -it dc37cf2d6ef7 /bin/bash          #查看在之前容器里写入的文件是否存在</span>
root@dc37cf2d6ef7:/<span class="token comment" spellcheck="true"># cat /etc/a.txt </span>
11111111111
<span class="token comment" spellcheck="true">#可以看到新创建的容器中，有在之前容器中创建的文件，说明镜像更改成功</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-镜像制作-基于本地模板创建"><a href="#1-2-镜像制作-基于本地模板创建" class="headerlink" title="1.2 镜像制作 - 基于本地模板创建"></a>1.2 镜像制作 - 基于本地模板创建</h3><p>通过导入操作系统模板文件可以生成镜像，模板可以从OPENVZ开源项目下载,或者 <a href="https://wiki.openvz.org/Download/template/precreated" target="_blank" rel="noopener">https://wiki.openvz.org/Download/template/precreated</a> ,优先使用OPENVZ开源项目那个链接；</p><h4 id="基于本地模板创建举例："><a href="#基于本地模板创建举例：" class="headerlink" title="基于本地模板创建举例："></a>基于本地模板创建举例：</h4><p>下载centos 7的迷你版系统模板，使用docker导入命令导入为本地镜像：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># wget https://download.openvz.org/template/precreated/centos-7-x86_64-minimal.tar.gz             #下载centos7的模板压缩包</span>
                           <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token comment" spellcheck="true">#省略部分内容</span>
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls | grep centos*                  #确认已经下载centos7的模板压缩包</span>
centos-7-x86_64-minimal.tar.gz
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat centos-7-x86_64-minimal.tar.gz | docker import - docker:new  </span>
<span class="token comment" spellcheck="true">#使用docker导入命令导入为本地镜像</span>
sha256:c065d5c0571df48eba3b95b1302494b596cf9f67c24eacc82ff75a9e9c2b7622
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker images | grep new         #查看导入的镜像</span>
docker                        new                 c065d5c0571d        56 minutes ago      435 MB
<span class="token comment" spellcheck="true">#至此，可使用这个镜像创建容器并部署需要的功能，进行使用了。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-镜像制作-基于dockerfile创建"><a href="#1-3-镜像制作-基于dockerfile创建" class="headerlink" title="1.3 镜像制作 - 基于dockerfile创建"></a>1.3 镜像制作 - 基于dockerfile创建</h3><h4 id="1-3-1-Dockerfile-概念"><a href="#1-3-1-Dockerfile-概念" class="headerlink" title="1.3.1 Dockerfile 概念"></a>1.3.1 Dockerfile 概念</h4><p>我们使用 Dockerfile 定义镜像，依赖镜像来运行容器，因此 Dockerfile 是镜像和容器的关键，Dockerfile 可以非常容易的定义镜像内容。Docker 通过读取 Dockerfile 中的指令自动构建图像。</p><p>Dockerfile 由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。它们简化了从头到尾的流程并极大的简化了部署工作。Dockerfile 从 FROM 命令开始，紧接着跟随者各种方法，命令和参数。其产出为一个新的可以用于创建容器的镜像。</p><ul><li><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p></li><li><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，可以解决构建过程无法重复的问题、镜像构建透明性的问题、体积的问题。</p></li><li><p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。有了 Dockerfile，当我们需要定制自己额外的需求时，只需在 Dockerfile 上添加或者修改指令，重新生成 image 即可，省去了敲命令的麻烦。</p></li></ul><h4 id="1-3-2-Dockerfile-文件格式"><a href="#1-3-2-Dockerfile-文件格式" class="headerlink" title="1.3.2 Dockerfile 文件格式"></a>1.3.2 Dockerfile 文件格式</h4><p>Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令、容器启动执行指令。一开始必须要指明所基于的镜像名称，接下来一般会说明维护者信息；后面则是镜像操作指令，例如 RUN 指令。每执行一条RUN 指令，镜像添加新的一层，并提交；最后是 CMD 指令，来指明运行容器时的操作命令。</p><p>Dockerfile文件格式如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">## Dockerfile文件格式</span>
<span class="token comment" spellcheck="true"># This dockerfile uses the ubuntu image</span>
<span class="token comment" spellcheck="true"># VERSION 2 - EDITION 1</span>
<span class="token comment" spellcheck="true"># Author: docker_user</span>
<span class="token comment" spellcheck="true"># Command format: Instruction [arguments / command] ..</span>
<span class="token comment" spellcheck="true"># 1、第一行必须指定 基础镜像信息</span>
FROM ubuntu
<span class="token comment" spellcheck="true"># 2、维护者信息</span>
MAINTAINER docker_user docker_user@email.com
<span class="token comment" spellcheck="true"># 3、镜像操作指令</span>
RUN <span class="token keyword">echo</span> <span class="token string">"deb http://archive.ubuntu.com/ubuntu/ raring main universe"</span><span class="token operator">>></span>/etc/apt/sources.list
RUN <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y nginx
RUN <span class="token keyword">echo</span> <span class="token string">"\ndaemon off;"</span><span class="token operator">>></span>/etc/nginx/nginx.conf
<span class="token comment" spellcheck="true"># 4、容器启动执行指令</span>
CMD /usr/sbin/nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在编写dockerfile时，有严格的格式需要遵循：第一行必须使用FROM指令指明所基于的镜像名称；之后使用MAINTAINER指令说明维护该镜像的用户信息；然后是镜像操作相关指令，如RUN指令，每运行一条指令，都会给基础镜像添加新的一层；最后使用CMD指令来指定启动容器时要运行的命令操作。</p><p>dockerfile有十几条命令可用于构建镜像，其中常见的指令如下：</p><table><thead><tr><th align="center">指令</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">FROM 镜像</td><td align="left">指定新镜像所基于的镜像，第一条指令必须为FROM 指令，每创建一个镜像就需要一条FROM指令</td></tr><tr><td align="center">MAINTAINER 名字</td><td align="left">说明镜像的维护人员信息</td></tr><tr><td align="center">RUN 命令</td><td align="left">在所基于的镜像上执行命令，并提交到新镜像中</td></tr><tr><td align="center">CMD[“要运行的程序”,”参数1”,”参数2”]</td><td align="left">指令启动容器时要运行的命令或脚本，Dockerfile只能有一条CMD命令，如果指定多条则只能最后一条被执行</td></tr><tr><td align="center">EXPOSE 端口号</td><td align="left">指定新镜像加载到Docker时要开启的端口</td></tr><tr><td align="center">ENV 环境变量变量值</td><td align="left">设置一个环境变量的值，会被后面的RUN使用</td></tr><tr><td align="center">ADD 源文件/目录目标文件/目录</td><td align="left">将源文件复制到目标文件，源文件要与Dockerfile位于相同目录中，或者是一个URL</td></tr><tr><td align="center">COPY 源文件/目录目标文件/目录</td><td align="left">将本地主机上的文件/目录复制到目标地点，源文件/目录要与Dockerfile在相同的目录中</td></tr><tr><td align="center">VOLUME[“目录”]</td><td align="left">在容器中创建一个挂载点</td></tr><tr><td align="center">USER 用户名/UID</td><td align="left">指定运行容器的用户</td></tr><tr><td align="center">WORKDIR 路径</td><td align="left">为后续的RUN、CMD、ENTRYPOINT指定工作目录</td></tr><tr><td align="center">ONBUILD 命令</td><td align="left">指定所生成的镜像作为一个基础镜像时所要运行的命令</td></tr></tbody></table><h4 id="1-3-3-构建镜像"><a href="#1-3-3-构建镜像" class="headerlink" title="1.3.3 构建镜像"></a>1.3.3 构建镜像</h4><p>docker build 命令会根据 Dockerfile 文件及上下文构建新 Docker 镜像。构建上下文是指 Dockerfile 所在的本地路径或一个URL（Git仓库地址）。构建上下文环境会被递归处理，所以构建所指定的路径还包括了子目录，而URL还包括了其中指定的子模块。</p><p>将当前目录做为构建上下文时，可以像下面这样使用docker build命令构建镜像：</p><pre class="line-numbers language-bash"><code class="language-bash">docker build <span class="token keyword">.</span>
Sending build context to Docker daemon 6.51 MB
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>说明：构建会在 Docker 后台守护进程（daemon）中执行，而不是 CLI中。构建前，构建进程会将全部内容（递归）发送到守护进程。大多情况下，应该将一个空目录作为构建上下文环境，并将 Dockerfile 文件放在该目录下。</p><p>在构建上下文中使用的 Dockerfile 文件，是一个构建指令文件。为了提高构建性能，可以通过 .dockerignore文件排除上下文目录下不需要的文件和目录。</p><p>在 Docker 构建镜像的第一步，docker CLI 会先在上下文目录中寻找 .dockerignore文件，根据 .dockerignore 文件排除上下文目录中的部分文件和目录，然后把剩下的文件和目录传递给 Docker 服务。</p><p>Dockerfile 一般位于构建上下文的根目录下，也可以通过 -f指定该文件的位置：</p><pre class="line-numbers language-bash"><code class="language-bash">docker build -f /path/to/a/Dockerfile.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构建时，还可以通过 -t参数指定构建成镜像的仓库、标签。</p><h4 id="1-3-4-镜像标签"><a href="#1-3-4-镜像标签" class="headerlink" title="1.3.4 镜像标签"></a>1.3.4 镜像标签</h4><pre class="line-numbers language-bash"><code class="language-bash">docker build -t nginx/v3 <span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果存在多个仓库下，或使用多个镜像标签，就可以使用多个 -t参数：</p><pre class="line-numbers language-bash"><code class="language-bash">docker build -t nginx/v3:1.0.2-t nginx/v3:latest <span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回：</p><pre class="line-numbers language-bash"><code class="language-bash">docker build -t nginx/v3 <span class="token keyword">.</span>
Sending build context to Docker daemon 2.048 kB
Error response from daemon:Unknown instruction: RUNCMD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="1-3-5-缓存"><a href="#1-3-5-缓存" class="headerlink" title="1.3.5 缓存"></a>1.3.5 缓存</h4><p>Docker 守护进程会一条一条的执行 Dockerfile 中的指令，而且会在每一步提交并生成一个新镜像，最后会输出最终镜像的ID。生成完成后，Docker 守护进程会自动清理你发送的上下文。 Dockerfile文件中的每条指令会被独立执行，并会创建一个新镜像，RUN cd /tmp等命令不会对下条指令产生影响。 Docker 会重用已生成的中间镜像，以加速docker build的构建速度。以下是一个使用了缓存镜像的执行过程：</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker build -t svendowideit/ambassador <span class="token keyword">.</span>
Sending build context to Docker daemon 15.36 kB
Step1/4: FROM alpine:3.2
---<span class="token operator">></span>31f630c65071
Step2/4: MAINTAINER SvenDowideit@home.org.au
---<span class="token operator">></span>Using cache
---<span class="token operator">></span>2a1c91448f5f
Step3/4: RUN apk update <span class="token operator">&amp;&amp;</span> apk add socat <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> -r /var/cache/
---<span class="token operator">></span>Using cache
---<span class="token operator">></span>21ed6e7fbb73
Step4/4: CMD <span class="token function">env</span> <span class="token operator">|</span> <span class="token function">grep</span> _TCP<span class="token operator">=</span><span class="token operator">|</span><span class="token punctuation">(</span>sed <span class="token string">'s/.*_PORT_\([0-9]*\)_TCP=tcp:\/\/\(.*\):\(.*\)/socat -t 100000000 TCP4-LISTEN:\1,fork,reuseaddr TCP4:\2:\3 \&amp;/'</span><span class="token operator">&amp;&amp;</span> <span class="token keyword">echo</span> wait<span class="token punctuation">)</span><span class="token operator">|</span> sh
---<span class="token operator">></span>Using cache
---<span class="token operator">></span>7ea8aef582cc
Successfully built 7ea8aef582cc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构建缓存仅会使用本地父生成链上的镜像，如果不想使用本地缓存的镜像，也可以通过 –cache-from指定缓存。指定后将不再使用本地生成的镜像链，而是从镜像仓库中下载。</p><h4 id="1-3-6-寻找缓存的逻辑"><a href="#1-3-6-寻找缓存的逻辑" class="headerlink" title="1.3.6 寻找缓存的逻辑"></a>1.3.6 寻找缓存的逻辑</h4><p>Docker 寻找缓存的逻辑其实就是树型结构根据 Dockerfile 指令遍历子节点的过程。下图可以说明这个逻辑。</p><pre class="line-numbers language-bash"><code class="language-bash">FROM base_image:version Dockerfile:
+----------+ FROM base_image:version
<span class="token operator">|</span>base image<span class="token operator">|</span> RUN cmd1 --<span class="token operator">></span>use cache because we found base image
+-----X----+ RUN cmd11 --<span class="token operator">></span>use cache because we found cmd1
/ \
/ \
RUN cmd1 RUN cmd2 Dockerfile:
+------++------+ FROM base_image:version
<span class="token operator">|</span>image1<span class="token operator">||</span>image2<span class="token operator">|</span> RUN cmd2 --<span class="token operator">></span>use cache because we found base image
+---X--++------+ RUN cmd21 --<span class="token operator">></span>notuse cache because there's no child node
/ \ running cmd21, so we build a new image here
/ \
RUN cmd11 RUN cmd12
+-------+ +-------+
<span class="token operator">|</span>image11<span class="token operator">|</span> <span class="token operator">|</span>image12<span class="token operator">|</span>
+-------+ +-------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大部分指令可以根据上述逻辑去寻找缓存，除了 ADD 和 COPY 。这两个指令会复制文件内容到镜像内，除了指令相同以外，Docker 还会检查每个文件内容校验(不包括最后修改时间和最后访问时间)，如果校验不一致，则不会使用缓存。</p><p>除了这两个命令，Docker 并不会去检查容器内的文件内容，比如 RUN apt-get -y update，每次执行时文件可能都不一样，但是 Docker 认为命令一致，会继续使用缓存。这样一来，以后构建时都不会再重新运行 apt-get -y update。</p><p>如果 Docker 没有找到当前指令的缓存，则会构建一个新的镜像，并且之后的所有指令都不会再去寻找缓存。</p><h4 id="1-3-6-简单示例"><a href="#1-3-6-简单示例" class="headerlink" title="1.3.6 简单示例"></a>1.3.6 简单示例</h4><p>接下来用一个简单的示例来感受一下 Dockerfile 是如何用来构建镜像启动容器。我们以定制 nginx 镜像为例，在一个空白目录中，建立一个文本文件，并命名为 Dockerfile：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> mynginx
<span class="token function">cd</span> mynginx
<span class="token function">vi</span> Dockerfile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>构建一个 Dockerfile 文件内容为：</p><pre class="line-numbers language-bash"><code class="language-bash">FROM nginx
RUN <span class="token keyword">echo</span> <span class="token string">'&lt;h1>Hello, Docker!&lt;/h1>'</span><span class="token operator">></span>/usr/share/nginx/html/index.html
<span class="token function">vi</span> Dockerfile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个 Dockerfile 很简单，一共就两行涉及到了两条指令：FROM 和 RUN，FROM 表示获取指定基础镜像，RUN 执行命令，在执行的过程中重写了 nginx 的默认页面信息，将信息替换为：Hello, Docker!。</p><p>在 Dockerfile 文件所在目录执行：</p><pre class="line-numbers language-bash"><code class="language-bash">docker build -t nginx:v1 <span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令最后有一个. 表示当前目录</p><p>构建完成之后，使用 docker images 命令查看所有镜像，如果存在 REPOSITORY 为 nginx 和 TAG 是 v1 的信息，就表示构建成功。</p><pre class="line-numbers language-bash"><code class="language-bash">docker images
REPOSITORY TAG IMAGE ID CREATED SIZE
nginx v1 8c92471de2cc6 minutes ago 108.6 MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接下来使用 docker run 命令来启动容器</p><pre class="line-numbers language-bash"><code class="language-bash">docker run --name docker_nginx_v1 -d -p 80:80 nginx:v1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条命令会用 nginx 镜像启动一个容器，命名为 docker_nginx_v1，并且映射了 80 端口，这样我们可以用浏览器去访问这个 nginx 服务器： <a href="http://192.168.0.54/，页面返回信息：" target="_blank" rel="noopener">http://192.168.0.54/，页面返回信息：</a></p><p>这样一个简单使用 Dockerfile 构建镜像，运行容器的示例就完成了！</p><h2 id="2-Docker镜像的精简与优化"><a href="#2-Docker镜像的精简与优化" class="headerlink" title="2. Docker镜像的精简与优化"></a>2. Docker镜像的精简与优化</h2><p>精简Docker镜像的好处很多，不仅可以节省存储空间和带宽，还能减少安全隐患。优化镜像大小的手段多种多样，因服务所使用的基础开发语言不同而有差异。我们将介绍精简Docker镜像的几种通用方法。</p><h3 id="精简Docker镜像大小的必要性"><a href="#精简Docker镜像大小的必要性" class="headerlink" title="精简Docker镜像大小的必要性"></a>精简Docker镜像大小的必要性</h3><p>Docker镜像由很多镜像层（Layers）组成（最多127层），镜像层依赖于一系列的底层技术，比如文件系统（filesystems）、写时复制（copy-on-write）、联合挂载（union mounts）等技术，你可以查看Docker社区文档以了解更多有关Docker存储驱动的内容，这里就不再赘述技术细节。总的来说，Dockerfile中的每条指令都会创建一个镜像层，继而会增加整体镜像的尺寸。</p><p>下面是精简Docker镜像尺寸的好处：</p><ul><li>减少构建时间</li><li>减少磁盘使用量</li><li>减少下载时间</li><li>因为包含文件少，攻击面减小，提高了安全性</li><li>提高部署速度</li></ul><h3 id="2-1-优化基础镜像"><a href="#2-1-优化基础镜像" class="headerlink" title="2.1 优化基础镜像"></a>2.1 优化基础镜像</h3><p>优化基础镜像的方法就是选用合适的更小的基础镜像，常用的 Linux 系统镜像一般有 Ubuntu、CentOs、Alpine，其中Alpine更推荐使用。大小对比如下：</p><pre class="line-numbers language-bash"><code class="language-bash">➜ docker images
REPOSITORY         TAG             IMAGE ID            CREATED             SIZE
ubuntu             latest        74f8760a2a8b        8 days ago          82.4MB
alpine             latest        11cd0b38bc3c        2 weeks ago         4.41MB
centos               7           49f7960eb7e4        7 weeks ago         200MB
debian             latest        3bbb526d2608        8 days ago          101MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Alpine是一个高度精简又包含了基本工具的轻量级Linux发行版，基础镜像只有4.41M，各开发语言和框架都有基于Alpine制作的基础镜像，强烈推荐使用它。</p><p>查看上面的镜像尺寸对比结果，你会发现最小的镜像也有4.41M，那么有办法构建更小的镜像吗？答案是肯定的，例如 gcr.io/google_containers/pause-amd64:3.1 镜像仅有742KB。为什么这个镜像能这么小？在为大家解密之前，再推荐两个基础镜像：</p><p><strong>1. scratch镜像</strong></p><p>scratch是一个空镜像，只能用于构建其他镜像，比如你要运行一个包含所有依赖的二进制文件，如Golang程序，可以直接使用scratch作为基础镜像。现在给大家展示一下上文提到的Google pause镜像Dockerfile：</p><pre><code>FROM scratch
ARG ARCH
ADD bin/pause-${ARCH} /pause
ENTRYPOINT ["/pause"]</code></pre><p>Google pause镜像使用了scratch作为基础镜像，这个镜像本身是不占空间的，使用它构建的镜像大小几乎和二进制文件本身一样大，所以镜像非常小。当然在我们的Golang程序中也会使用。对于一些Golang/C程序，可能会依赖一些动态库，你可以使用自动提取动态库工具，比如ldd、linuxdeployqt等提取所有动态库，然后将二进制文件和依赖动态库一起打包到镜像中。</p><p><strong>2. busybox镜像</strong></p><p>scratch是个空镜像，如果希望镜像里可以包含一些常用的Linux工具，busybox镜像是个不错选择，镜像本身只有1.16M，非常便于构建小镜像。</p><h3 id="2-2-串联-Dockerfile-指令"><a href="#2-2-串联-Dockerfile-指令" class="headerlink" title="2.2 串联 Dockerfile 指令"></a>2.2 串联 Dockerfile 指令</h3><p>大家在定义Dockerfile时，如果太多的使用RUN指令，经常会导致镜像有特别多的层，镜像很臃肿，而且甚至会碰到超出最大层数（127层）限制的问题，遵循 Dockerfile 最佳实践，我们应该把多个命令串联合并为一个 RUN（通过运算符&amp;&amp;和/ 来实现），每一个 RUN 要精心设计，确保安装构建最后进行清理，这样才可以降低镜像体积，以及最大化的利用构建缓存。</p><p>下面是一个优化前Dockerfile：</p><pre class="line-numbers language-bash"><code class="language-bash">FROM ubuntu

ENV VER     3.0.0  
ENV TARBALL http://download.redis.io/releases/redis-<span class="token variable">$VER</span>.tar.gz  
<span class="token operator">==</span><span class="token operator">></span> Install curl and helper tools<span class="token punctuation">..</span>.
RUN <span class="token function">apt-get</span> update  
RUN <span class="token function">apt-get</span> <span class="token function">install</span> -y  curl <span class="token function">make</span> gcc  
<span class="token operator">==</span><span class="token operator">></span> Download, compile, and install<span class="token punctuation">..</span>.
RUN curl -L <span class="token variable">$TARBALL</span> <span class="token operator">|</span> <span class="token function">tar</span> zxv  
WORKDIR  redis-<span class="token variable">$VER</span>  
RUN <span class="token function">make</span>  
RUN <span class="token function">make</span> <span class="token function">install</span>  
<span class="token punctuation">..</span>.
<span class="token operator">==</span><span class="token operator">></span> Clean up<span class="token punctuation">..</span>.
WORKDIR /  
RUN <span class="token function">apt-get</span> remove -y --auto-remove curl <span class="token function">make</span> gcc  
RUN <span class="token function">apt-get</span> clean  
RUN <span class="token function">rm</span> -rf /var/lib/apt/lists/*  /redis-<span class="token variable">$VER</span>  
<span class="token punctuation">..</span>.
CMD <span class="token punctuation">[</span><span class="token string">"redis-server"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构建镜像，名称叫 test/test:0.1。</p><p>我们对Dockerfile做优化，优化后Dockerfile：</p><pre class="line-numbers language-bash"><code class="language-bash">FROM ubuntu

ENV VER     3.0.0  
ENV TARBALL http://download.redis.io/releases/redis-<span class="token variable">$VER</span>.tar.gz

RUN <span class="token keyword">echo</span> <span class="token string">"==> Install curl and helper tools..."</span>  <span class="token operator">&amp;&amp;</span> \  
<span class="token function">apt-get</span> update                      <span class="token operator">&amp;&amp;</span> \
<span class="token function">apt-get</span> <span class="token function">install</span> -y  curl <span class="token function">make</span> gcc   <span class="token operator">&amp;&amp;</span> \
<span class="token keyword">echo</span> <span class="token string">"==> Download, compile, and install..."</span>  <span class="token operator">&amp;&amp;</span> \
curl -L <span class="token variable">$TARBALL</span> <span class="token operator">|</span> <span class="token function">tar</span> zxv  <span class="token operator">&amp;&amp;</span> \
<span class="token function">cd</span> redis-<span class="token variable">$VER</span>               <span class="token operator">&amp;&amp;</span> \
<span class="token function">make</span>                        <span class="token operator">&amp;&amp;</span> \
<span class="token function">make</span> <span class="token function">install</span>                <span class="token operator">&amp;&amp;</span> \
<span class="token keyword">echo</span> <span class="token string">"==> Clean up..."</span>  <span class="token operator">&amp;&amp;</span> \
<span class="token function">apt-get</span> remove -y --auto-remove curl <span class="token function">make</span> gcc  <span class="token operator">&amp;&amp;</span> \
<span class="token function">apt-get</span> clean                                  <span class="token operator">&amp;&amp;</span> \
<span class="token function">rm</span> -rf /var/lib/apt/lists/*  /redis-<span class="token variable">$VER</span>
<span class="token punctuation">..</span>.
CMD <span class="token punctuation">[</span><span class="token string">"redis-server"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构建镜像，名称叫 test/test:0.2。</p><p>对比两个镜像大小：</p><pre class="line-numbers language-bash"><code class="language-bash">root@k8s-master:/tmp/iops<span class="token comment" spellcheck="true">#docker images</span>
REPOSITORY       TAG           IMAGE ID            CREATED             SIZE
test/test        0.2         58468c0222ed        2 minutes ago       98.1MB
test/test        0.1         e496cf7243f2        6 minutes ago       307MB
root@k8s-master:/tmp/iops<span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，将多条RUN命令串联起来构建的镜像大小是每条命令分别RUN的三分之一。</p><blockquote><p>提示：为了应对镜像中存在太多镜像层，Docker 1.13版本以后，提供了一个压扁镜像功能，即将 Dockerfile 中所有的操作压缩为一层。这个特性还处于实验阶段，Docker默认没有开启，如果要开启，需要在启动Docker时添加-experimental 选项，并在Docker build 构建镜像时候添加 –squash 。我们不推荐使用这个办法，请在撰写 Dockerfile 时遵循最佳实践编写，不要试图用这种办法去压缩镜像。</p></blockquote><h3 id="2-3-使用多阶段构建"><a href="#2-3-使用多阶段构建" class="headerlink" title="2.3 使用多阶段构建"></a>2.3 使用多阶段构建</h3><p>Dockerfile中每条指令都会为镜像增加一个镜像层，并且你需要在移动到下一个镜像层之前清理不需要的组件。实际上，有一个Dockerfile用于开发（其中包含构建应用程序所需的所有内容）以及一个用于生产的瘦客户端，它只包含你的应用程序以及运行它所需的内容。这被称为“建造者模式”。Docker 17.05.0-ce版本以后支持多阶段构建。使用多阶段构建，你可以在Dockerfile中使用多个FROM语句，每条FROM指令可以使用不同的基础镜像，这样您可以选择性地将服务组件从一个阶段COPY到另一个阶段，在最终镜像中只保留需要的内容。</p><p>下面是一个使用COPY –from 和 FROM … AS … 的Dockerfile：</p><pre><code># Compile
FROM golang:1.9.0 AS builder
WORKDIR /go/src/v9.git...com/.../k8s-monitor
COPY . .
WORKDIR /go/src/v9.git...com/.../k8s-monitor
RUN make build
RUN mv k8s-monitor /root
Package
Use scratch image
FROM scratch
WORKDIR /root/
COPY --from=builder /root .
EXPOSE 8080
CMD ["/root/k8s-monitor"] </code></pre><p>构建镜像，你会发现生成的镜像只有上面COPY 指令指定的内容，镜像大小只有2M。这样在以前使用两个Dockerfile（一个Dockerfile用于开发和一个用于生产的瘦客户端），现在使用多阶段构建就可以搞定。</p><h3 id="2-4-构建业务服务镜像技巧"><a href="#2-4-构建业务服务镜像技巧" class="headerlink" title="2.4 构建业务服务镜像技巧"></a>2.4 构建业务服务镜像技巧</h3><p>Docker在build镜像的时候，如果某个命令相关的内容没有变化，会使用上一次缓存（cache）的文件层，在构建业务镜像的时候可以注意下面两点：</p><ul><li><p>不变或者变化很少的体积较大的依赖库和经常修改的自有代码分开；</p></li><li><p>因为cache缓存在运行Docker build命令的本地机器上，建议固定使用某台机器来进行Docker build，以便利用cache。</p></li></ul><p>下面是构建Spring Boot应用镜像的例子，用来说明如何分层。其他类型的应用，比如Java WAR包，Nodejs的npm模块等，可以采取类似的方式。</p><ol><li><p>在Dockerfile所在目录，解压缩maven生成的jar包。</p><pre class="line-numbers language-bash"><code class="language-bash">unzip <span class="token operator">&lt;</span>path-to-app-jar<span class="token operator">></span>.jar -d app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>Dockerfile我们把应用的内容分成4个部分COPY到镜像里面：其中前面3个基本不变，第4个是经常变化的自有代码。最后一行是解压缩后，启动spring boot应用的方式。</p><pre class="line-numbers language-bash"><code class="language-bash">FROM openjdk:8-jre-alpine

LABEL maintainer <span class="token string">"opl-xws@xiaomi.com"</span>
COPY app/BOOT-INF/lib/ /app/BOOT-INF/lib/
COPY app/org /app/org
COPY app/META-INF /app/META-INF
COPY app/BOOT-INF/classes /app/BOOT-INF/classes
EXPOSE 8080
CMD <span class="token punctuation">[</span><span class="token string">"/usr/bin/java"</span>, <span class="token string">"-cp"</span>, <span class="token string">"/app"</span>, <span class="token string">"org.springframework.boot.loader.JarLauncher"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样在构建镜像时候可大大提高构建速度。</p></li></ol><h3 id="2-5-其他优化办法"><a href="#2-5-其他优化办法" class="headerlink" title="2.5 其他优化办法"></a>2.5 其他优化办法</h3><p><strong>1、RUN命令中执行apt、apk或者yum类工具技巧</strong></p><p>如果在RUN命令中执行apt、apk或者yum类工具，可以借助这些工具提供的一些小技巧来减少镜像层数量及镜像大小。举几个例子：</p><ul><li><p>在执行apt-get install -y 时增加选项— no-install-recommends ，可以不用安装建议性（非必须）的依赖，也可以在执行apk add 时添加选项–no-cache 达到同样效果；</p></li><li><p>执行yum install -y 时候， 可以同时安装多个工具，比如yum install -y gcc gcc-c++ make …。将所有yum install 任务放在一条RUN命令上执行，从而减少镜像层的数量；</p></li><li><p>组件的安装和清理要串联在一条指令里面，如 apk –update add php7 &amp;&amp; rm -rf /var/cache/apk/* ，因为Dockerfile的每条指令都会产生一个文件层，如果将apk add … 和 rm -rf … 命令分开，清理无法减小apk命令产生的文件层的大小。 Ubuntu或Debian可以使用 rm -rf /var/lib/apt/lists/* 清理镜像中缓存文件；CentOS等系统使用yum clean all 命令清理。</p></li></ul><p><strong>2、压缩镜像</strong></p><p>Docker自带的一些命令还能协助压缩镜像，比如export和import</p><pre><code>$ docker run -d test/test:0.2
$ docker export 747dc0e72d13 | docker import - test/test:0.3</code></pre><p>使用这种方式需要先将容器运行起来，而且这个过程中会丢失镜像原有的一些信息，比如：导出端口，环境变量，默认指令。</p><p>查看这两个镜像history信息，如下，可以看到test/test:0.3 丢失了所有的镜像层信息：</p><pre><code>root@k8s-master:/tmp/iops# docker history test/test:0.3
IMAGE               CREATED             CREATED BY          SIZE                COMMENT
6fb3f00b7a72        15 seconds ago                          84.7MB              Imported from -
root@k8s-master:/tmp/iops# docker history test/test:0.2
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
58468c0222ed        2 hours ago         /bin/sh -c #(nop)  CMD ["redis-server"]         0B       
1af7ffe3d163        2 hours ago         /bin/sh -c echo "==&gt; Install curl and helper…   15.7MB   
8bac6e733d54        2 hours ago         /bin/sh -c #(nop)  ENV TARBALL=http://downlo…   0B       
793282f3ef7a        2 hours ago         /bin/sh -c #(nop)  ENV VER=3.0.0                0B       
74f8760a2a8b        8 days ago          /bin/sh -c #(nop)  CMD ["/bin/bash"]            0B       
&lt;missing&gt;           8 days ago          /bin/sh -c mkdir -p /run/systemd &amp;&amp; echo 'do…   7B
&lt;missing&gt;           8 days ago          /bin/sh -c sed -i 's/^#\s*\(deb.*universe\)$…   2.76kB
&lt;missing&gt;           8 days ago          /bin/sh -c rm -rf /var/lib/apt/lists/*          0B
&lt;missing&gt;           8 days ago          /bin/sh -c set -xe   &amp;&amp; echo '#!/bin/sh' &gt; /…   745B    
&lt;missing&gt;           8 days ago          /bin/sh -c #(nop) ADD file:5fabb77ea8d61e02d…   82.4MB   
root@k8s-master:/tmp/iops#</code></pre><script>document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });</script></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者:</i></span> <span class="reprint-info"><a href="/about" rel="external nofollow noreferrer">Baymax</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接:</i></span> <span class="reprint-info"><a href="https://baymax.tips/posts/64811.html">https://baymax.tips/posts/64811.html</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明:</i></span> <span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="/about" target="_blank">Baymax</a> !</span></div></div><script async defer>document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/Docker/"><span class="chip bg-color">Docker</span></a> <a href="/tags/%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1/"><span class="chip bg-color">容器服务</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div><style>#reward{margin:40px 0;text-align:center}#reward .reward-link{font-size:1.4rem;line-height:38px}#reward .btn-floating:hover{box-shadow:0 6px 12px rgba(0,0,0,.2),0 5px 15px rgba(0,0,0,.2)}#rewardModal{width:320px;height:350px}#rewardModal .reward-title{margin:15px auto;padding-bottom:5px}#rewardModal .modal-content{padding:10px}#rewardModal .close{position:absolute;right:15px;top:15px;color:rgba(0,0,0,.5);font-size:1.3rem;line-height:20px;cursor:pointer}#rewardModal .close:hover{color:#ef5350;transform:scale(1.3);-moz-transform:scale(1.3);-webkit-transform:scale(1.3);-o-transform:scale(1.3)}#rewardModal .reward-tabs{margin:0 auto;width:210px}.reward-tabs .tabs{height:38px;margin:10px auto;padding-left:0}.reward-content ul{padding-left:0!important}.reward-tabs .tabs .tab{height:38px;line-height:38px}.reward-tabs .tab a{color:#fff;background-color:#ccc}.reward-tabs .tab a:hover{background-color:#ccc;color:#fff}.reward-tabs .wechat-tab .active{color:#fff!important;background-color:#22ab38!important}.reward-tabs .alipay-tab .active{color:#fff!important;background-color:#019fe8!important}.reward-tabs .reward-img{width:210px;height:210px}</style><div id="reward"><a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a><div id="rewardModal" class="modal"><div class="modal-content"><a class="close modal-close"><i class="fas fa-times"></i></a><h4 class="reward-title">你的赏识是我前进的动力</h4><div class="reward-content"><div class="reward-tabs"><ul class="tabs row"><li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li><li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li></ul><div id="alipay"><img src="/medias/loading.gif" data-original="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码"></div><div id="wechat"><img src="/medias/loading.gif" data-original="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码"></div></div></div></div></div></div><script>$(function(){$(".tabs").tabs()})</script></div></div><link rel="stylesheet" href="/libs/gitalk/gitalk.css"><link rel="stylesheet" href="/css/my-gitalk.css"><div class="card gitalk-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="gitalk-container" class="card-content"></div></div><script src="/libs/gitalk/gitalk.min.js"></script><script>let gitalk = new Gitalk({
        clientID: '409bf7f6a2a9bcc0f9e6',
        clientSecret: '1cafe266ac7e32c87692df3d52b9a16b773e8c31',
        repo: 'baymax-tips.github.io',
        owner: 'baymax-tips',
        admin: "baymax-tips",
        id: '2020-05-26T22-19-29',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i> &nbsp;上一篇</div><div class="card"><a href="/posts/23288.html"><div class="card-image"><img src="/medias/loading.gif" data-original="/medias/featureimages/14.jpg" class="responsive-img" alt="Flutter 学习计划 1. Flutter 简介与开发环境"> <span class="card-title">Flutter 学习计划 1. Flutter 简介与开发环境</span></div></a><div class="card-content article-content"><div class="summary block-with-text">一、 Flutter简介Flutter 是 Google推出并开源的移动应用开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart语言开发 App，一套代码同时运行在 iOS 和 Android平台。 Flutter提供了丰富的组件</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2020-05-27</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/Flutter/" class="post-category">Flutter</a></span></div></div><div class="card-action article-tags"><a href="/tags/Flutter/"><span class="chip bg-color">Flutter</span></a> <a href="/tags/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8/"><span class="chip bg-color">移动应用</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/posts/37415.html"><div class="card-image"><img src="/medias/loading.gif" data-original="/medias/featureimages/10.jpg" class="responsive-img" alt="Docker入门系列  9. Docker 容器的数据管理  数据卷 绑定挂载 临时挂载"> <span class="card-title">Docker入门系列 9. Docker 容器的数据管理 数据卷 绑定挂载 临时挂载</span></div></a><div class="card-content article-content"><div class="summary block-with-text">因为容器技术，重新构建并运行应用变得容易且快速，容器化应用基本是无需进一步配置的（已经打包好所有依赖并且已配置），只需PULL，然后Deploy（也许还需要一份docker-compose.yml）就好。我们无需太担心硬件，OS，库以及应用</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2020-05-25</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1/" class="post-category">容器服务</a></span></div></div><div class="card-action article-tags"><a href="/tags/Docker/"><span class="chip bg-color">Docker</span></a> <a href="/tags/%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1/"><span class="chip bg-color">容器服务</span></a></div></div></div></div></article></div><script src="/libs/codeBlock/codeBlockFuction.js"></script><script src="/libs/codeBlock/codeLang.js"></script><script src="/libs/codeBlock/codeCopy.js"></script><script src="/libs/codeBlock/codeShrink.js"></script><style>code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });</script></main><footer class="page-footer bg-color"><link rel="stylesheet" href="/libs/aplayer/APlayer.min.css"><style>.aplayer .aplayer-lrc p{display:none;font-size:12px;font-weight:700;line-height:16px!important}.aplayer .aplayer-lrc p.aplayer-lrc-current{display:none;font-size:15px;color:#42b983}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{left:-66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover{left:0!important}</style><div><div class="row"><meting-js class="col l8 offset-l2 m10 offset-m1 s12" server="netease" type="playlist" id="503838841" fixed="true" autoplay theme="#42b983" loop order="random" preload="auto" volume="0.7" list-folded="true"></meting-js></div></div><script src="/libs/aplayer/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><div class="container row center-align" style="margin-bottom:0!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019</span> <a href="/about" target="_blank">Baymax</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><span id="busuanzi_container_site_pv">|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次</span> <span id="busuanzi_container_site_uv">|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br><br></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/baymax-tips" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i></a><a href="mailto:baymax.tips@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i></a><a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1104559822" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1104559822" data-position="top" data-delay="50"><i class="fab fa-qq"></i></a><a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fas fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i> &nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script>$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-arrow-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?0c003470f128eba63e9f505647bc17bd";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/libs/others/clicklove.js" async></script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script src="/libs/background/ribbon-dynamic.js" async></script><script src="/libs/instantpage/instantpage.js" type="module"></script><script>window.imageLazyLoadSetting={isSPA:!1,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=i;var e=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=r[a].getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight+240||document.documentElement.clientHeight+240)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e()},n.src=i}()}i(),n.addEventListener("scroll",function(){var t,e;t=i,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script></body></html>