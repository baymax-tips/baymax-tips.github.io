<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="Docker入门系列  5. Docker 容器网络的概念及网络配置 覆盖网络"><meta name="description" content=""><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-167468047-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-167468047-1")</script><title>Docker入门系列 5. Docker 容器网络的概念及网络配置 覆盖网络 | 小白笔记</title><link rel="icon" type="image/png" href="/favicon.png"><link rel="stylesheet" href="/libs/awesome/css/all.css"><link rel="stylesheet" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" href="/libs/aos/aos.css"><link rel="stylesheet" href="/libs/animate/animate.min.css"><link rel="stylesheet" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" href="/css/matery.css"><link rel="stylesheet" href="/css/my.css"><script src="/libs/jquery/jquery.min.js"></script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="小白笔记" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css"><link rel="stylesheet" href="/css/prism-line-numbers.css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><div><img src="/medias/loading.gif" data-original="/medias/logo.png" class="logo-img" alt="LOGO"> <span class="logo-span">小白笔记</span></div></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fas fa-tags" style="zoom:.6"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fas fa-bookmark" style="zoom:.6"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fas fa-archive" style="zoom:.6"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fas fa-user-circle" style="zoom:.6"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fas fa-comments" style="zoom:.6"></i> <span>留言板</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fas fa-address-book" style="zoom:.6"></i> <span>友情链接</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/medias/loading.gif" data-original="/medias/logo.png" class="logo-img circle responsive-img"><div class="logo-name">小白笔记</div><div class="logo-desc">Never really desperate, only the lost of the soul.</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa-fw fas fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa-fw fas fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa-fw fas fa-comments"></i> 留言板</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa-fw fas fa-address-book"></i> 友情链接</a></li><li><div class="divider"></div></li><li><a href="https://github.com/baymax-tips" class="waves-effect waves-light" target="_blank"><i class="fab fa-github-square fa-fw"></i> Fork Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#0f9d58;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/baymax-tips" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/medias/featureimages/18.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">Docker入门系列 5. Docker 容器网络的概念及网络配置 覆盖网络</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/Docker/"><span class="chip bg-color">Docker</span></a> <a href="/tags/%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1/"><span class="chip bg-color">容器服务</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1/" class="post-category">容器服务</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i> 发布日期:&nbsp;&nbsp; 2020-05-24</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i> 文章字数:&nbsp;&nbsp; 7.2k</div><div class="info-break-policy"><i class="far fa-clock fa-fw"></i> 阅读时长:&nbsp;&nbsp; 28 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="far fa-eye fa-fw"></i> 阅读次数:&nbsp;&nbsp;<span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h2 id="1-使用覆盖网络"><a href="#1-使用覆盖网络" class="headerlink" title="1. 使用覆盖网络"></a>1. 使用覆盖网络</h2><p>覆盖网络驱动程序在多个 Docker 守护进程主机之间创建一个分布式网络。 这个网络位于(覆盖)主机特定网络的顶部，允许连接到它的容器(包括群服务容器)在启用加密时进行安全通信。 Docker 透明地处理每个数据包与正确的 Docker 守护进程主机和正确的目标容器之间的路由。。</p><p>当你初始化一个群或者将一个 Docker 主机加入到一个已经存在的群中时，会在 Docker 主机上创建两个新的网络:</p><ul><li><p>一个称为<code>ingress</code>的覆盖网络，用于处理与群体服务有关的控制和数据流。当您创建一个群服务并且不将其连接到用户定义的覆盖网络时，默认情况下它将连接到网络<code>ingress</code> 。</p></li><li><p>一个名为<code>docker_gwbridge</code>的桥接网络，它将各个独立的Docker守护程序连接到该集群中的其他守护程序。</p></li></ul><p>您可以使用 <code>docker network create</code> 创建用户定义的覆盖网络，就像您可以创建用户定义的桥接网络一样。 服务或容器可以同时连接到多个网络。 服务或容器只能通过它们各自连接的网络进行通信。</p><p>虽然可以将群服务和独立容器连接到覆盖网络，但默认行为和配置问题是不同的。 基于这个原因，这个主题的其余部分被分为适用于所有覆盖网络的操作，适用于群服务网络的操作，以及适用于独立容器使用的覆盖网络的操作。</p><h2 id="2-所有覆盖网络的操作"><a href="#2-所有覆盖网络的操作" class="headerlink" title="2. 所有覆盖网络的操作"></a>2. 所有覆盖网络的操作</h2><h3 id="2-1-创建覆盖网络"><a href="#2-1-创建覆盖网络" class="headerlink" title="2.1 创建覆盖网络"></a>2.1 创建覆盖网络</h3><blockquote><p><strong>先决条件：</strong></p><ul><li><p>使用覆盖网络的Docker守护程序的防火墙规则</p><p>你需要下面的端口对来往于参与覆盖网络的每个 Docker 主机的通信开放:</p><ul><li>用于集群管理通信的 TCP 端口2377</li><li>用于节点间通信的 TCP 和 UDP 端口7946</li><li>用于覆盖网络流量的 UDP 端口4789</li></ul></li><li><p>在创建覆盖网络之前，您需要使用 Docker swarm init 将 Docker 守护进程初始化为一个群管理器，或者使用 Docker swarm join 将其加入到现有的群中。 这两者中的任何一个都会创建默认的入口覆盖网络，该网络默认由群服务使用。 你需要这样做，即使你从来没有计划使用群服务。 然后，您可以创建其他用户定义的覆盖网络。</p></li></ul></blockquote><p>要创建一个覆盖网络来使用群服务，可以使用如下命令:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create -d overlay my-overlay<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要创建一个覆盖网络，它可以被群服务或独立容器用来与运行在其他 Docker 守护进程上的其他独立容器进行通信，添加<code>--attachable</code>标志：</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create -d overlay --attachable my-attachable-overlay<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您可以指定IP地址范围，子网，网关和其他选项。</p><h3 id="2-1-加密覆盖网络上的流量"><a href="#2-1-加密覆盖网络上的流量" class="headerlink" title="2.1 加密覆盖网络上的流量"></a>2.1 加密覆盖网络上的流量</h3><p>在 GCM 模式下，所有群服务管理流量默认情况下使用 AES 算法进行加密。 群中的管理器节点每12小时轮换用于加密传播协议数据的密钥。</p><p>要加密应用程序数据，在创建覆盖网络时添加<code>--opt encrypted</code>。这样就可以在 vxlan 级别实现 IPSEC 加密。 这种加密会带来不可忽视的性能损失，因此在生产中使用此选项之前应该对其进行测试。</p><p>当您启用覆盖加密时，Docker 会在所有节点之间创建 IPSEC 隧道，在这些节点中，任务被安排用于连接到覆盖网络的服务。 这些隧道也使用 AES 算法在 GCM 模式，并且管理器节点每12小时自动轮换一次密钥。</p><blockquote><p>不要将Windows节点附加到加密的覆盖网络。<br>Windows不支持覆盖网络加密。如果Windows节点尝试连接到加密的覆盖网络，则不会检测到错误，但是该节点无法通信。</p></blockquote><h4 id="群集模式覆盖网络和独立容器"><a href="#群集模式覆盖网络和独立容器" class="headerlink" title="群集模式覆盖网络和独立容器"></a>群集模式覆盖网络和独立容器</h4><p>您可以同时使用覆盖网络功能，<code>--opt encrypted --attachable</code> 并将非托管容器附加到该网络：</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create --opt encrypted --driver overlay --attachable my-attachable-multi-host-network<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2-自定义默认入口网络"><a href="#2-2-自定义默认入口网络" class="headerlink" title="2.2 自定义默认入口网络"></a>2.2 自定义默认入口网络</h3><p>大多数用户从不需要配置<code>ingress</code>网络，但是Docker 17.05及更高版本允许您进行配置。如果自动选择的子网与网络上已经存在的子网发生冲突，或者您需要自定义其他低级别的网络设置（例如MTU），这将很有用。</p><p>自定义<code>ingress</code>网络涉及删除并重新创建它。这通常在集群中创建任何服务之前完成。如果您拥有发布端口的现有服务，那么在删除<code>ingress</code>网络之前需要删除这些服务。</p><p>在没有<code>ingress</code>网络的时候，不发布端口的现有服务继续运行，但是负载不平衡。 这会影响发布端口的服务，比如发布端口80的 WordPress 服务。</p><ol><li><p>使用<code>docker network inspect ingress</code>检查<code>ingress</code>网络，并移除与其连接的容器的任何服务。这些是发布端口的服务，例如发布端口80的WordPress服务。如果不停止所有这些服务，下一步就会失败。</p></li><li><p>移除现有<code>ingress</code>网络：</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network <span class="token function">rm</span> ingress

WARNING<span class="token operator">!</span> Before removing the routing-mesh network, <span class="token function">make</span> sure all the nodes
<span class="token keyword">in</span> your swarm run the same docker engine version. Otherwise, removal may not
be effective and functionality of newly created ingress networks will be
impaired.
Are you sure you want to continue? <span class="token punctuation">[</span>y/N<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用<code>--ingress</code>标志创建一个新的覆盖网络，以及您想要设置的自定义选项。 此示例将 MTU 设置为1200，将子网设置为<code>10.11.0.0/16</code>，并将网关设置为<code>10.11.0.2</code>。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create \
--driver overlay \
--ingress \
--subnet<span class="token operator">=</span>10.11.0.0/16 \
--gateway<span class="token operator">=</span>10.11.0.2 \
--opt com.docker.network.driver.mtu<span class="token operator">=</span>1200 \
my-ingress<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意</strong>：您可以将<code>ingress</code>网络命名为别的名称，但只能有一个。 试图创建第二个的尝试失败。</p></blockquote></li><li><p>重新启动在第一步中停止的服务。</p></li></ol><h3 id="2-3-自定义docker-gwbridge接口"><a href="#2-3-自定义docker-gwbridge接口" class="headerlink" title="2.3 自定义docker_gwbridge接口"></a>2.3 自定义docker_gwbridge接口</h3><p><code>docker_gwbridge</code>是一个虚拟网桥，它将覆盖网络(包括入口网络)连接到单个 Docker 守护进程的物理网络。 当初始化一个群或者将一个 Docker 主机加入到一个群中时，Docker 会自动创建它，但它不是 Docker 设备。 它存在于 Docker 主机的内核中。 如果您需要自定义它的设置，那么您必须在加入 Docker 主机到群体之前或者从群体中临时移除主机之后这样做。</p><ol><li><p>停止 Docker。</p></li><li><p>删除现有的 <code>docker gwbridge</code> 接口。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> ip <span class="token function">link</span> <span class="token keyword">set</span> docker_gwbridge down

$ <span class="token function">sudo</span> ip <span class="token function">link</span> del dev docker_gwbridge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>启动 Docker。不要连接或初始化集群服务。</p></li><li><p>使用自定义设置，使用 <code>docker network Create</code> 命令手动创建或重新创建 <code>docker gwbridge</code>。 此示例使用子网<code>10.11.0.0 / 16</code>。 有关可自定义选项的完整列表，请参见桥接驱动程序选项。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create \
\--subnet 10.11.0.0/16 \
\--opt com.docker.network.bridge.name<span class="token operator">=</span>docker_gwbridge \
\--opt com.docker.network.bridge.enable_icc<span class="token operator">=</span>false \
\--opt com.docker.network.bridge.enable_ip_masquerade<span class="token operator">=</span>true \
docker_gwbridge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>初始化或加入群。由于桥已经存在，Docker 不会自动创建它。</p></li></ol><h2 id="3-群服务的操作"><a href="#3-群服务的操作" class="headerlink" title="3. 群服务的操作"></a>3. 群服务的操作</h2><h3 id="3-1-在覆盖网络上发布端口"><a href="#3-1-在覆盖网络上发布端口" class="headerlink" title="3.1 在覆盖网络上发布端口"></a>3.1 在覆盖网络上发布端口</h3><p>连接到同一覆盖网络的群服务有效地将所有端口相互暴露。 对于可以在服务之外访问的端口，必须使用 <code>-p</code> 或 <code>-- publish</code> 标志在 <code>docker service create</code> 或 <code>docker service update</code>时发布该端口。 支持旧的冒号分隔语法和新的逗号分隔值语法。 较长的语法是首选的，因为它在一定程度上是自文档化的。</p><table><thead><tr><th align="center">标志值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">-p 8080:80 - p 8080:80 或 -p published=8080,target=80</td><td align="left">将服务上的 TCP 端口80映射到路由网格上的端口8080</td></tr><tr><td align="center">-p 8080:80/udp 或 -p published=8080,target=80,protocol=udp</td><td align="left">将服务上的 UDP 端口80映射到路由网上的端口8080</td></tr><tr><td align="center">-p 8080:80/tcp -p 8080:80/udp 或 -p published=8080,target=80,protocol=tcp -p published=8080,target=80,protocol=udp</td><td align="left">将服务上的 TCP 端口80映射到路由网格上的 TCP 端口8080，将服务上的 UDP 端口80映射到路由网格上的 UDP 端口8080</td></tr></tbody></table><h3 id="3-2-绕过集群服务的路由网格"><a href="#3-2-绕过集群服务的路由网格" class="headerlink" title="3.2 绕过集群服务的路由网格"></a>3.2 绕过集群服务的路由网格</h3><p>默认情况下，发布端口的群服务使用路由网格来发布端口。 当您连接到任何群节点上的发布端口时(无论它是否运行给定的服务) ，您都会被重定向到正在透明地运行该服务的工作节点。 实际上，Docker 充当了你的群服务的负载平衡器。 使用路由网格的服务以虚拟 IP (VIP)模式运行。 即使是在每个节点上运行的服务(通过 <code>-- mode glocal</code>标志)也使用路由网格。 当使用路由网格时，不能保证哪个 Docker 节点为客户机请求提供服务。</p><p>要绕过路由网格，可以通过将 <code>-- endpoint-mode</code> 标志设置为 <code>dnsrr</code>，使用 DNS Round Robin (DNSRR)模式启动服务。 您必须在集群服务前面运行自己的负载均衡器。 针对 Docker 主机上的服务名称的 DNS 查询将返回运行该服务的节点的 IP 地址列表。 配置您的负载平衡器来使用这个列表并平衡节点之间的流量。</p><h3 id="3-3-分离控制和数据通信"><a href="#3-3-分离控制和数据通信" class="headerlink" title="3.3 分离控制和数据通信"></a>3.3 分离控制和数据通信</h3><p>默认情况下，与集群管理和应用程序之间的通信相关的控制通信在同一网络上运行，不过群控通信是加密的。 您可以将 Docker 配置为使用单独的网络接口来处理两种不同类型的流量。 初始化或加入群时，分别指定 ·– advertised-addr· 和 ·– datapath-addr·。 您必须为加入群的每个节点执行此操作。</p><h2 id="4-覆盖网络上独立容器的操作"><a href="#4-覆盖网络上独立容器的操作" class="headerlink" title="4. 覆盖网络上独立容器的操作"></a>4. 覆盖网络上独立容器的操作</h2><h3 id="4-1-将独立的容器连接到覆盖网络"><a href="#4-1-将独立的容器连接到覆盖网络" class="headerlink" title="4.1 将独立的容器连接到覆盖网络"></a>4.1 将独立的容器连接到覆盖网络</h3><p><code>ingress</code>网络是在没有<code>-- attachable</code>标志的情况下创建的，这意味着只有群服务可以使用它，而不是单独的容器。 您可以将独立容器连接到用户定义的覆盖网络，这些覆盖网络是用 <code>-- attachable</code>标志创建的。 这使得运行在不同 Docker 守护进程上的独立容器能够进行通信，而无需在单个 Docker 守护进程主机上设置路由。</p><h3 id="4-2-发布端口"><a href="#4-2-发布端口" class="headerlink" title="4.2 发布端口"></a>4.2 发布端口</h3><table><thead><tr><th align="center">标志值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">-p 8080:80</td><td align="left">将容器中的 TCP 端口80映射到覆盖网络上的8080端口</td></tr><tr><td align="center">-p 8080:80/udp</td><td align="left">在覆盖网络上将容器中的 UDP 端口80映射到8080端口</td></tr><tr><td align="center">-p 8080:80/sctp</td><td align="left">将容器中的 SCTP 端口80映射到覆盖网络上的8080端口</td></tr><tr><td align="center">p 8080:80/tcp -p 8080:80/udp</td><td align="left">将容器内的 TCP 端口80映射到覆盖网络上的 TCP 端口8080，将容器内的 UDP 端口80映射到覆盖网络上的 UDP 端口8080</td></tr></tbody></table><h3 id="4-3-容器发现"><a href="#4-3-容器发现" class="headerlink" title="4.3 容器发现"></a>4.3 容器发现</h3><p>对于大多数情况，应该连接到服务名称，该名称是负载平衡的，由支持服务的所有容器(“任务”)处理。 若要获取支持服务的所有任务的列表，请对任务执行 DNS 查找 <code>tasks.&lt;service-name&gt;</code>。</p><h2 id="5-实践练习-覆盖网络"><a href="#5-实践练习-覆盖网络" class="headerlink" title="5. 实践练习 覆盖网络"></a>5. 实践练习 覆盖网络</h2><ul><li><p><code>使用默认覆盖网络</code> 演示了如何在初始化或加入群集时使用Docker自动为您设置的默认覆盖网络。该网络不是生产系统的最佳选择。</p></li><li><p><code>使用用户定义的覆盖网络</code> 演示了如何创建和使用自己的自定义覆盖网络来连接服务。建议将其用于生产中运行的服务。</p></li><li><p><code>将覆盖网络用于独立容器</code> 演示了如何使用覆盖网络在不同Docker守护程序上的独立容器之间进行通信。</p></li><li><p><code>容器与群集服务之间的通信</code> 演示了使用可附加的覆盖网络，在独立容器和群服务之间建立通信。 这在 Docker 17.06及更高版本中得到了支持。</p></li></ul><h3 id="5-1-前提条件"><a href="#5-1-前提条件" class="headerlink" title="5.1 前提条件"></a>5.1 前提条件</h3><p>这些要求您至少有一个单节点群集，这意味着您已启动Docker并docker swarm init在主机上运行。您也可以在多节点群集上运行示例。</p><p>最后一个示例需要Docker 17.06或更高版本。</p><h3 id="5-2-使用默认的覆盖网络"><a href="#5-2-使用默认的覆盖网络" class="headerlink" title="5.2 使用默认的覆盖网络"></a>5.2 使用默认的覆盖网络</h3><p>在这个示例中，您将启动一个 alpine 服务，并从单个服务容器的角度检查网络的特性。</p><h4 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h4><p>本教程需要三个物理或虚拟的 Docker 主机，它们都可以相互通信，都运行 Docker 17.03或更高版本的新安装。 本教程假设三台主机在同一网络上运行，不涉及防火墙。</p><p>这些主机将被称为 manager、 worker-1和 worker-2。 管理器主机既是管理节点又是工作节点，这意味着它既可以运行服务任务，也可以管理集群。 工作节点1号和工作节点2号只起工作节点的作用,</p><p>如果你手头没有三台主机，一个简单的解决方案是在云提供商(比如 Amazon EC2)上安装三台 Ubuntu 主机，它们都在同一个网络上，允许所有主机通信(使用 EC2安全组之类的机制) ，然后按照 Ubuntu 上 Docker Engine-Community 的安装说明进行安装。</p><h4 id="演练"><a href="#演练" class="headerlink" title="演练"></a>演练</h4><h5 id="创造集群"><a href="#创造集群" class="headerlink" title="创造集群"></a>创造集群</h5><p>在这个过程的最后，所有三个 Docker 主机将被加入到群体中，并且将使用一个称为入口的覆盖网络连接在一起。</p><ol><li><p>在 manager. 上初始化群。如果主机只有一个网络接口，则 – advertised-addr 标志是可选的。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker swarm init --advertise-addr<span class="token operator">=</span><span class="token operator">&lt;</span>IP-ADDRESS-OF-MANAGER<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>记下输出的文本，因为它包含将用于将 worker-1和 worker-2加入到群体中的令牌。 将令牌存储在密码管理器中是一个好主意。</p></li><li><p>在 worker-1上，加入群体。如果主机只有一个网络接口，则 – advertised-addr 标志是可选的。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker swarm <span class="token function">join</span> --token <span class="token operator">&lt;</span>TOKEN<span class="token operator">></span> \
--advertise-addr <span class="token operator">&lt;</span>IP-ADDRESS-OF-WORKER-1<span class="token operator">></span> \
<span class="token operator">&lt;</span>IP-ADDRESS-OF-MANAGER<span class="token operator">></span>:2377<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>在 worker-2上，加入群体。如果主机只有一个网络接口，则 – advertised-addr 标志是可选的。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker swarm <span class="token function">join</span> --token <span class="token operator">&lt;</span>TOKEN<span class="token operator">></span> \
--advertise-addr <span class="token operator">&lt;</span>IP-ADDRESS-OF-WORKER-2<span class="token operator">></span> \
<span class="token operator">&lt;</span>IP-ADDRESS-OF-MANAGER<span class="token operator">></span>:2377<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>在管理节点上，列出所有的节点。这个命令只能从管理器执行。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker node <span class="token function">ls</span>

ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS
d68ace5iraw6whp7llvgjpu48 *   ip-172-31-34-146    Ready               Active              Leader
nvp5rwavvb8lhdggo8fcf7plg     ip-172-31-35-151    Ready               Active
ouvx2l7qfcxisoyms8mtkgahw     ip-172-31-36-89     Ready               Active<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你还可以使用-filter 标志按角色进行筛选:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker node <span class="token function">ls</span> --filter role<span class="token operator">=</span>manager

ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS
d68ace5iraw6whp7llvgjpu48 *   ip-172-31-34-146    Ready               Active              Leader

$ docker node <span class="token function">ls</span> --filter role<span class="token operator">=</span>worker

ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS
nvp5rwavvb8lhdggo8fcf7plg     ip-172-31-35-151    Ready               Active
ouvx2l7qfcxisoyms8mtkgahw     ip-172-31-36-89     Ready               Active<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在 manager、 worker-1和 worker-2上列出 Docker 网络，注意它们现在都有一个覆盖网络，称为<code>ingress</code>网络和一个桥接网络，称为 Docker gwbridge。 这里只显示了 manager 的列表:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network <span class="token function">ls</span>

NETWORK ID          NAME                DRIVER              SCOPE
495c570066be        bridge              bridge              local
961c6cae9945        docker_gwbridge     bridge              local
ff35ceda3643        host                host                local
trtnl4tqnc3n        ingress             overlay             swarm
c8357deec9cb        none                null                local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p><code>Docker gwbridge</code> 将<code>ingress</code>网络与 Docker 主机的网络接口连接起来，这样就可以在群管理节点和工作节点之间进行通信。 如果您创建了群服务，但没有指定网络，那么它们将连接到<code>ingress</code>网络。 建议您为每个应用程序或将一起工作的应用程序组使用单独的覆盖网络。 在下一个过程中，您将创建两个覆盖网络，并将服务连接到每个覆盖网络。</p><h5 id="创造服务"><a href="#创造服务" class="headerlink" title="创造服务"></a>创造服务</h5><ol><li><p>在 manager 上，创建一个新的覆盖网络 nginx-net:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create -d overlay nginx-net<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您不需要在其他节点上创建覆盖网络，因为当其中一个节点开始运行需要它的服务任务时，它将自动创建。</p></li><li><p>在 <code>manager</code> 上，创建一个连接到 <code>nginx-net</code> 的5个副本的 Nginx 服务。 该服务将向外界发布端口80。 所有的服务任务容器都可以在不打开任何端口的情况下相互通信。</p><blockquote><p><strong>注意: 服务只能在管理器上创建。</strong></p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ docker <span class="token function">service</span> create \
--name my-nginx \
--publish target<span class="token operator">=</span>80,published<span class="token operator">=</span>80 \
--replicas<span class="token operator">=</span>5 \
--network nginx-net \
nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认的<code>ingress</code>发布模式，当您没有为 <code>-- publish</code> 标志指定<code>mode</code>模式时使用，这意味着如果您在 manager、 worker-1或 worker-2上浏览到端口80，您将连接到5个服务任务节点之一的端口80，即使当前在您浏览的节点上没有任何任务正在运行。 如果希望使用<code>host</code>主机模式发布端口，可以将<code>mode=host</code>添加到 <code>-- publish</code> 输出。 但是，在这种情况下，您还应该使用 <code>-- mode global</code> 而不是 <code>-- replicas 5</code>，因为只有一个服务任务可以绑定指定节点上的指定端口。</p></li><li><p>运行 <code>docker service ls</code> 来监视服务启动的进度，这可能需要几秒钟。</p></li><li><p>检查<code>manager</code>、<code>worker-1</code>和<code>worker-2</code>的 <code>nginx-net</code> 网络。 请记住，您不需要在 <code>worker-1</code>和 <code>worker-2</code>上手动创建它，因为 Docker 为您创建了它。 输出将很长，但请注意 <code>Containers</code> 和 <code>Peers</code> 部分。 <code>Containers</code>列出从该主机连接到覆盖网络的所有服务任务(或独立容器)。</p></li><li><p>从 manager节点，使用 <code>docker service inspect my-nginx</code> 并注意关于服务使用的端口和端点的信息。</p></li><li><p>创建一个新的网络 nginx-net-2，然后更新该服务以使用该网络而不是 nginx-net:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create -d overlay nginx-net-2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">$ docker <span class="token function">service</span> update \
--network-add nginx-net-2 \
--network-rm nginx-net \
my-nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>运行 <code>docker service ls</code>，以验证服务是否已更新，所有任务是否已重新部署。 运行 <code>docker network inspect nginx-net</code> 以验证没有任何容器连接到它。 对 <code>nginx-net-2</code>运行相同的命令，并注意所有服务任务容器都连接到它。</p><blockquote><p><strong>注意: 即使覆盖网络是根据需要在群工作节点上自动创建的，它们也不会被自动删除。</strong></p></blockquote></li><li><p>清理服务和网络。 从 manager，运行以下命令。 管理节点会指示工作节点自动移除网络。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker <span class="token function">service</span> <span class="token function">rm</span> my-nginx
$ docker network <span class="token function">rm</span> nginx-net nginx-net-2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="5-3-使用用户定义的覆盖网络"><a href="#5-3-使用用户定义的覆盖网络" class="headerlink" title="5.3 使用用户定义的覆盖网络"></a>5.3 使用用户定义的覆盖网络</h3><h4 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h4><p>假设群已经设置好，并且你在管理节点。</p><h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><pre><code>1. 创建用户定义的覆盖网络。

```bash
$ docker network create -d overlay my-overlay
```

2. 使用覆盖网络启动服务，并将端口80发布到 Docker 主机上的端口8080。

```bash
$ docker service create \
--name my-nginx \
--network my-overlay \
--replicas 1 \
--publish published=8080,target=80 \
nginx:latest
```

3. 运行 `docker network inspect my-overlay` 并通过查看 `Containers` 部分来验证 `my-nginx` 服务任务是否连接到它。

4. 删除服务和网络。

```bash
$ docker service rm my-nginx

$ docker network rm my-overlay
```</code></pre><h3 id="5-4-对独立容器使用覆盖网络"><a href="#5-4-对独立容器使用覆盖网络" class="headerlink" title="5.4 对独立容器使用覆盖网络"></a>5.4 对独立容器使用覆盖网络</h3><p>这个示例演示了 DNS 容器发现——具体地说，如何使用覆盖网络在不同的 Docker 守护进程上的独立容器之间进行通信。 步骤如下:</p><ul><li>在节点host1上，将节点初始化为群集（管理器）。</li><li>在节点host2上，将节点加入群集（工作节点）。</li><li>在节点host1上，创建一个可连接的覆盖网络（test-net）。</li><li>在节点host1上，运行一个交互式<code>alpine</code>容器（alpine1）在 test-net上。</li><li>在节点host2上，运行一个独立的交互式<code>alpine</code>容器（alpine2）test-net。</li><li>在节点host1上, <code>alpine1</code> 的会话中 ping <code>alpine2</code>。</li></ul><h4 id="先决条件-1"><a href="#先决条件-1" class="headerlink" title="先决条件"></a>先决条件</h4><p>对于这个测试，您需要两个可以相互通信的 Docker 主机。 每个主机必须具有 Docker 17.06或更高版本，并在两个 Docker 主机之间打开以下端口:</p><ul><li>TCP端口2377</li><li>TCP和UDP端口7946</li><li>UDP端口4789</li></ul><p>一种简单的设置方法是使用两个 vm (本地或像 AWS 这样的云提供商) ，每个 vm 都安装并运行了 Docker。 如果您正在使用 AWS 或类似的云计算平台，最简单的配置是使用一个安全组来打开两台主机之间的所有传入端口，并从客户机的 IP 地址打开 SSH 端口。</p><p>这个例子将我们的群中的两个节点称为 host1和 host2。 这个示例也使用 Linux 主机，但是相同的命令可以在 Windows 上使用。</p><h4 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h4><ol><li><p>设置集群</p><p>a. 在 <code>host1</code>上，初始化一个群(如果提示，使用 <code>-- advertised-addr</code> 为与群中其他主机通信的接口指定 IP 地址，例如 AWS 上的私有 IP 地址) :</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker swarm init
Swarm initialized: current node <span class="token punctuation">(</span>vz1mm9am11qcmo979tlrlox42<span class="token punctuation">)</span> is now a manager.

To add a worker to this swarm, run the following command:

   docker swarm <span class="token function">join</span> --token SWMTKN-1-5g90q48weqrtqryq4kj6ow0e8xm9wmv9o6vgqc5j320ymybd5c-8ex8j0bc40s6hgvy5ui5gl4gy 172.31.47.252:2377

To add a manager to this swarm, run <span class="token string">'docker swarm join-token manager'</span> and follow the instructions.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>b. 在 <code>host2</code>上，按照上面的指示加入蜂群:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker swarm <span class="token function">join</span> --token <span class="token operator">&lt;</span>your_token<span class="token operator">></span> <span class="token operator">&lt;</span>your_ip_address<span class="token operator">></span>:2377
This node joined a swarm as a worker.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果节点未能加入群体，docker 群体将超时加入命令。 要解决这个问题，运行 docker swarm leave ——强制 host2，验证网络和防火墙设置，然后再试一次。</p></li><li><p>在 <code>host1</code>上，创建一个名为 <code>test-net</code> 的可连接覆盖网络:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network create --driver<span class="token operator">=</span>overlay --attachable test-net
uqsof8phj3ak0rq9k86zta6ht<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>请注意返回的 NETWORK ID ——当您从 <code>host2</code>连接到它时，将再次看到它。</p></blockquote></li><li><p>在 <code>host1</code> 上，启动一个连接到 <code>test-net</code> 的交互式(- it)容器(alpine1) :</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run -it --name alpine1 --network test-net alpine
/ <span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>在 <code>host2</code> 上，列出可用的网络——注意 <code>test-net</code> 还不存在:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network <span class="token function">ls</span>
NETWORK ID          NAME                DRIVER              SCOPE
ec299350b504        bridge              bridge              local
66e77d0d0e9a        docker_gwbridge     bridge              local
9f6ae26ccb82        host                host                local
omvdxqrda80z        ingress             overlay             swarm
b65c952a4b2b        none                null                local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在 <code>host2</code> 上，启动一个连接到 <code>test-net</code> 的独立(- d)和交互(- it)容器(alpine2) :</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run -dit --name alpine2 --network test-net alpine
fb635f5ece59563e7b8b99556f816d24e6949a5f6a5b1fbd92ca244db17a4342<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>自动 DNS 容器发现只适用于唯一的容器名。</p></blockquote></li><li><p>在 <code>host2</code> 上，验证创建了 <code>test-net</code> (并且在 <code>host1</code> 上具有与 <code>test-net</code> 相同的 NETWORK ID) :</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network <span class="token function">ls</span>
NETWORK ID          NAME                DRIVER              SCOPE
<span class="token punctuation">..</span>.
uqsof8phj3ak        test-net            overlay             swarm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在 <code>host1</code> 上，ping <code>alpine2</code> 在 <code>alpine1</code>的交互终端上:</p><pre class="line-numbers language-bash"><code class="language-bash">/ <span class="token comment" spellcheck="true"># ping -c 2 alpine2</span>
PING alpine2 <span class="token punctuation">(</span>10.0.0.5<span class="token punctuation">)</span>: 56 data bytes
64 bytes from 10.0.0.5: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.600 ms
64 bytes from 10.0.0.5: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.555 ms

\--- alpine2 <span class="token function">ping</span> statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max <span class="token operator">=</span> 0.555/0.577/0.600 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个容器与连接两台主机的覆盖网络通信。 如果你在 host2上运行另一个不是分离的 alpine 容器，你可以从 host2中 ping alpine1(在这里我们添加了自动容器清理的 remove 选项) :</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run -it --rm --name alpine3 --network test-net alpine
/ <span class="token comment" spellcheck="true"># ping -c 2 alpine1</span>
/ <span class="token comment" spellcheck="true"># exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>在 host1上，关闭 alpine1会话(它也会停止容器) :</p><pre class="line-numbers language-bash"><code class="language-bash">/ <span class="token comment" spellcheck="true"># exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>清理你的容器和网络:</p><p>您必须独立地停止和删除每个主机上的容器，因为 Docker 守护进程是独立运行的，而且它们是独立的容器。 您只需要删除 host1上的网络，因为当您在 host2上停止 alpine2时，test-net 就会消失。</p><p>在 host2上，停止使用 alpine2，检查测试网是否被移除，然后移除 alpine2:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container stop alpine2
$ docker network <span class="token function">ls</span>
$ docker container <span class="token function">rm</span> alpine2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在 host1上，删除 alpine1和 test-net:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container <span class="token function">rm</span> alpine1
$ docker network <span class="token function">rm</span> test-net<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="5-5-容器和群服务之间的通信"><a href="#5-5-容器和群服务之间的通信" class="headerlink" title="5.5 容器和群服务之间的通信"></a>5.5 容器和群服务之间的通信</h3><h4 id="先决条件-2"><a href="#先决条件-2" class="headerlink" title="先决条件"></a>先决条件</h4><p>本例中需要 Docker 17.06或更高版本。</p><h4 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h4><p>在本例中，您在同一个 Docker 主机上启动两个不同的 alpine 容器，并进行一些测试以了解它们如何彼此通信。 您需要安装并运行 Docker。</p><ol><li><p>打开终端窗口。 在你做任何事情之前列出当前的网络。 如果您从未在这个 Docker 守护进程上添加过网络或初始化过一个群，下面是您应该看到的内容。 你可能会看到不同的网络，但是你至少应该看到这些(网络 id 不同) :</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network <span class="token function">ls</span>

NETWORK ID          NAME                DRIVER              SCOPE
17e324f45964        bridge              bridge              local
6ed54d316334        host                host                local
7092879f2cc8        none                null                local
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>列出了缺省桥接网络、主机和 none。 后两者不是完全成熟的网络，但用于启动直接连接到 Docker 守护进程主机的网络堆栈的容器，或者启动没有网络设备的容器。 本教程将把两个容器连接到桥接网络。</p></li><li><p>启动两个运行阿尔卑斯灰的容器，这是阿尔卑斯的默认外壳而不是猛击。 Dit 标志意味着启动分离的容器(在后台)、交互式的容器(可以在其中键入内容)和 TTY (这样您就可以看到输入和输出)。 因为是分离启动的，所以不会马上连接到容器。 相反，容器的 ID 将被打印出来。 因为您没有指定任何 – 网络标志，所以容器连接到默认的网桥网络。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker run -dit --name alpine1 alpine ash

$ docker run -dit --name alpine2 alpine ash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>检查两个容器是否实际启动:</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container <span class="token function">ls</span>

CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
602dbf1edc81        alpine              <span class="token string">"ash"</span>               4 seconds ago       Up 3 seconds                            alpine2
da33b7aa74b0        alpine              <span class="token string">"ash"</span>               17 seconds ago      Up 16 seconds  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>检查桥接网络，看看有哪些容器连接到它。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker network inspect bridge

<span class="token punctuation">[</span>
 <span class="token punctuation">{</span>
     <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"bridge"</span>,
     <span class="token string">"Id"</span><span class="token keyword">:</span> <span class="token string">"17e324f459648a9baaea32b248d3884da102dde19396c25b30ec800068ce6b10"</span>,
     <span class="token string">"Created"</span><span class="token keyword">:</span> <span class="token string">"2017-06-22T20:27:43.826654485Z"</span>,
     <span class="token string">"Scope"</span><span class="token keyword">:</span> <span class="token string">"local"</span>,
     <span class="token string">"Driver"</span><span class="token keyword">:</span> <span class="token string">"bridge"</span>,
     <span class="token string">"EnableIPv6"</span><span class="token keyword">:</span> false,
     <span class="token string">"IPAM"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>
         <span class="token string">"Driver"</span><span class="token keyword">:</span> <span class="token string">"default"</span>,
         <span class="token string">"Options"</span><span class="token keyword">:</span> null,
         <span class="token string">"Config"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>
             <span class="token punctuation">{</span>
                 <span class="token string">"Subnet"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.0/16"</span>,
                 <span class="token string">"Gateway"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.1"</span>
             <span class="token punctuation">}</span>
         <span class="token punctuation">]</span>
     <span class="token punctuation">}</span>,
     <span class="token string">"Internal"</span><span class="token keyword">:</span> false,
     <span class="token string">"Attachable"</span><span class="token keyword">:</span> false,
     <span class="token string">"Containers"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>
         <span class="token string">"602dbf1edc81813304b6cf0a647e65333dc6fe6ee6ed572dc0f686a3307c6a2c"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>
             <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"alpine2"</span>,
             <span class="token string">"EndpointID"</span><span class="token keyword">:</span> <span class="token string">"03b6aafb7ca4d7e531e292901b43719c0e34cc7eef565b38a6bf84acf50f38cd"</span>,
             <span class="token string">"MacAddress"</span><span class="token keyword">:</span> <span class="token string">"02:42:ac:11:00:03"</span>,
             <span class="token string">"IPv4Address"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.3/16"</span>,
             <span class="token string">"IPv6Address"</span><span class="token keyword">:</span> <span class="token string">""</span>
         <span class="token punctuation">}</span>,
         <span class="token string">"da33b7aa74b0bf3bda3ebd502d404320ca112a268aafe05b4851d1e3312ed168"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>
             <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"alpine1"</span>,
             <span class="token string">"EndpointID"</span><span class="token keyword">:</span> <span class="token string">"46c044a645d6afc42ddd7857d19e9dcfb89ad790afb5c239a35ac0af5e8a5bc5"</span>,
             <span class="token string">"MacAddress"</span><span class="token keyword">:</span> <span class="token string">"02:42:ac:11:00:02"</span>,
             <span class="token string">"IPv4Address"</span><span class="token keyword">:</span> <span class="token string">"172.17.0.2/16"</span>,
             <span class="token string">"IPv6Address"</span><span class="token keyword">:</span> <span class="token string">""</span>
         <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>,
     <span class="token string">"Options"</span><span class="token keyword">:</span> <span class="token punctuation">{</span>
         <span class="token string">"com.docker.network.bridge.default_bridge"</span><span class="token keyword">:</span> <span class="token string">"true"</span>,
         <span class="token string">"com.docker.network.bridge.enable_icc"</span><span class="token keyword">:</span> <span class="token string">"true"</span>,
         <span class="token string">"com.docker.network.bridge.enable_ip_masquerade"</span><span class="token keyword">:</span> <span class="token string">"true"</span>,
         <span class="token string">"com.docker.network.bridge.host_binding_ipv4"</span><span class="token keyword">:</span> <span class="token string">"0.0.0.0"</span>,
         <span class="token string">"com.docker.network.bridge.name"</span><span class="token keyword">:</span> <span class="token string">"docker0"</span>,
         <span class="token string">"com.docker.network.driver.mtu"</span><span class="token keyword">:</span> <span class="token string">"1500"</span>
     <span class="token punctuation">}</span>,
     <span class="token string">"Labels"</span><span class="token keyword">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在顶部附近，列出了有关桥接网络的信息，包括 Docker 主机和桥接网络之间网关的 IP 地址(172.17.0.1)。 在 Containers 键下，列出了每个连接的容器，以及有关其 IP 地址的信息(alpine1为172.17.0.2，alpine2为172.17.0.3)。</p></li><li><p>容器在后台运行。使用 <code>docker attach</code> 命令连接到 <code>alpine1</code>。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker attach alpine1

/ <span class="token comment" spellcheck="true">#</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>提示将更改为 <code>#</code> ，以指示您是容器中的根用户。 使用 <code>ip addr show</code> 命令显示 <code>alpine1</code>的网络接口，因为它们从容器内部观察:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ip addr show</span>

1: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">></span> mtu 65536 qdisc noqueue state UNKNOWN qlen 1
 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
 inet 127.0.0.1/8 scope host lo
   valid_lft forever preferred_lft forever
 inet6 ::1/128 scope host
   valid_lft forever preferred_lft forever
27: eth0@if28: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN<span class="token operator">></span> mtu 1500 qdisc noqueue state UP
 link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
 inet 172.17.0.2/16 scope global eth0
   valid_lft forever preferred_lft forever
 inet6 fe80::42:acff:fe11:2/64 scope <span class="token function">link</span>
   valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个接口是环回设备。 暂时忽略它。 请注意，第二个接口的 IP 地址为172.17.0.2，与前面步骤中显示的 alpine1的地址相同。</p></li><li><p>在 <code>alpine1</code> 内部，确保你可以通过 <code>ping google.com</code> 连接到互联网。 <code>-c 2</code> 标志将命令限制为两次 ping 尝试。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ping -c 2 google.com</span>

PING google.com <span class="token punctuation">(</span>172.217.3.174<span class="token punctuation">)</span>: 56 data bytes
64 bytes from 172.217.3.174: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>41 time<span class="token operator">=</span>9.841 ms
64 bytes from 172.217.3.174: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>41 time<span class="token operator">=</span>9.897 ms

\--- google.com <span class="token function">ping</span> statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max <span class="token operator">=</span> 9.841/9.869/9.897 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>现在尝试 ping 第二个容器，首先，ping 它的 IP 地址，172.17.0.3:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ping -c 2 172.17.0.3</span>

PING 172.17.0.3 <span class="token punctuation">(</span>172.17.0.3<span class="token punctuation">)</span>: 56 data bytes
64 bytes from 172.17.0.3: seq<span class="token operator">=</span>0 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.086 ms
64 bytes from 172.17.0.3: seq<span class="token operator">=</span>1 ttl<span class="token operator">=</span>64 time<span class="token operator">=</span>0.094 ms

\--- 172.17.0.3 <span class="token function">ping</span> statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max <span class="token operator">=</span> 0.086/0.090/0.094 ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成功。接下来，尝试按容器名称 ping alpine2容器。这将失败。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># ping -c 2 alpine2</span>

ping: bad address <span class="token string">'alpine2'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>通过使用分离序列，CTRL + p CTRL + q (按住 CTRL，输入 p 后跟 q)从 <code>alpine1</code>中分离，而不停止它。 如果你愿意，连接到 <code>alpine2</code>，重复步骤4,5,6，用 <code>alpine1</code>代替 <code>alpine2</code>。</p></li><li><p>停止并移走两个容器。</p><pre class="line-numbers language-bash"><code class="language-bash">$ docker container stop alpine1 alpine2
$ docker container <span class="token function">rm</span> alpine1 alpine2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>请记住，生产环境中不推荐使用默认的网桥网络。 要了解用户定义的桥梁网络，请继续阅读下一个教程。</p></li></ol><script>document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });</script></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者:</i></span> <span class="reprint-info"><a href="/about" rel="external nofollow noreferrer">Baymax</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接:</i></span> <span class="reprint-info"><a href="https://baymax.tips/posts/11593.html">https://baymax.tips/posts/11593.html</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明:</i></span> <span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="/about" target="_blank">Baymax</a> !</span></div></div><script async defer>document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/Docker/"><span class="chip bg-color">Docker</span></a> <a href="/tags/%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1/"><span class="chip bg-color">容器服务</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div><style>#reward{margin:40px 0;text-align:center}#reward .reward-link{font-size:1.4rem;line-height:38px}#reward .btn-floating:hover{box-shadow:0 6px 12px rgba(0,0,0,.2),0 5px 15px rgba(0,0,0,.2)}#rewardModal{width:320px;height:350px}#rewardModal .reward-title{margin:15px auto;padding-bottom:5px}#rewardModal .modal-content{padding:10px}#rewardModal .close{position:absolute;right:15px;top:15px;color:rgba(0,0,0,.5);font-size:1.3rem;line-height:20px;cursor:pointer}#rewardModal .close:hover{color:#ef5350;transform:scale(1.3);-moz-transform:scale(1.3);-webkit-transform:scale(1.3);-o-transform:scale(1.3)}#rewardModal .reward-tabs{margin:0 auto;width:210px}.reward-tabs .tabs{height:38px;margin:10px auto;padding-left:0}.reward-content ul{padding-left:0!important}.reward-tabs .tabs .tab{height:38px;line-height:38px}.reward-tabs .tab a{color:#fff;background-color:#ccc}.reward-tabs .tab a:hover{background-color:#ccc;color:#fff}.reward-tabs .wechat-tab .active{color:#fff!important;background-color:#22ab38!important}.reward-tabs .alipay-tab .active{color:#fff!important;background-color:#019fe8!important}.reward-tabs .reward-img{width:210px;height:210px}</style><div id="reward"><a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a><div id="rewardModal" class="modal"><div class="modal-content"><a class="close modal-close"><i class="fas fa-times"></i></a><h4 class="reward-title">你的赏识是我前进的动力</h4><div class="reward-content"><div class="reward-tabs"><ul class="tabs row"><li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li><li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li></ul><div id="alipay"><img src="/medias/loading.gif" data-original="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码"></div><div id="wechat"><img src="/medias/loading.gif" data-original="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码"></div></div></div></div></div></div><script>$(function(){$(".tabs").tabs()})</script></div></div><link rel="stylesheet" href="/libs/gitalk/gitalk.css"><link rel="stylesheet" href="/css/my-gitalk.css"><div class="card gitalk-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="gitalk-container" class="card-content"></div></div><script src="/libs/gitalk/gitalk.min.js"></script><script>let gitalk = new Gitalk({
        clientID: '409bf7f6a2a9bcc0f9e6',
        clientSecret: '1cafe266ac7e32c87692df3d52b9a16b773e8c31',
        repo: 'baymax-tips.github.io',
        owner: 'baymax-tips',
        admin: "baymax-tips",
        id: '2020-05-24T22-09-28',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i> &nbsp;上一篇</div><div class="card"><a href="/posts/42665.html"><div class="card-image"><img src="/medias/loading.gif" data-original="/medias/featureimages/5.jpg" class="responsive-img" alt="Docker入门系列  7. Docker 容器网络的概念及网络配置 主机网络"> <span class="card-title">Docker入门系列 7. Docker 容器网络的概念及网络配置 主机网络</span></div></a><div class="card-content article-content"><div class="summary block-with-text">1. 使用主机网络如果您使用容器的主机网络模式，那么容器的网络堆栈不会与 Docker 主机隔离(容器共享主机的网络名称空间) ，并且容器不会得到自己的 ip 地址分配。 例如，如果您运行一个绑定到端口80的容器，并且使用主机网络，那么容器</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2020-05-25</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1/" class="post-category">容器服务</a></span></div></div><div class="card-action article-tags"><a href="/tags/Docker/"><span class="chip bg-color">Docker</span></a> <a href="/tags/%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1/"><span class="chip bg-color">容器服务</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/posts/27457.html"><div class="card-image"><img src="/medias/loading.gif" data-original="/medias/featureimages/21.jpg" class="responsive-img" alt="Docker入门系列  4. Docker 容器网络的概念及网络配置 网桥网络"> <span class="card-title">Docker入门系列 4. Docker 容器网络的概念及网络配置 网桥网络</span></div></a><div class="card-content article-content"><div class="summary block-with-text">1. 使用网桥网络就网络而言，桥接网络是在网段之间转发流量的链路层设备。桥接器可以是在主机内核中运行的硬件设备或软件设备。 就 Docker 而言，桥接网络使用一个软件桥接器，它允许连接到同一桥接网络的容器进行通信，同时提供与未连接到桥接网</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2020-05-22</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1/" class="post-category">容器服务</a></span></div></div><div class="card-action article-tags"><a href="/tags/Docker/"><span class="chip bg-color">Docker</span></a> <a href="/tags/%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1/"><span class="chip bg-color">容器服务</span></a></div></div></div></div></article></div><script src="/libs/codeBlock/codeBlockFuction.js"></script><script src="/libs/codeBlock/codeLang.js"></script><script src="/libs/codeBlock/codeCopy.js"></script><script src="/libs/codeBlock/codeShrink.js"></script><style>code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });</script></main><footer class="page-footer bg-color"><link rel="stylesheet" href="/libs/aplayer/APlayer.min.css"><style>.aplayer .aplayer-lrc p{display:none;font-size:12px;font-weight:700;line-height:16px!important}.aplayer .aplayer-lrc p.aplayer-lrc-current{display:none;font-size:15px;color:#42b983}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{left:-66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover{left:0!important}</style><div><div class="row"><meting-js class="col l8 offset-l2 m10 offset-m1 s12" server="netease" type="playlist" id="503838841" fixed="true" autoplay theme="#42b983" loop order="random" preload="auto" volume="0.7" list-folded="true"></meting-js></div></div><script src="/libs/aplayer/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><div class="container row center-align" style="margin-bottom:0!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2019</span> <a href="/about" target="_blank">Baymax</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br><span id="busuanzi_container_site_pv">|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次</span> <span id="busuanzi_container_site_uv">|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br><br></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/baymax-tips" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i></a><a href="mailto:baymax.tips@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i></a><a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1104559822" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1104559822" data-position="top" data-delay="50"><i class="fab fa-qq"></i></a><a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fas fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i> &nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="/js/search.js"></script><script>$(function(){searchFunc("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-arrow-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?0c003470f128eba63e9f505647bc17bd";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/libs/others/clicklove.js" async></script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script src="/libs/background/ribbon-dynamic.js" async></script><script src="/libs/instantpage/instantpage.js" type="module"></script><script>window.imageLazyLoadSetting={isSPA:!1,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=i;var e=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=r[a].getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight+240||document.documentElement.clientHeight+240)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e()},n.src=i}()}i(),n.addEventListener("scroll",function(){var t,e;t=i,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script></body></html>